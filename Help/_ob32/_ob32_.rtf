{\rtf1\ansi\deff0\deftab720{\fonttbl{\f0\fswiss MS Sans Serif;}{\f1\froman\fcharset2 Symbol;}{\f2\fswiss\fprq2 Arial;}{\f3\froman Times New Roman;}{\f4\fmodern\fprq1 Courier;}{\f5\fmodern\fprq1 Courier New;}{\f6\froman\fprq2 Times New Roman;}}
{\colortbl\red0\green0\blue0;\red0\green255\blue0;\red0\green128\blue0;}
\deflang1031\pard\plain\f2\fs16\up6 #$K\plain\lang2057\f2\fs28  Oberon Help Index
\par \plain\lang2057\f2\fs20 
\par \plain\lang2057\f2\fs20\strike Opal\plain\lang2057\f2\fs20 Basic_Libraries
\par 
\par \plain\lang2057\f2\fs20\strike The Programming Language Oberon-2\plain\lang2057\f2\fs20 Oberon2
\par \plain\lang2057\f2\fs20\strike Information specific to the RA Oberon-2 Compiler\plain\lang2057\f2\fs20 Oberon2_Extensions
\par 
\par \plain\f2\fs16\up6 #$K\plain\lang2057\f2\fs28  OPAL
\par \plain\lang2057\f2\fs20 Oberon Portable Applications Library Rel. 1.0 32 Bit
\par 
\par Basic modules
\par \plain\f2\fs20\cf1\strike module Strings\plain\f2\fs20 Strings
\par \plain\f2\fs20\cf1\strike module Float\plain\f2\fs20 Float
\par \plain\f2\fs20\cf1\strike module Utils\plain\f2\fs20 Utils
\par \plain\f2\fs20\cf1\strike module OOBase\plain\f2\fs20 OOBase
\par \plain\f2\fs20\cf1\strike module Param\plain\f2\fs20 Param
\par \plain\f2\fs20\cf1\strike module Process\plain\f2\fs20 Process
\par \plain\lang2057\f2\fs20 
\par User Interface
\par \plain\f2\fs20\cf1\strike module Display\plain\f2\fs20 Display
\par \plain\f2\fs20\cf1\strike module ColorPlane\plain\f2\fs20 ColorPlane
\par \plain\lang2057\f2\fs20 
\par File System Access
\par \plain\f2\fs20\cf1\strike module File\plain\f2\fs20 File
\par \plain\f2\fs20\cf1\strike module Volume\plain\f2\fs20 Volume
\par \plain\lang2057\f2\fs20 
\par Printing
\par \plain\f2\fs20\cf1\strike module Print\plain\f2\fs20 Print
\par \plain\lang2057\f2\fs20 
\par Compatibility modules according to the Oakwood Guidelines
\par \plain\f2\fs20\cf1\strike module In\plain\f2\fs20 In
\par \plain\f2\fs20\cf1\strike module Out\plain\f2\fs20 Out
\par \plain\f2\fs20\cf1\strike module XYplane\plain\f2\fs20 XYplane
\par \plain\f2\fs16\up6 #$K\plain\lang2057\f2\fs28  Oberon - 2
\par \plain\lang2057\f2\fs20 Oberon - 2 was developed at the ETH Z\'fcrich.
\par This chapter of the help text contains most of the information found in a paper by H. M\'f6ssenb\'f6ck and N. Wirth, "The Programming Language Oberon - 2".
\par 
\par \plain\lang2057\f2\fs20\strike Syntax\plain\lang2057\f2\fs20 Syntax
\par \plain\lang2057\f2\fs20\strike Vocabulary and Representation\plain\lang2057\f2\fs20 Vocabulary_Representation
\par \plain\lang2057\f2\fs20\strike Declarations and scope rules\plain\lang2057\f2\fs20 Declarationsandscoperules
\par \plain\lang2057\f2\fs20\strike Constant declarations\plain\lang2057\f2\fs20 Constantdeclarations
\par \plain\lang2057\f2\fs20\strike Type declarations\plain\lang2057\f2\fs20 Typedeclarations
\par \plain\lang2057\f2\fs20\strike Variable declarations\plain\lang2057\f2\fs20 Variabledeclarations
\par \plain\lang2057\f2\fs20\strike Expressions\plain\lang2057\f2\fs20 Expressions
\par \plain\lang2057\f2\fs20\strike Statements\plain\lang2057\f2\fs20 Statements
\par \plain\lang2057\f2\fs20\strike Procedure declarations\plain\lang2057\f2\fs20 Proceduredeclarations
\par 
\par \plain\lang2057\f2\fs20\strike The module SYSTEM\plain\lang2057\f2\fs20 ThemoduleSYSTEM
\par 
\par \plain\f2\fs16\up6 #\plain\lang2057\f2\fs28  Syntax
\par \plain\lang2057\f2\fs20 An extended Backus-Naur Formalism (EBNF) is used to describe the syntax of Oberon-2:
\par Alternatives are separated by |. Brackets [ and ] denote optionality of the enclosed expression, and braces \{ and \} denote its repetition (possibly 0 times). Non-terminal symbols start with an upper-case letter (e.g. Statement). Terminal symbols either start with a lower-case letter (e.g. ident), or are written all in upper-case letters (e.g. BEGIN), or are denoted by strings (e.g. ":=").
\par \plain\f2\fs16\up6 #$K\plain\lang2057\f2\fs28  Vocabulary and Representation
\par \plain\lang2057\f2\fs20 The representation of (terminal) symbols in terms of characters is defined using the ASCII set. Symbols are identifiers, numbers, strings, operators, and delimiters. The following lexical rules must be observed: Blanks and line breaks must not occur within symbols (except in comments, and blanks in strings). They are ignored unless they are essential to separate two consecutive symbols. Capital and lower-case letters are considered as distinct.
\par 
\par 1. \plain\lang2057\f2\fs20\b Identifiers \plain\lang2057\f2\fs20 are sequences of letters and digits. The first character must be a letter.
\par \pard\li567\plain\lang2057\f2\fs20 ident = letter \{ letter | digit \}.
\par \pard\plain\lang2057\f2\fs20 Examples: x  Scan  Oberon2  GetSymbol  firstLetter
\par 
\par 2. \plain\lang2057\f2\fs20\b Numbers \plain\lang2057\f2\fs20 are (unsigned) integer or real constants. The type of an integer constant is the minimal type to which the constant value belongs. If the constant is specified with the suffix H, the representation is hexadecimal otherwise it is decimal.
\par A real numberr always contains a decimal point. Optionally it may also contain a decimal scale factor. The letter E (or D) means "times ten to the power of". A real number is of type REAL, unless it has a scale factor containing the letter D. In this case it is of type LONGREAL.
\par \pard\li567\plain\lang2057\f2\fs20 number = integer | real.
\par integer = digit \{digit\} | digit \{hexDigit\} "H"
\par real = digit \{digit\} "." \{digit\} [ScaleFactor].
\par ScaleFactor = ("E" | "D") ["+" | "-"] digit \{digit\}.
\par hexDigit = digit | "A" | "B" | "C" | "D" | "E" | "F".
\par digit = "0" | "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9".
\par \pard\plain\lang2057\f2\fs20 Examples: 1991  0DH  12.3  4.567E8  0.57712566D-6
\par 
\par 3. \plain\lang2057\f2\fs20\b Character constants \plain\lang2057\f2\fs20 are denoted by the ordinal number of the character in hexadecimal notation followed by the letter X.
\par \pard\li567\plain\lang2057\f2\fs20 character = digit \{HexDigit\}"X".
\par \pard\plain\lang2057\f2\fs20 4. \plain\lang2057\f2\fs20\b Strings \plain\lang2057\f2\fs20 are sequences of characters enclosed in singel (') or double (") quote marks. The opening quote must be the same as the closing quote and must not occur within the string. The number of characters in a string is called its length. A string of length 1 can be used wherever a character constant is allowed and vice vers.
\par \pard\li567\plain\lang2057\f2\fs20 string = ' " ' \{char\} ' " ' | " ' " \{char\} " ' ".
\par \pard\plain\lang2057\f2\fs20 Examples: "Oberon-2"  "Don't worry!"
\par 
\par 5. \plain\lang2057\f2\fs20\b Operators and delimiters \plain\lang2057\f2\fs20 are the special characters, character pairs, or reserved words listed below. The reserved words consist excusively of capital letters and cannot be used as identifiers.
\par \tab +\tab :=\tab ARRAY\tab IMPORT\tab RETURN
\par \tab -\tab ^\tab BEGIN\tab IN\tab \tab THEN
\par \tab *\tab =\tab BY\tab IS\tab \tab TO
\par \tab /\tab #\tab CASE\tab LOOP\tab \tab TYPE
\par \tab ~\tab <\tab CONST\tab MOD\tab \tab UNTIL
\par \tab &\tab >\tab DIV\tab MODULE\tab VAR
\par \tab .\tab <=\tab DO\tab NIL\tab \tab WHILE
\par \tab ,\tab >=\tab ELSE\tab OF\tab \tab WITH
\par \tab ;\tab ..\tab ELSIF\tab OR
\par \tab |\tab :\tab END\tab POINTER
\par \tab (\tab )\tab EXIT\tab PROCEDURE
\par \tab [\tab ]\tab FOR\tab RECORD
\par \tab \{\tab \}\tab IF\tab REPEAT
\par 
\par 6. \plain\lang2057\f2\fs20\b Comments \plain\lang2057\f2\fs20 may be inserted between any two symbols in a program. They are arbitrary character sequences opened by the bracket (* and closed by *). Comments may be nested. They do not affect the meaning of a program.
\par \plain\f2\fs16\up6 #$K\plain\lang2057\f2\fs28  Declarations and scope rules
\par \plain\lang2057\f2\fs20 Every identifier occuring in a program must be introduced by a declaration, unless it is a predeclared identifier. Declarations also specify certain permanent properties of an object, such as whether it is a constant, a type, a variable, or a procedure. The identifier is then used to refer to the associated object.
\par The \plain\lang2057\f2\fs20\b scope\plain\lang2057\f2\fs20  of an object x extends textually from the point of its declaration to the end of the block (module, procedure, or record) to which the declaration belongs and hence to which the object is \plain\lang2057\f2\fs20\b local\plain\lang2057\f2\fs20 . It excludes the scopes of equally named objects which are declared in nested blocks. The scope rules are:
\par 
\par \pard\li284\fi-142\plain\lang2057\f2\fs20 1. No identifier may denote more than one object within a given scopy (i.e. no identifier may be declared twice in a block);
\par 2. An object may only be referenced within its scope;
\par 3. A type T of the form POINTER TO T1 can be declared before the scope of T1. In this case, the declaration of T1 must follow in the same block to which T is local;
\par 4. Identifiers denoting record fields or type-bound procedures are valid in record designators only.
\par \pard\plain\lang2057\f2\fs20 
\par An identifier declared in a module block may be followed by an export mark ("*" or "-") in its declaration to indicate that it is exported. An identifier x exported by a module M may be used in other modules, if they import M. The identifier is then denoted as M.x in these modules and is called \plain\lang2057\f2\fs20\b qualified identifier\plain\lang2057\f2\fs20 . Identifiers marked with "-" in their declaration are read-only in importing modules.
\par \pard\li567\plain\lang2057\f2\fs20 Qualident = [ident "."] ident.
\par IdentDef = ident ["*" |"-"].
\par \pard\plain\lang2057\f2\fs20 The following identifiers are predeclared:
\par 
\par \plain\lang2057\f2\fs20\strike \tab ABS\plain\lang2057\f2\fs20 Predeclaredprocedures\plain\lang2057\f2\fs20\strike \tab \tab LEN\plain\lang2057\f2\fs20 Predeclaredprocedures\plain\lang2057\f2\fs20\strike 
\par \tab ASH\plain\lang2057\f2\fs20 Predeclaredprocedures\plain\lang2057\f2\fs20\strike \tab \tab LONG\plain\lang2057\f2\fs20 Predeclaredprocedures\plain\lang2057\f2\fs20\strike 
\par \tab BOOLEAN\plain\lang2057\f2\fs20 Basictypes\plain\lang2057\f2\fs20\strike \tab LONGINT\plain\lang2057\f2\fs20 Basictypes\plain\lang2057\f2\fs20\strike 
\par \tab CAP\plain\lang2057\f2\fs20 Predeclaredprocedures\plain\lang2057\f2\fs20\strike \tab \tab LONGREAL\plain\lang2057\f2\fs20 Basictypes\plain\lang2057\f2\fs20\strike 
\par \tab CHAR\plain\lang2057\f2\fs20 Basictypes\plain\lang2057\f2\fs20\strike \tab \tab MAX\plain\lang2057\f2\fs20 Predeclaredprocedures\plain\lang2057\f2\fs20\strike 
\par \tab CHR\plain\lang2057\f2\fs20 Predeclaredprocedures\plain\lang2057\f2\fs20\strike \tab \tab MIN\plain\lang2057\f2\fs20 Predeclaredprocedures\plain\lang2057\f2\fs20\strike 
\par \tab COPY\plain\lang2057\f2\fs20 Predeclaredprocedures\plain\lang2057\f2\fs20\strike \tab \tab NEW\plain\lang2057\f2\fs20 Predeclaredprocedures\plain\lang2057\f2\fs20\strike 
\par \tab DEC\plain\lang2057\f2\fs20 Predeclaredprocedures\plain\lang2057\f2\fs20\strike \tab \tab ODD\plain\lang2057\f2\fs20 Predeclaredprocedures\plain\lang2057\f2\fs20\strike 
\par \tab ENTIER\plain\lang2057\f2\fs20 Predeclaredprocedures\plain\lang2057\f2\fs20\strike \tab \tab ORD\plain\lang2057\f2\fs20 Predeclaredprocedures\plain\lang2057\f2\fs20\strike 
\par \tab EXCL\plain\lang2057\f2\fs20 Predeclaredprocedures\plain\lang2057\f2\fs20\strike \tab \tab REAL\plain\lang2057\f2\fs20 Basictypes\plain\lang2057\f2\fs20\strike 
\par \tab FALSE\plain\lang2057\f2\fs20 Basictypes\plain\lang2057\f2\fs20\strike \tab \tab SET\plain\lang2057\f2\fs20 Basictypes\plain\lang2057\f2\fs20\strike 
\par \tab HALT\plain\lang2057\f2\fs20 Predeclaredprocedures\plain\lang2057\f2\fs20\strike \tab \tab SHORT\plain\lang2057\f2\fs20 Predeclaredprocedures\plain\lang2057\f2\fs20\strike 
\par \tab INC\plain\lang2057\f2\fs20 Predeclaredprocedures\plain\lang2057\f2\fs20\strike \tab \tab SHORTINT\plain\lang2057\f2\fs20 Basictypes\plain\lang2057\f2\fs20\strike 
\par \tab INCL\plain\lang2057\f2\fs20 Predeclaredprocedures\plain\lang2057\f2\fs20\strike \tab \tab SIZE\plain\lang2057\f2\fs20 Predeclaredprocedures\plain\lang2057\f2\fs20\strike 
\par \tab INTEGER\plain\lang2057\f2\fs20 Basictypes\plain\lang2057\f2\fs20\strike \tab TRUE\plain\lang2057\f2\fs20 Basictypes\plain\lang2057\f2\fs20\strike 
\par \plain\f2\fs16\up6 #$K\plain\lang2057\f2\fs28  Constant declarations
\par \plain\lang2057\f2\fs20 A constant declaration associates an identifier with a constant value.
\par \pard\li567\plain\lang2057\f2\fs20 ConstantDeclaration = IdentDef "=" ConstExpression.
\par ConstExpression = Expression.
\par \pard\plain\lang2057\f2\fs20 A constant expression is an expression that can be evaluated by a mere textual scan without actually executing the program. Its operands are constants or \plain\lang2057\f2\fs20\strike predeclared functions\plain\lang2057\f2\fs20 Predeclaredprocedures that can be evaluated at compile time. Examples of constant declarations are:
\par 
\par \tab N = 100
\par \tab limit = 2*'N - 1
\par \tab fullSet = \{MIN(SET)..MAX(SET)\}
\par \plain\f2\fs16\up6 #$K\plain\lang2057\f2\fs28  Type declarations
\par \plain\lang2057\f2\fs20 A data type determines the set of values which variables of that type may assume, and the operators that are applicable. A type declaration associates an identifier with a type. In the case of structured types (arrays and records) it also defines the structure of variables of this type.
\par \pard\li567\plain\lang2057\f2\fs20 TypeDeclaration = IdentDef "=" Type.
\par Type = Qualident | ArrayType | RecordType | PointerType | ProcedureType.
\par \pard\plain\lang2057\f2\fs20 Examples:
\par \tab Table=ARRAY N OF REAL
\par \tab Tree=POINTER TO Node
\par \tab Node=RECORD
\par \tab \tab key:INTEGER;
\par \tab \tab left,right:Tree
\par \tab END
\par \tab Function=PROCEDURE(x:INTEGER):INTEGER
\par 
\par \plain\lang2057\f2\fs20\strike Basic types\plain\lang2057\f2\fs20 Basictypes
\par \plain\lang2057\f2\fs20\strike Array types\plain\lang2057\f2\fs20 Arraytypes
\par \plain\lang2057\f2\fs20\strike Record types\plain\lang2057\f2\fs20 Recordtypes
\par \plain\lang2057\f2\fs20\strike Pointer types\plain\lang2057\f2\fs20 Pointertypes
\par \plain\lang2057\f2\fs20\strike Procedure types\plain\lang2057\f2\fs20 Proceduretypes
\par \plain\f2\fs16\up6 #$K\plain\lang2057\f2\fs28  Variable declarations
\par \plain\lang2057\f2\fs20 Variable declarations introduce variables by defining an identifier and a data type for them.
\par \pard\li567\plain\lang2057\f2\fs20 VariableDeclaration = IdentList ":" Type.
\par \pard\plain\lang2057\f2\fs20 Record and pointer variables have both a \plain\lang2057\f2\fs20\b static type\plain\lang2057\f2\fs20  (the type with which they are declared - simply called their type) and a \plain\lang2057\f2\fs20\b dynamic type\plain\lang2057\f2\fs20  (the type they assume at run time). For pointers and variable parameters of record type the dynamic type may be an extension of their static type. The static type determines which fields of a record are accessible. The dynamic type is used to call \plain\lang2057\f2\fs20\strike type-bound procedures\plain\lang2057\f2\fs20 Typeboundprocedures.
\par 
\par Examples of variable declarations:
\par \tab i,j,k:INTEGER
\par \tab x,y:REAL
\par \tab p,q:BOOLEAN
\par \plain\f2\fs16\up6 #$K\plain\lang2057\f2\fs28  Expressions
\par \plain\lang2057\f2\fs20 Expressions are constructs denoting rules of computation whereby constants and current values of variables are combined to compute other values by the application of operators and function procedures. Expressions consist of operands and operators. Parentheses may be used to express specific associations of operators and operands.
\par 
\par \plain\lang2057\f2\fs20\strike Operands\plain\lang2057\f2\fs20 Operands
\par \plain\lang2057\f2\fs20\strike Operators\plain\lang2057\f2\fs20 Operators
\par \plain\f2\fs16\up6 #$K\plain\lang2057\f2\fs28  Statements
\par \plain\lang2057\f2\fs20 Statements denote actions. There are elementary and structured statements. Elementary statements are not composed of any parts that are themselves statements. They are the assignment, the procedure call, the return, and the exit statement. Structured statements are composed of parts that are themselves statements. They are used to express sequencing and conditional, selective, and repetitive execution. A statement may also be empty, in which case it denotes no action. The empty statement is included in order to relax punctuation rules in statement sequences.
\par \pard\li567\plain\lang2057\f2\fs20 Statement = [Assignment | ProcedureCall | IfStatement | CaseStatement | WhileStatement | RepeatStatement | ForStatement | LoopStatement | WithStatement | EXIT | RETURN [Expression]].
\par \pard\plain\lang2057\f2\fs20\strike Assignments\plain\lang2057\f2\fs20 Assignments
\par \plain\lang2057\f2\fs20\strike Procedure calls\plain\lang2057\f2\fs20 Procedurecalls
\par \plain\lang2057\f2\fs20\strike Statement sequences\plain\lang2057\f2\fs20 Statementsequences
\par \plain\lang2057\f2\fs20\strike If statements\plain\lang2057\f2\fs20 Ifstatements
\par \plain\lang2057\f2\fs20\strike Case statements\plain\lang2057\f2\fs20 Casestatements
\par \plain\lang2057\f2\fs20\strike While statements\plain\lang2057\f2\fs20 Whilestatements
\par \plain\lang2057\f2\fs20\strike Repeat statements\plain\lang2057\f2\fs20 Repeatstatements
\par \plain\lang2057\f2\fs20\strike For statements\plain\lang2057\f2\fs20 Forstatements
\par \plain\lang2057\f2\fs20\strike Loop statements\plain\lang2057\f2\fs20 Loopstatements
\par \plain\lang2057\f2\fs20\strike Return and exit statements\plain\lang2057\f2\fs20 Returnandexit
\par \plain\lang2057\f2\fs20\strike With statements\plain\lang2057\f2\fs20 Withstatements
\par \plain\f2\fs16\up6 #$K\plain\lang2057\f2\fs28  Procedure declarations
\par \plain\lang2057\f2\fs20 A procedure declaration consists of a procedure heading and a procedure body. The heading specifies the procedure identifier and the formal parameters. For type-bound procedures it also specifies the receiver parameter. The body contains declarations and statements. The procedure identifier is repeated at the end of the procedure declaration.
\par There are two kinds of procedures: proper procedures and function procedures. The latter are activated by a function designator as a constituent of an expression and yield a result that is an operand of the expression. Proper procedures are activatec by a procedure call. A procedure is a function procedure it its formal parameters specify a result type. The body of a function procedure must contain a return statement which defines its result.
\par All constants, variables, types, and procedures declared within a preocedure body are local to the procedure. Since procedures may be declared as local objects too, procedure declarations may be nested. The call of a procedure within its declaration implies recursive activation.
\par In addition to its formal parameters and locally declared objects, the objects declared in the environment of the procedure are also visible in the procedure (with the exception of those objects that have the same name as an object declared locally).
\par \pard\li567\plain\lang2057\f2\fs20 ProcedureDeclaration = ProcedureHeading ";" ProcedureBody ident.
\par ProcedureHeading = PROCEDURE [Receiver] IdentDef [FormalParameters].
\par ProcedureBody = DeclarationSequence [BEGIN StatementSequence] END.
\par DeclarationSequence = \{CONST \{ConstantDeclaration ";"\} TYPE \{TypeDeclaration ";"\} | VAR \{VariableDeclaration ";"\}\} \{ProcedureDeclaration ";" | ForwardDeclaration ";"\}.
\par ForwardDeclaration = PROCEDURE "^" [Receiver] IdentDef [FormalParameters].
\par \pard\plain\lang2057\f2\fs20 If a procedure declaration specifies a receiver parameter, the procedure is considered to be bound to a type. A forward declaration serves to allow forward references to a procedure whose actual declaration appears later in the text. The formal parameter lists of the forward declaration and the actual declaration must match.
\par 
\par \plain\lang2057\f2\fs20\strike Formal parameters\plain\lang2057\f2\fs20 Formalparameters
\par \plain\lang2057\f2\fs20\strike Predeclared procedures\plain\lang2057\f2\fs20 Predeclaredprocedures
\par \plain\lang2057\f2\fs20\strike Type-bound procedures\plain\lang2057\f2\fs20 Typeboundprocedures
\par \plain\f2\fs16\up6 #$K\plain\lang2057\f2\fs28  Modules
\par \plain\lang2057\f2\fs20 A module is a collection of declarations of constants, types, variables, and procedures, together with a sequence of statements for the purpose of assigning initial values to the variables. A module constitutes a text that is compilable as a unit.
\par \pard\li567\plain\lang2057\f2\fs20 Module = MODULE ident ";" [ImportList] DeclarationSequence [BEGIN StatementSequence] END ident ".".
\par ImportList = IMPORT Import \{ "," Import \} ";".
\par Import = [ident ":="] ident.
\par \pard\plain\lang2057\f2\fs20 The import list specifies the names of the imported modules. If a module A is imported by a module M and A exports an identifier x, then x is referred to as A.x within M. If A is imported as B:=A, the object x is referenced as B.x. This allows short alias names in qualified identifiers. Identifiers that are to be exported (i.e. that are visible in client modules) must be marked by an export mark in their declaration.
\par The statement sequence following the symbol BEGIN is executed when the module is added to a system (loaded), which is done after the imported modules have been loaded. It follows that cyclic import of modules is illegal. Individual (parameterless and exported) procedures can be activated from the system, and these procedures serve as commands\plain\lang2057\f2\fs20\up6 *\plain\lang2057\f2\fs20 .
\par 
\par 
\par 
\par \plain\lang2057\f2\fs20\up6 *\plain\lang2057\f2\fs20  These commands are a property of the Oberon System and are not available from the Windows environment. Building a Windows program, it is necessary to implement a WinMain Procedure which serves as the entry point of the program.
\par \plain\f2\fs16\up6 #$K\plain\lang2057\f2\fs28  The module SYSTEM
\par \plain\lang2057\f2\fs20 The module SYSTEM contains certain types and procedures that are necessary to implement low-level operations particular to a given computer and/or implementation. These include for example facilities for accessing devices that are controlled by the computer, and facilities to break the type compatibility rules otherwise imposed by the language definition. It is stringly recommended to restrict their use to specific modules (called low-level modules). Such modules are inherently non-portable, but easily recognized due to the identifier SYSTEM appearing in their import list. The following specifications hold for the implementation of Oberon-2 on the Ceres computer.
\par Module SYSTEM exports a type BYTE with the following characteristics: Variables of type CHAR or SHORTINT can be assigned to variables of type BYTE. If a formal variable parameter is of type ARRAY OF BYTE then the corresponding actual parameter may be of any type.
\par Another type exported by the module SYSTEM is the type PTR. Variables of any pointer type may be assigned to variables of type PTR. If a formal variable is of type PTR, the actual parameter may be of any pointer type.
\par The procedures contained in module SYSTEM are listed in the following tables. Most of them correspond to single instructions compiled as in-line code. For details, the reader is referred to the processor manual. v stands vor variable, x, y, a, and n for expressions, and T for a type.
\par 
\par \plain\lang2057\f2\fs20\b Function procedures
\par \plain\lang2057\f2\fs20 
\par Name\tab \tab Argument types\tab Result type\tab Function
\par 
\par \plain\lang2057\f2\fs20\b ADR\plain\lang2057\f2\fs20 (v)\tab \tab any\tab \tab LONGINT\tab address of variable v
\par \plain\lang2057\f2\fs20\b BIT\plain\lang2057\f2\fs20 (a,n)\tab a:LONGINT\tab BOOLEAN\tab bit n of Mem[a]
\par \tab \tab n:integer
\par \plain\lang2057\f2\fs20\b CC\plain\lang2057\f2\fs20 (n)\tab \tab integer constant\tab BOOLEAN\tab condition n
\par \tab \tab \tab \tab \tab \tab (0<=n<=15)
\par \plain\lang2057\f2\fs20\b LSH\plain\lang2057\f2\fs20 (x,n)\tab x:integer,\tab type of x\tab logical shift
\par \tab \tab CHAR, BYTE
\par \tab \tab n:integer
\par \plain\lang2057\f2\fs20\b ROT\plain\lang2057\f2\fs20 (x,n)\tab x:integer,\tab type of x\tab rotation
\par \tab \tab CHAR, BYTE
\par \tab \tab n:integer
\par \plain\lang2057\f2\fs20\b VAL\plain\lang2057\f2\fs20 (T,x)\tab T,x:any type\tab T\tab \tab x interpreted
\par \tab \tab \tab \tab \tab \tab as of type T
\par 
\par 
\par \plain\lang2057\f2\fs20\b Proper procedures
\par \plain\lang2057\f2\fs20 
\par Name\tab \tab Argument types\tab \tab Function
\par 
\par \plain\lang2057\f2\fs20\b GET\plain\lang2057\f2\fs20 (a,v)\tab a:LONGINT; v any\tab v:=M[a]
\par \tab \tab basic type, pointer,
\par \tab \tab procedure type
\par \plain\lang2057\f2\fs20\b PUT\plain\lang2057\f2\fs20 (a,x)\tab a:LONGINT; x any\tab M[a]:=x
\par \tab \tab basic type, pointer,
\par \tab \tab procedure type
\par \plain\lang2057\f2\fs20\b GETREG\plain\lang2057\f2\fs20 (n,v)\tab n:integer constant;\tab v:=Register\plain\lang2057\f2\fs20\dn6 n\plain\lang2057\f2\fs20 
\par \tab \tab v any basic type, pointer,
\par \tab \tab procedure type
\par \plain\lang2057\f2\fs20\b PUTREG\plain\lang2057\f2\fs20 (n,x)\tab n:integer constant;\tab Register\plain\lang2057\f2\fs20\dn6 n:\plain\lang2057\f2\fs20 =x
\par \tab \tab x any basic type, pointer,
\par \tab \tab procedure type
\par \plain\lang2057\f2\fs20\b MOVE\plain\lang2057\f2\fs20 (a\plain\lang2057\f2\fs20\dn6 0\plain\lang2057\f2\fs20 ,a\plain\lang2057\f2\fs20\dn6 1\plain\lang2057\f2\fs20 ,n)\tab a\plain\lang2057\f2\fs20\dn6 0\plain\lang2057\f2\fs20 ,a\plain\lang2057\f2\fs20\dn6 1\plain\lang2057\f2\fs20 :LONGINT;\tab M[a\plain\lang2057\f2\fs20\dn6 1\plain\lang2057\f2\fs20 ..a\plain\lang2057\f2\fs20\dn6 1\plain\lang2057\f2\fs20 +n-1]:=
\par \tab \tab n:integer\tab \tab M[a\plain\lang2057\f2\fs20\dn6 0\plain\lang2057\f2\fs20 ..a\plain\lang2057\f2\fs20\dn6 0\plain\lang2057\f2\fs20 +n-1]
\par \plain\lang2057\f2\fs20\b NEW\plain\lang2057\f2\fs20 (v,n)\tab v: any pointer; n:integer\tab allocate storage block
\par \tab \tab \tab \tab \tab of n bytes; assign
\par \tab \tab \tab \tab \tab its address to v
\par \plain\f2\fs16\up6 #$K\plain\lang2057\f2\fs28  Predeclared procedures
\par \plain\lang2057\f2\fs20 The following table list the predeclared procedures. Some are generic procedures, i.e. they apply to several types of operands. v stands for a variable, x and n for expressions, and T for a type.
\par 
\par 
\par Function procedures
\par 
\par \plain\lang2057\f2\fs20\strike \tab ABS\plain\lang2057\f2\fs20 ABS\plain\lang2057\f2\fs20\strike \tab ASH\plain\lang2057\f2\fs20 ASH\plain\lang2057\f2\fs20\strike \tab CAP\plain\lang2057\f2\fs20 CAP\plain\lang2057\f2\fs20\strike 
\par \tab CHR\plain\lang2057\f2\fs20 CHR\plain\lang2057\f2\fs20\strike \tab ENTIER\plain\lang2057\f2\fs20 ENTIER\plain\lang2057\f2\fs20\strike \tab LEN\plain\lang2057\f2\fs20 LEN\plain\lang2057\f2\fs20\strike 
\par \tab LONG\plain\lang2057\f2\fs20 LONG\plain\lang2057\f2\fs20\strike \tab MAX\plain\lang2057\f2\fs20 MAX\plain\lang2057\f2\fs20\strike \tab MIN\plain\lang2057\f2\fs20 MIN\plain\lang2057\f2\fs20\strike 
\par \tab ODD\plain\lang2057\f2\fs20 ODD\plain\lang2057\f2\fs20\strike \tab ORD\plain\lang2057\f2\fs20 ORD\plain\lang2057\f2\fs20\strike \tab SHORT\plain\lang2057\f2\fs20 SHORT\plain\lang2057\f2\fs20\strike 
\par \tab SIZE\plain\lang2057\f2\fs20 SIZE\plain\lang2057\f2\fs20\strike 
\par \plain\lang2057\f2\fs20 
\par 
\par Proper procedures
\par 
\par \tab \plain\lang2057\f2\fs20\strike COPY\plain\lang2057\f2\fs20 COPY\tab \plain\lang2057\f2\fs20\strike DEC\plain\lang2057\f2\fs20 DEC\tab \plain\lang2057\f2\fs20\strike EXCL\plain\lang2057\f2\fs20 EXCL
\par \tab \plain\lang2057\f2\fs20\strike HALT\plain\lang2057\f2\fs20 HALT\tab \plain\lang2057\f2\fs20\strike INC\plain\lang2057\f2\fs20 INC\tab \plain\lang2057\f2\fs20\strike INCL\plain\lang2057\f2\fs20 INCL
\par \tab \plain\lang2057\f2\fs20\strike NEW\plain\lang2057\f2\fs20 NEW\tab \plain\lang2057\f2\fs20\strike ASSERT\plain\lang2057\f2\fs20 ASSERT
\par \plain\f2\fs16\up6 #$K\plain\lang2057\f2\fs28  Basic types
\par \plain\lang2057\f2\fs20 The basic types are denoted by predeclared identifiers. The \plain\lang2057\f2\fs20\strike associated operators\plain\lang2057\f2\fs20 Operators and the \plain\lang2057\f2\fs20\strike predeclared function procedures\plain\lang2057\f2\fs20 Predeclaredprocedures are described in the corresponding chapters. The values of the given basic types are the following:
\par 
\par 1. \plain\lang2057\f2\fs20\b BOOLEAN\plain\lang2057\f2\fs20 \tab the truth values TRUE and FALSE
\par 2. \plain\lang2057\f2\fs20\b CHAR\plain\lang2057\f2\fs20 \tab the characters of the extended ASCII set (0X..0FFX
\par 3. \plain\lang2057\f2\fs20\b SHORTINT\plain\lang2057\f2\fs20 \tab the integers between MIN(SHORTINT) and MAX(SHORTINT)
\par 4. \plain\lang2057\f2\fs20\b INTEGER\plain\lang2057\f2\fs20 \tab the integers between MIN(INTEGER) and MAX(INTEGER)
\par 5. \plain\lang2057\f2\fs20\b LONGINT\plain\lang2057\f2\fs20 \tab the integers between MIN(LONGINT) and MAX(LONGINT)
\par 6. \plain\lang2057\f2\fs20\b REAL\plain\lang2057\f2\fs20 \tab the real numbers between MIN(REAL) and MAX(REAL)
\par 7. \plain\lang2057\f2\fs20\b LONGREAL\plain\lang2057\f2\fs20 \tab the real numbers between MIN(LONGREAL) and MAX(LONGREAL)
\par 8. \plain\lang2057\f2\fs20\b SET\plain\lang2057\f2\fs20 \tab \tab the sets of integers between 0 and MAX(SET)
\par 
\par Types 3 to 5 are integer types, types 6 and 7 are real types, and together they are called numeric types. They form a hierarchy; the larger type includes (the values of) the smaller type.
\par \plain\f2\fs16\up6 #$K\plain\lang2057\f2\fs28  Array types
\par \plain\lang2057\f2\fs20 An array is a structure consisting of a number of elements which are all of the same type, called the element type. The number of elements in an array is called length. The elements of the array are designated by indices, which are integers between 0 and the length minus 1.
\par \pard\li567\plain\lang2057\f2\fs20 ArrayType = ARRAY [Length \{"," Length\}] OF TYPE.
\par Length = ConstExpression
\par \pard\plain\lang2057\f2\fs20 A type of the form
\par \pard\li567\plain\lang2057\f2\fs20 ARRAY L\plain\lang2057\f2\fs20\dn6 0\plain\lang2057\f2\fs20 , L\plain\lang2057\f2\fs20\dn6 1\plain\lang2057\f2\fs20 , ..., L\plain\lang2057\f2\fs20\dn6 n\plain\lang2057\f2\fs20  OF T
\par \pard\plain\lang2057\f2\fs20 is understood as an abbreviation of
\par \pard\li567\plain\lang2057\f2\fs20 ARRAY L\plain\lang2057\f2\fs20\dn6 0\plain\lang2057\f2\fs20  OF
\par   ARRAY L\plain\lang2057\f2\fs20\dn6 1\plain\lang2057\f2\fs20  OF
\par     ...
\par       ARRAY L\plain\lang2057\f2\fs20\dn6 n\plain\lang2057\f2\fs20  OF T
\par \pard\plain\lang2057\f2\fs20 Arrays declared without length are called open arrays. They are restricted to pointer base types, element types of open array types, and formal parameter types.
\par \plain\f2\fs16\up6 #$K\plain\lang2057\f2\fs28  Record types
\par \plain\lang2057\f2\fs20 A record type is a structure consisting of a fixed number of elements, called fields, with possibly different types. The record type declaration specifies the name and type of each field. The scope of the field identifiers extends from the point of their declaration to the end of the record type, but they are also visible within designators referring to elements of record variables. If a record type is exported, field identifiers that are to be visible outside the declaring module must be marked. They are called public fields; unmarked elements are called private fields.
\par \pard\li567\plain\lang2057\f2\fs20 RecordType=RECORD ["("BaseType")"] FieldList \{ ";" FieldList\} END.
\par BaseType = Qualident.
\par FieldList = [IdentList ":" Type].
\par \pard\plain\lang2057\f2\fs20 Record types are extensible, i. e. a record type can be declared as an extension of another record type. In the example
\par \tab T0 = RECORD x:INTEGER END
\par \tab T1 = RECORD (T0) y:REAL END
\par T1 is a (direct) extension of T0 and T0 is the (direct) base type of T1. An extended type T1 consists of the fields of its base type and of the fields which are declared in T1. Identifiers declared in the extension must be different from the identifiers declared in its base type(s).
\par 
\par Examples of record type declarations:
\par 
\par \tab RECORD
\par \tab \tab day,month,year:INTEGER
\par \tab END
\par 
\par \tab RECORD
\par \tab \tab name,firstname:ARRAY 32 OF CHAR;
\par \tab \tab age:INTEGER;
\par \tab \tab salary:REAL
\par \tab END
\par \plain\f2\fs16\up6 #$K\plain\lang2057\f2\fs28  Pointer types
\par \plain\lang2057\f2\fs20 Variables of a pointer type P assume as values pointers to variables of some type T. T is called the pointer base type of P and must be a record or array type. Pointer types inherit the extension relation of their pointer base types: if a type T1 is an extension of T, and P1 is of type POINTER TO T1, then p1 is also an extension of P.
\par \pard\li567\plain\lang2057\f2\fs20 PointerType = POINTER TO Type.
\par \pard\plain\lang2057\f2\fs20 If p is a variable of type P = POINTER TO T, a call of the predeclared procedure NEW(p) allocates a variable of type T in free storage. If T is a record type or an array type with fixed length, the allocation has to be done with NEW(p); if T is an n-dimensional open array the allocation has to be done with NEW(p,e\plain\lang2057\f2\fs20\dn6 0\plain\lang2057\f2\fs20 ,....e\plain\lang2057\f2\fs20\dn6 n-1\plain\lang2057\f2\fs20 ) where T is allocated with lengths given by the expression e\plain\lang2057\f2\fs20\dn6 0\plain\lang2057\f2\fs20 ,....,e\plain\lang2057\f2\fs20\dn6 n-1\plain\lang2057\f2\fs20 . In eitherr case a pointer to the allocated varaible is assigned to p. p is of type P. The referenced variable p^ (pronounced as p-referenced) is of type T.
\par Any pointer variable may assume the value NIL, which points to no variable at all.
\par \plain\f2\fs16\up6 #$K\plain\lang2057\f2\fs28  Procedure types
\par \plain\lang2057\f2\fs20 Variables of a procedure type T have a procedure (or NIL) as value. If a procedure P is assigned to a variable of type T, the formal parameter lists of P and T must match. P must not be a predeclared or type-bound procedure nor may it be local to another procedure.
\par \pard\li567\plain\lang2057\f2\fs20 ProcedureType = PROCEDURE [FormalParameters].
\par \pard\plain\f2\fs16\up6 #$K\plain\lang2057\f2\fs28  Operands
\par \plain\lang2057\f2\fs20 With the exception of set constructors and literal constants (numbers, character constants, or strings), operands are denoted by designators. A designator consists of an identifier referring to a constant, variable, or procedure. This identifier may possibly be qualified by a module identifier and may be followed by selectors if the designated object is an element of a structure.
\par \pard\li567\plain\lang2057\f2\fs20 Designator = Qualident \{ "." ident | "[" ExpressionList "]" | "^" | "(" Qualident ")" \}.
\par ExpressionList = Expression \{ "," Expression \}.
\par \pard\plain\lang2057\f2\fs20 If a designates an array, then a[e] denotes that element of a whose index is the current value of the expression e. The type of e must be an integer type. A designator of the form a[e\plain\lang2057\f2\fs20\dn6 0\plain\lang2057\f2\fs20 ,e\plain\lang2057\f2\fs20\dn6 1\plain\lang2057\f2\fs20 ,...,e\plain\lang2057\f2\fs20\dn6 n\plain\lang2057\f2\fs20 ]  stands for a[e\plain\lang2057\f2\fs20\dn6 0\plain\lang2057\f2\fs20 ][e\plain\lang2057\f2\fs20\dn6 1\plain\lang2057\f2\fs20 ]...[e\plain\lang2057\f2\fs20\dn6 n\plain\lang2057\f2\fs20 ]. If r designates a record, then r.f denotes the field f of r or the procedure f bound to the dynamic type of r. If p designates a pointer, p^ denotes the variable which is referenced by p. The designators p^.f and p^[e] may be abbreviated as p.f and p[e], i.e. record and array selectors imply dereferencing. If a or r are readn-only, then also a[e] and r.f are read-only.
\par A \plain\lang2057\f2\fs20\b type guard\plain\lang2057\f2\fs20  v(T) asserts that the dynamic type of v is T (or an extension of T), i.e. program execution is aborted, if the dynamic type of v is not T (or an extension of T). Within the designator, v is then regarded as having the static type T. The guard is applicable, if
\par 1. v is a variable parameter of record type or v is a pointer, and if
\par 2. T is an extension of the static type of v.
\par 
\par If the designated object is a constant or a variable, then the designator refers to its current value. If it is a procedure, the designator refers to that procedure unless it is followed by a (possibly empty) parameter list in which case it implies an activation of that procedure and stands for the value resulting from its execution. The actual parameters must correspond to the formal parameters as in proper procedure calls.
\par 
\par Examples of designators:
\par \tab i\tab \tab \tab (INTEGER)
\par \tab a[i]\tab \tab \tab (REAL)
\par \tab w[3].name[i]\tab \tab (CHAR)
\par \tab t.left.right\tab \tab (Tree)
\par \tab t(CenterNode).subnode\tab (Tree)
\par \plain\f2\fs16\up6 #$K\plain\lang2057\f2\fs28  Operators
\par \plain\lang2057\f2\fs20 Four classes of operators with different precedences (binding strengths) are syntactically distinguished in expressions. The operator ~ has the highest precedence, followed by multiplication operators, addition operators, and relations. Operators of the same precedence associate from left to right. For example, x-y-z stands for (x-y)-z.
\par 
\par Expression \tab = SimpleExpression [Relation SimpleExpression].
\par SimpleExpression\tab = ["+" | "-"] Term \{AddOperator Term\}.
\par Term \tab = Factor \{MulOperator Factor\}.
\par Factor \tab = Designator [ActualParameters] | 
\par \tab     number | character | string | NIL | Set | "(" Expression ")" | "~" Factor.
\par Set \tab = "\{" [Element \{"," Element\}] "\}".
\par Element \tab = Expression [".." Expression].
\par ActualParameters \tab = "(" [ExpressionList] ")".
\par Relation \tab = "=" | "#" | "<" | "<=" | ">" | ">=" | IN | IS.
\par AddOperator \tab = "+" | "-" | OR.
\par MulOperator \tab = "*" | "/" | DIV | MOD | "&".
\par 
\par The available operators are listed in the following tables. Some operators are applicable to operands of various types, denoting different operations. In these cases, the actual operation is identified by the type of the operands. The operands must be expression compatible with respect to the operator (see App.A).
\par 
\par \plain\lang2057\f2\fs20\b Logical operators
\par \plain\lang2057\f2\fs20 
\par OR\tab logical disjunction \tab p OR q\tab   "if p then TRUE, else q"
\par &\tab logical conjunction \tab p & q\tab   "if p then q, else FALSE"
\par ~\tab negation \tab ~ p\tab   "not p"
\par 
\par These operators apply to BOOLEAN operands and yield a BOOLEAN result.
\par 
\par \plain\lang2057\f2\fs20\b Arithmetic operators
\par \plain\lang2057\f2\fs20 
\par +\tab sum
\par -\tab difference
\par *\tab product
\par /\tab real quotient
\par DIV\tab integer quotient
\par MOD\tab modulus
\par 
\par The operators +, -, *, and / apply to operands of numeric types. The type of the result is the type of that operand which includes the type of the other operand, except for division (/), where the result is the smallest real type which includes both operand types. When used as monadic operators, - denotes sign inversion and + denotes the identity operation. The operators DIV and MOD apply to integer operands only. They are related by the following formulas defined for any x and positive divisors y:
\par 
\par x = (x DIV y) * y + (x MOD y)
\par 0 <= (x MOD y) < y
\par 
\par Examples:
\par x\tab y\tab x DIV y\tab x MOD y
\par 5\tab 3\tab 1\tab 2
\par -5\tab 3\tab -2\tab 1
\par 
\par \plain\lang2057\f2\fs20\b Set Operators
\par \plain\lang2057\f2\fs20 
\par +\tab union
\par -\tab difference (x - y = x * (-y))
\par *\tab intersection
\par /\tab symmetric set difference (x / y = (x-y) + (y-x))
\par 
\par Set operators apply to operands of type SET and yield a result of type SET. The monadic minus sign denotes the complement of x, i.e. -x denotes the set of integers between 0 and MAX(SET) which are not elements of x.
\par A set constructor defines the value of a set by listing its elements between curly brackets. The elements must be integers in the range 0..MAX(SET). A range a..b denotes all integers in the interval [a, b].
\par 
\par \plain\lang2057\f2\fs20\b Relations
\par \plain\lang2057\f2\fs20 
\par =\tab equal
\par #\tab unequal
\par <\tab less
\par <=\tab less or equal
\par >\tab greater
\par >=\tab greater or equal
\par IN\tab set membership
\par IS\tab type test
\par 
\par Relations yield a BOOLEAN result. The relations =, #, <, <=, >, and >= apply to the numeric types, CHAR, (open) character arrays, and strings. The relations = and # also apply to BOOLEAN and SET, as well as to pointer and procedure types (including the value NIL). x IN s stands for "x is an element of s". x must be of an integer type, and s of type SET. v IS T stands for "the dynamic type of v is T (or an extension of T)" and is called a type test. It is applicable if
\par 
\par 1.  v is a variable parameter of record type or v is a pointer, and if
\par 2.  T is an extension of the static type of v
\par 
\par Examples of expressions (refer to examples in Ch.7):
\par 
\par 1991\tab INTEGER
\par i DIV 3\tab INTEGER
\par ~p OR q\tab BOOLEAN
\par (i+j) * (i-j)\tab INTEGER
\par s - \{8, 9, 13\}\tab SET
\par i + x\tab REAL
\par a[i+j] * a[i-j]\tab REAL
\par (0<=i) & (i<100)\tab BOOLEAN
\par t.key = 0\tab BOOLEAN
\par k IN \{i..j-1\}\tab BOOLEAN
\par w[i].name <= "John"\tab BOOLEAN
\par t IS CenterTree\tab BOOLEAN
\par 
\par 
\par 
\par \plain\f2\fs16\up6 #$K\plain\lang2057\f2\fs28  Assignments
\par \plain\lang2057\f2\fs20 
\par Assignments replace the current value of a variable by a new value specified by an expression. The expression must be assignment compatible with the variable (see App. A). The assignment operator is written as ":=" and pronounced as becomes.
\par 
\par \tab Assignment = Designator ":=" Expression.
\par 
\par If an expression e of type Te is assigned to a variable v of type Tv, the following happens:
\par 
\par \tab 1.  if Tv and Te are record types, only those fields of Te are assigned which also belong to Tv (projection); the dynamic 
\par \tab \tab type of v  must be the same as the static type of v and  is not changed by the assignment;
\par \tab 2.  if Tv and Te are pointer types, the dynamic type of v becomes the dynamic type of e;
\par \tab 3.  if Tv is ARRAY n OF CHAR and e is a string of length m<n, v[i] becomes ei for i = 0..m-1 and v[m] becomes 0X.
\par 
\par Examples of assignments (refer to examples in Ch.7):
\par 
\par i := 0
\par p := i = j
\par x := i + 1
\par k := log2(i+j)
\par F := log2\tab \tab (* see 10.1 *)
\par s := \{2, 3, 5, 7, 11, 13\}
\par a[i] := (x+y) * (x-y)
\par t.key := i
\par w[i+1].name := "John"
\par t := c
\par 
\par 
\par \plain\f2\fs16\up6 #$K\plain\lang2057\f2\fs28  Procedure calls
\par \plain\lang2057\f2\fs20 
\par A procedure call activates a procedure. It may contain a list of actual parameters which replace the corresponding formal parameters defined in the \plain\lang2057\f2\fs20\strike procedure declaration\plain\lang2057\f2\fs20 Proceduredeclarations. The correspondence is established by the positions of the parameters in the actual and formal parameter lists. There are two kinds of parameters: variable and value parameters.
\par \tab If a formal parameter is a variable parameter, the corresponding actual parameter must be a designator denoting a variable. If it denotes an element of a structured variable, the component selectors are evaluated when the formal/actual parameter substitution takes place, i.e. before the execution of the procedure. If a formal parameter is a value parameter, the corresponding actual parameter must be an expression. This expression is evaluated before the procedure activation, and the resulting value is assigned to the \plain\lang2057\f2\fs20\strike formal parameter\plain\lang2057\f2\fs20 Formalparameters.
\par 
\par \pard\li567\plain\lang2057\f2\fs20 \tab ProcedureCall = Designator [ActualParameters].
\par \pard\plain\lang2057\f2\fs20 
\par Examples:
\par 
\par WriteInt(i*2+1)
\par INC(w[k].count)
\par t.Insert("John")
\par \plain\f2\fs16\up6 #\plain\lang2057\f2\fs28  Statement sequences
\par \plain\lang2057\f2\fs20 Statement sequences denote the sequence of actions specified by the component statements which are spearated by semicolons.
\par \pard\li567\plain\lang2057\f2\fs20 StatementSequence  = Statement \{ ";" Statement\}.
\par \pard\plain\f2\fs16\up6 #$K\plain\lang2057\f2\fs28  If statements
\par \pard\li567\plain\lang2057\f2\fs20 IfStatement = IF Expression THEN StatementSequence \{ ELSIF Expression THEN StatementSequence \} [ELSE StatementSequence] END.
\par \pard\plain\lang2057\f2\fs20 If statements specify the conditional execution of guarded statement sequences. The Boolean expression preceding a statement sequence is called its guard. The guards are evaluated in sequence of occurrence, until one evaluates to TRUE, whereafter its associated statement sequence is executed. If no guard is satisfied, the statement sequence following the symbol ELSE is executed, if there is one.
\par 
\par Example:
\par \tab IF (ch>="A") & (ch<="Z") THEN ReadIdentifier
\par \tab ELSIF (ch>="0") & (ch<="9") THEN ReadNumber
\par \tab ELSIF (ch="'") OR (ch='"') THEN ReadString
\par \tab ELSE SpecialCharacter
\par \tab END
\par \plain\f2\fs16\up6 #$K\plain\lang2057\f2\fs28  Case statements
\par \plain\lang2057\f2\fs20 Case statements specify the selection and execution of a statement sequence according to the value of an expression. First the case expression is evaluated, then that statement sequence is executed whose case label list contains the obtained value. The case expression must either be of an integer type that includes the types of all case labels, or both the case expression and the case labels must be of type CHAR. Case labels are constants, and no value must occur more than once. If the value of the expression does not occur as a label of any case, the statement sequence following the symbol ELSE is selected, if there is one, otherwise the program is aborted.
\par 
\par \pard\li567\plain\lang2057\f2\fs20 CaseStatement \tab = CASE Expression OF Case \{"|" Case\} [ELSE StatementSequence] END.
\par Case \tab = [CaseLabelList ":" StatementSequence].
\par CaseLabelList \tab = CaseLabels \{"," CaseLabels\}.
\par CaseLabels \tab = ConstExpression [".." ConstExpression].
\par \pard\plain\lang2057\f2\fs20 
\par Example:
\par 
\par CASE ch OF
\par \tab "A" .. "Z": ReadIdentifier 
\par |\tab "0" .. "9": ReadNumber 
\par |\tab " ' ", ' " ': ReadString
\par ELSE SpecialCharacter
\par END
\par 
\par \plain\f2\fs16\up6 #$K\plain\lang2057\f2\fs28  While statements
\par \plain\lang2057\f2\fs20 While statements specify the repeated execution of a statement sequence while the Boolean expression (its guard) yields TRUE. The guard is checked before every execution of the statement sequence.
\par 
\par \pard\li567\plain\lang2057\f2\fs20 \tab WhileStatement = WHILE Expression DO StatementSequence END.
\par \pard\plain\lang2057\f2\fs20 
\par Examples:
\par WHILE i > 0 DO i := i DIV 2; k := k + 1 END
\par WHILE (t # NIL) & (t.key # i) DO t := t.left END
\par 
\par 
\par \plain\f2\fs16\up6 #$K\plain\lang2057\f2\fs28  Repeat statements
\par \plain\lang2057\f2\fs20 A repeat statement specifies the repeated execution of a statement sequence until a condition specified by a Boolean expression is satisfied. The statement sequence is executed at least once.
\par 
\par \tab RepeatStatement = REPEAT StatementSequence UNTIL Expression.
\par 
\par \plain\f2\fs16\up6 #$K\plain\lang2057\f2\fs28  For statements
\par \plain\lang2057\f2\fs20 A for statement specifies the repeated execution of a statement sequence for a fixed number of times while a progression of values is assigned to an integer variable called the control variable of the for statement.
\par 
\par \pard\li567\plain\lang2057\f2\fs20 \tab ForStatement = FOR ident ":=" Expression TO Expression [BY ConstExpression] DO StatementSequence END.
\par \pard\plain\lang2057\f2\fs20 
\par The statement
\par 
\par \tab FOR v := low TO high BY step DO statements END
\par 
\par is equivalent to
\par 
\par v := low; temp := high;
\par IF step > 0 THEN
\par \tab WHILE v <= temp DO statements; v := v + step END
\par ELSE
\par \tab WHILE v >= temp DO statements; v := v + step END
\par END
\par 
\par low must be assignment compatible with v (see App. A), high must be expression compatible (i.e. comparable) with v, and step must be a nonzero constant expression of an integer type. If step is not specified, it is assumed to be 1.
\par 
\par Examples:
\par FOR i := 0 TO 79 DO k := k + a[i] END
\par FOR i := 79 TO 1 BY -1 DO a[i] := a[i-1] END
\par 
\par \plain\f2\fs16\up6 #$K\plain\lang2057\f2\fs28  Loop statements
\par \plain\lang2057\f2\fs20 A loop statement specifies the repeated execution of a statement sequence. It is terminated upon execution of an exit statement within that sequence.
\par 
\par \pard\li567\plain\lang2057\f2\fs20 \tab LoopStatement = LOOP StatementSequence END.
\par \pard\plain\lang2057\f2\fs20 
\par Example:
\par LOOP
\par \tab ReadInt(i);
\par \tab IF i < 0 THEN EXIT END;
\par \tab WriteInt(i)
\par END
\par 
\par Loop statements are useful to express repetitions with several exit points or cases where the exit condition is in the middle of the repeated statement sequence.
\par 
\par \plain\f2\fs16\up6 #$K\plain\lang2057\f2\fs28  Return and exit statements
\par \plain\lang2057\f2\fs20 A return statement indicates the termination of a procedure. It is denoted by the symbol RETURN, followed by an expression if the procedure is a function procedure. The type of the expression must be assignment compatible with the result type specified in the procedure heading.
\par \tab Function procedures require the presence of a return statement indicating the result value. In proper procedures, a return statement is implied by the end of the procedure body. Any explicit return statement therefore appears as an additional (probably exceptional) termination point.
\par \tab An exit statement is denoted by the symbol EXIT. It specifies termination of the enclosing loop statement and continuation with the statement following that loop statement. Exit statements are contextually, although not syntactically associated with the loop statement which contains them.
\par 
\par \plain\f2\fs16\up6 #$K\plain\lang2057\f2\fs28  With statements
\par \plain\lang2057\f2\fs20 With statements execute a statement sequence depending on the result of a type test and apply a type guard to every occurrence of the tested variable within this statement sequence.
\par 
\par \pard\li567\plain\lang2057\f2\fs20 WithStatement \tab = WITH Guard DO StatementSequence \{"|" Guard DO StatementSequence\}
\par \tab \tab [ELSE StatementSequence] END.
\par Guard\tab = Qualident ":" Qualident.
\par \pard\plain\lang2057\f2\fs20 
\par If v is a variable parameter of record type or a pointer variable, and if it is of a static type T0, the statement
\par 
\par \tab WITH v: T1 DO S1 | v: T2 DO S2 ELSE S3 END
\par 
\par has the following meaning: if the dynamic type of v is T1, then the statement sequence S1 is executed where v is regarded as if it had the static type T1; else if the dynamic type of v is T2, then S2 is executed where v is regarded as if it had the static type T2; else S3 is executed. T1 and T2 must be extensions of T0. If no type test is satisfied and if an else clause is missing the program is aborted.
\par 
\par Example:
\par \tab WITH t: CenterTree DO i := t.width; c := t.subnode END
\par 
\par \plain\f2\fs16\up6 #$K\plain\lang2057\f2\fs28  Formal parameters
\par \plain\lang2057\f2\fs20 Formal parameters are identifiers declared in the formal parameter list of a procedure. They correspond to actual parameters specified in the procedure call. The correspondence between formal and actual parameters is established when the procedure is called. There are two kinds of parameters, value and variable parameters, indicated in the formal parameter list by the absence or presence of the keyword VAR. Value parameters are local variables to which the value of the corresponding actual parameter is assigned as an initial value. Variable parameters correspond to actual parameters that are variables, and they stand for these variables. The scope of a formal parameter extends from its declaration to the end of the procedure block in which it is declared. A function procedure without parameters must have an empty parameter list. It must be called by a function designator whose actual parameter list is empty too. The result type of a procedure can be neither a record nor an array.
\par 
\par \pard\li567\plain\lang2057\f2\fs20 FormalParameters\tab = "(" [FPSection \{";" FPSection\}] ")" [":" Qualident].
\par FPSection \tab = [VAR] ident \{"," ident\} ":" Type.
\par \pard\plain\lang2057\f2\fs20 
\par Let Tf be the type of a formal parameter f (not an open array) and Ta the type of the corresponding actual parameter a. For variable parameters, Ta must be the same as Tf, or Tf must be a record type and Ta an extension of Tf. For value parameters, a must be assignment compatible with f (see App. A).
\par \tab If Tf is an open array , then a must be array compatible with f (see App. A). The lengths of f are taken from a.
\par 
\par Examples of procedure declarations:
\par 
\par PROCEDURE ReadInt(VAR x: INTEGER);
\par \tab VAR i: INTEGER; ch: CHAR;
\par BEGIN i := 0; Read(ch);
\par \tab WHILE ("0" <= ch) & (ch <= "9") DO
\par \tab \tab i := 10*i + (ORD(ch)-ORD("0")); Read(ch)
\par \tab END;
\par \tab x := i
\par END ReadInt
\par 
\par PROCEDURE WriteInt(x: INTEGER); (*0 <= x <100000*)
\par \tab VAR i: INTEGER; buf: ARRAY 5 OF INTEGER;
\par BEGIN i := 0;
\par \tab REPEAT buf[i] := x MOD 10; x := x DIV 10; INC(i) UNTIL x = 0;
\par \tab REPEAT DEC(i); Write(CHR(buf[i] + ORD("0"))) UNTIL i = 0
\par END WriteInt
\par 
\par PROCEDURE WriteString(s: ARRAY OF CHAR);
\par \tab VAR i: INTEGER;
\par BEGIN i := 0;
\par \tab WHILE (i < LEN(s)) & (s[i] # 0X) DO Write(s[i]); INC(i) END
\par END WriteString;
\par 
\par 
\par PROCEDURE log2(x: INTEGER): INTEGER;
\par \tab VAR y: INTEGER; (*assume x>0*)
\par BEGIN
\par \tab y := 0; WHILE x > 1 DO x := x DIV 2; INC(y) END;
\par \tab RETURN y
\par END log2
\par 
\par \plain\f2\fs16\up6 #$K\plain\f2\fs28  Type-bound procedures
\par \plain\lang2057\f2\fs20 Globally declared procedures may be associated with a record type declared in the same module. The procedures are said to be bound to the record type. The binding is expressed by the type of the receiver in the heading of a procedure declaration.  The receiver may be either a variable parameter of record type T or a value parameter of type POINTER TO T (where T is a record type). The procedure is bound to the type T and is considered local to it.
\par 
\par \pard\li567\plain\lang2057\f2\fs20 ProcedureHeading\tab = PROCEDURE [Receiver] IdentDef [FormalParameters].
\par Receiver \tab = "(" [VAR] ident ":" ident ")".
\par \pard\plain\lang2057\f2\fs20 
\par If a procedure P is bound to a type T0, it is implicitly also bound to any type T1 which is an extension of T0. However, a procedure P ' (with the same name as P) may be explicitly bound to T1 in which case it overrides the binding of P. P ' is considered a redefinition of P for T1. The formal parameters of P and P ' must match. If P and T1 are exported P ' must be exported too.
\par \tab If v is a designator and P is a type-bound procedure, then v.P denotes that procedure P which is bound to the dynamic type of v (dynamic binding). Note, that this may be a different procedure than the one bound to the static type of v. v is passed to P's receiver according to the parameter passing rules.
\par \tab If r is a receiver parameter declared with type T, r.P^ denotes the (redefined) procedure P bound to the base type of T.
\par In a forward declaration of a type-bound procedure the receiver parameter must be of the same type as in the actual procedure declaration. The formal parameter lists of both declarations must match.
\par 
\par Examples:
\par 
\par PROCEDURE (t: Tree) Insert (node: Tree);
\par \tab VAR p, father: Tree;
\par BEGIN p := t;
\par \tab REPEAT father := p;
\par \tab \tab IF node.key = p.key THEN RETURN END;
\par \tab \tab IF node.key < p.key THEN p := p.left ELSE p := p.right END
\par \tab UNTIL p = NIL;
\par \tab IF node.key < father.key THEN father.left := node ELSE father.right := node END;
\par \tab node.left := NIL; node.right := NIL
\par END Insert;
\par 
\par PROCEDURE (t: CenterTree) Insert (node: Tree);  (*redefinition*)
\par BEGIN
\par \tab WriteInt(node(CenterTree).width);
\par \tab t.Insert^ (node)  (* calls the Insert procedure bound to Tree *)
\par END Insert;
\par \plain\f2\fs16\up6 #$K\plain\lang2057\f2\fs28  ABS
\par \plain\lang2057\f2\fs20 ABS(x)
\par 
\par Argument type: numeric type
\par 
\par Result type: type of x
\par 
\par Function
\par absolute value
\par \plain\f2\fs16\up6 #$K\plain\lang2057\f2\fs28  ASH
\par \plain\lang2057\f2\fs20 ASH(x,n)
\par 
\par Argument types: integer type
\par 
\par Result type: LONGINT
\par 
\par Function
\par arithmetic shift (x*2^n)
\par \plain\f2\fs16\up6 #$K\plain\lang2057\f2\fs28  CAP
\par \plain\lang2057\f2\fs20 CAP(x)
\par 
\par Argument type: CHAR
\par 
\par Result type: CHAR
\par 
\par Function
\par x is letter: corresponding capital letter
\par \plain\f2\fs16\up6 #$K\plain\lang2057\f2\fs28  CHR
\par \plain\lang2057\f2\fs20 CHR(x)
\par 
\par Argument type: integer type
\par 
\par Result type: CHAR
\par 
\par Function
\par character with ordinal number x
\par \plain\f2\fs16\up6 #$K\plain\lang2057\f2\fs28  ENTIER
\par \plain\lang2057\f2\fs20 ENTIER(x)
\par 
\par Argument type: real type
\par 
\par Result type: LONGINT
\par 
\par Function
\par largest integer not greater than x
\par \plain\f2\fs16\up6 #$K\plain\lang2057\f2\fs28  LEN
\par \plain\lang2057\f2\fs20 LEN(v) or LEN(v,n)
\par 
\par Argument type: v:array, n:integer constant
\par 
\par Result type: LONGINT
\par 
\par Function
\par length of v in dimension n or length of v in dimension 0 if n is not given.
\par \plain\f2\fs16\up6 #$K\plain\lang2057\f2\fs28  LONG
\par \plain\lang2057\f2\fs20 LONG(x)
\par 
\par Argument type: numeric type
\par 
\par Result type: next numeric type in type inclusion hierarchy
\par 
\par Function
\par identity
\par \plain\f2\fs16\up6 #$K\plain\lang2057\f2\fs28  MAX
\par \plain\lang2057\f2\fs20 MAX(T)
\par 
\par Argument type: T=basic type
\par Result type: T
\par Function: maximum value of type T
\par 
\par Argument type: T=SET
\par Result type: INTEGER
\par Function: maximum element of a set
\par \plain\f2\fs16\up6 #$K\plain\lang2057\f2\fs28  MIN
\par \plain\lang2057\f2\fs20 MIN(T)
\par 
\par Argument type: T=basic type
\par Result type: T
\par Function: minimum value of type T
\par 
\par Argument type: T=SET
\par Result type: INTEGER
\par Function: 0
\par \plain\f2\fs16\up6 #$K\plain\lang2057\f2\fs28  ODD
\par \plain\lang2057\f2\fs20 ODD(x)
\par 
\par Argument type: integer type
\par 
\par Result type: BOOLEAN
\par 
\par Function
\par x MOD 2 = 1
\par \plain\f2\fs16\up6 #$K\plain\lang2057\f2\fs28  ORD
\par \plain\lang2057\f2\fs20 ORD(x)
\par 
\par Argument type: CHAR
\par 
\par Result type: INTEGER
\par 
\par Function
\par ordinal number of x
\par \plain\f2\fs16\up6 #$K\plain\lang2057\f2\fs28  SHORT
\par \plain\lang2057\f2\fs20 SHORT(x)
\par 
\par Argument type: numeric type
\par 
\par Result type: previous type in type inclusion hierarchy
\par 
\par Function
\par identity
\par \plain\f2\fs16\up6 #$K\plain\lang2057\f2\fs28  SIZE
\par \plain\lang2057\f2\fs20 SIZE(T)
\par 
\par Argument type: any type
\par 
\par Result type: integer type
\par 
\par Function
\par number of bytes required by T
\par \plain\f2\fs16\up6 #$K\plain\lang2057\f2\fs28  COPY
\par \plain\lang2057\f2\fs20 COPY(x,v)
\par 
\par Argument types: x,v:character array
\par 
\par Function
\par v:=x
\par COPY allows the assignment between (open) character arrays with different types. If necessary, the source is shortened to the target length minus one. The target is always terminated by the character 0X.
\par \plain\f2\fs16\up6 #$K\plain\lang2057\f2\fs28  DEC
\par \plain\lang2057\f2\fs20 DEC(x) or DEC(x,d)
\par 
\par Argument types: integer types
\par 
\par Function
\par x:=x-1 or x:=x-d
\par \plain\f2\fs16\up6 #$K\plain\lang2057\f2\fs28  EXCL
\par \plain\lang2057\f2\fs20 EXCL(v,x)
\par 
\par Argument types: v:SET, x:integer type
\par 
\par Function
\par v:=v-\{x\}
\par \plain\f2\fs16\up6 #$K\plain\lang2057\f2\fs28  HALT
\par \plain\lang2057\f2\fs20 HALT(x)
\par 
\par Argument type: integer constant
\par 
\par Function
\par Terminate program execution.
\par The interpretation of x is left to the underlying system implementation. 
\par \plain\f2\fs16\up6 #$K\plain\lang2057\f2\fs28  INC
\par \plain\lang2057\f2\fs20 INC(x) or INC(x,d)
\par 
\par Argument types: integer types
\par 
\par Function
\par x:=x+1 or x:=x+d
\par \plain\f2\fs16\up6 #$K\plain\lang2057\f2\fs28  INCL
\par \plain\lang2057\f2\fs20 INCL(v,x)
\par 
\par Argument types: v:SET, x:integer type
\par 
\par Function
\par v:=v + \{x\}
\par \plain\f2\fs16\up6 #$K\plain\lang2057\f2\fs28  NEW
\par \plain\lang2057\f2\fs20 NEW(v)
\par 
\par Argument type: pointer to record or fixed array
\par 
\par Function
\par allocate v^
\par 
\par 
\par NEW(v,x0,...,xn)
\par 
\par Argument types: v: pointer to open array, xi:integer type
\par 
\par Function
\par allocate v^ with lengths x0..xn
\par 
\par \plain\f2\fs16\up6 #$K\plain\lang2057\f2\fs28  ASSERT
\par \plain\lang2057\f2\fs20 ASSERT(x)
\par ASSERT(x,n)
\par 
\par Argument types: x: boolean expression, n:integer constant
\par 
\par Function
\par terminate program execution if not x.
\par 
\par \plain\f2\fs16\up6 #$K\plain\lang2057\f2\fs28  Information specific to the RA Oberon-2 Compiler
\par \plain\f2\fs22\b Language Extensions
\par \plain\lang2057\f2\fs20 The following new language elements have been introduced:
\par 
\par The keyword \plain\f2\fs20\cf2\strike DISPOSE\plain\f2\fs20 key_DISPOSE allows to explicitly free allocated memory without the aid of a garbage collector.
\par 
\par \plain\lang2057\f2\fs20 The keyword \plain\f2\fs20\cf2\strike [_APICALL]\plain\f2\fs20 key_APICALL can be used to specify that a procedure needs to comply with the Windows standard calling convention.
\par 
\par \plain\lang2057\f2\fs20 The keyword \plain\f2\fs20\cf2\strike [_NOTALIGNED]\plain\f2\fs20 key_NOTALIGNED allows to prevent byte alignment of record or array elements.
\par \plain\lang2057\f2\fs20 
\par Modules declared with the keyword \plain\f2\fs20\cf2\strike DEFINITION\plain\f2\fs20 key_DEFINITION instead of MODULE are used to specify the interface of external libraries and DLLs. Within a definition module the new construct \plain\f2\fs20\cf2\strike VAR STATICTYPED\plain\f2\fs20 key_STATICTYPED permits a nice mapping of certain C style pointer parameters to Oberon-2 VAR parameters.
\par \plain\f2\fs22\b Module System
\par \plain\lang2057\f2\fs20\cf2\strike Register numbers\plain\lang2057\f2\fs20 Register_numbers
\par \plain\f2\fs16\up6 #$K\plain\lang2057\f2\fs28  Register numbers
\par \plain\lang2057\f2\fs20 The register numbers in PUTREG and GETREG are encoded as:
\par 
\par EAX=0;
\par ECX=1;
\par EDX=2;
\par EBX=3;
\par ESP=4;:
\par EBP=5;
\par ESI=6;
\par EDI=7;
\par ES=8;
\par CS=9;
\par SS=10;
\par DS=11;
\par FS=12;
\par GS=13;
\par EIP=14;
\par \plain\f2\fs16\up6 #$K\plain\lang2057\f2\fs28  DEFINITION
\par \plain\lang2057\f2\fs20 If instead of the keyword MODULE the word DEFINITION is used then only a symbol and a reduced object file is generated. In this case \plain\lang2057\f2\fs20\b all \plain\lang2057\f2\fs20 symbols declared in such a module will be exported. There are no statements in a definition module.
\par Definition modules are used to interface to the Windows API or to DLLs not created by the RA Oberon-2 Compiler.
\par The following example shows a definition module which provides access to one particular Windows GDI function. Data types are declared as needed to specify the parameter list of the function.
\par 
\par \plain\f4\fs16 DEFINITION SmallGDI;
\par 
\par IMPORT WD:=WinDef;
\par 
\par CONST
\par   LF_FACESIZE = 32;
\par 
\par TYPE
\par   LOGFONTA = RECORD \plain\f4\fs16\cf2\strike [_NOTALIGNED]\plain\f4\fs16 key_NOTALIGNED
\par     lfHeight        : LONGINT;
\par     lfWidth         : LONGINT;
\par     lfEscapement    : LONGINT;
\par     lfOrientation   : LONGINT;
\par     lfWeight        : LONGINT;
\par     lfItalic        : WD.BYTE;
\par     lfUnderline     : WD.BYTE;
\par     lfStrikeOut     : WD.BYTE;
\par     lfCharSet       : WD.BYTE;
\par     lfOutPrecision  : WD.BYTE;
\par     lfClipPrecision : WD.BYTE;
\par     lfQuality       : WD.BYTE;
\par     lfPitchAndFamily: WD.BYTE;
\par     lfFaceName      : ARRAY LF_FACESIZE OF CHAR;
\par   END;
\par 
\par 
\par \pard\li1980\fi-1980\plain\f4\fs16 PROCEDURE \plain\f4\fs16\cf2\strike [_APICALL]\plain\f4\fs16 key_APICALL CreateFontIndirectA(\plain\f4\fs16\cf2\strike VAR STATICTYPED\plain\f4\fs16 key_STATICTYPED lplf:LOGFONTA):WD.HFONT;
\par \pard\plain\f4\fs16 
\par END SmallGDI.
\par \plain\lang2057\f2\fs20 
\par 
\par The original C style function prototype for CreateFontIndirectA is
\par 
\par \plain\lang2057\f5\fs16 HFONT CreateFontIndirect(CONST LOGFONT *lplf\plain\f5\fs16 ); 
\par \plain\lang2057\f2\fs20 
\par The difference in the function names is caused by a special mechanism employed in the C header files to select between ASCII and Unicode compatible function calls. At system level, all Win32 API functions working with strings in some way (in our example the string lfFaceName is contained in the record passed as a parameter) exist twice, once with the basic function name appended with an \plain\f4\fs19 "\plain\lang2057\f2\fs20 A\plain\f4\fs19 "\plain\lang2057\f2\fs20  for the ASCII version and once with the basic function name appended with a \plain\f4\fs19 "\plain\lang2057\f2\fs20 W\plain\f4\fs19 " \plain\f2\fs20 for the Unicode version. Those names are available in C as well, and depending on the C project definition either all ASCII or all Unicode function names are mapped to the basic function name by a simple textual replacement with the help of the preprocessor. The API documentation usually only refers to the basic function name.\plain\lang2057\f2\fs20 
\par \plain\f2\fs16\up6 #$K\plain\lang2057\f2\fs28  DISPOSE
\par \plain\lang2057\f2\fs20 DISPOSE frees memory previously allocated with NEW.
\par When working with the garbage collector it is not necessary to call DISPOSE; however calling it in situations where memory can be disposed securely reduces the frequency of garbage collector runs and thus slightly increases performance.
\par It is also possible to create programs, which do not use the garbage collector. In this case all memory allocated with NEW has to be freed explicitly with DISPOSE.
\par 
\par Syntax: DISPOSE(pointer);
\par 
\par The garbage collector can be activated and deactivated in the linker options by selecting either a runtime system with or without the garbage collector.
\par 
\par Using the garbage collector might lead to problems in a special situation: when working with the Windows API, it is possible to allocate an object, transfer a reference to the object to Windows (e.g. by calling Windows.SetWindowLong) and not keep a reference within the scope of the Oberon program at all. In this case the garbage collector will remove the object at its next run. To prevent this it is necessary to import the module RTSGC and explicitly lock and unlock the memory objects in question via calls to RTSGC.Lock(pointer) and RTSGC.Unlock(pointer).
\par 
\par The current 32 bit release of Pow! Does not contain a garbage collector.
\par \plain\f2\fs16\up6 #$K\plain\lang2057\f2\fs28  [_APICALL]
\par \plain\lang2057\f2\fs20 The keyword [WINDOWS] has been introduced to facilitate interfacing to the Windows API.
\par 
\par It can be applied as follows:
\par 
\par \plain\f2\fs22\b Arrays
\par \plain\lang2057\f2\fs20 TYPE ... = ARRAY [WINDOWS] ...
\par There is no alignment between array elements or at the end of the array.
\par \plain\f2\fs22\b Records
\par \plain\lang2057\f2\fs20 TYPE ... = RECORD [WINDOWS] ...
\par There is no alignment between the fields or at the end of the record.
\par \plain\f2\fs22\b Procedures
\par \plain\lang2057\f2\fs20 PROCEDURE [WINDOWS] ....
\par The calling convention of the procedure complies with the calling convention for the Windows API.
\par \plain\f2\fs16\up6 #$K\plain\lang2057\f2\fs28  [_NOTALIGNED]
\par \plain\lang2057\f2\fs20 The keyword [WINDOWS] has been introduced to facilitate interfacing to the Windows API.
\par 
\par It can be applied as follows:
\par 
\par \plain\f2\fs22\b Arrays
\par \plain\lang2057\f2\fs20 TYPE ... = ARRAY [WINDOWS] ...
\par There is no alignment between array elements or at the end of the array.
\par \plain\f2\fs22\b Records
\par \plain\lang2057\f2\fs20 TYPE ... = RECORD [WINDOWS] ...
\par There is no alignment between the fields or at the end of the record.
\par \plain\f2\fs22\b Procedures
\par \plain\lang2057\f2\fs20 PROCEDURE [WINDOWS] ....
\par The calling convention of the procedure complies with the calling convention for the Windows API.
\par \plain\f2\fs16\up6 #$K\plain\lang2057\f2\fs28  VAR STATICTYPED
\par \plain\lang2057\f2\fs20 The keyword [WINDOWS] has been introduced to facilitate interfacing to the Windows API.
\par 
\par It can be applied as follows:
\par 
\par \plain\f2\fs22\b Arrays
\par \plain\lang2057\f2\fs20 TYPE ... = ARRAY [WINDOWS] ...
\par There is no alignment between array elements or at the end of the array.
\par \plain\f2\fs22\b Records
\par \plain\lang2057\f2\fs20 TYPE ... = RECORD [WINDOWS] ...
\par There is no alignment between the fields or at the end of the record.
\par \plain\f2\fs22\b Procedures
\par \plain\lang2057\f2\fs20 PROCEDURE [WINDOWS] ....
\par The calling convention of the procedure complies with the calling convention for the Windows API.
\par \plain\f6\fs16\b\up12 #$K\plain\f2\fs28\b Contents
\par \plain\f2\fs20\cf1\strike module ColorPlane\plain\f2\fs20 ColorPlane
\par \plain\f2\fs20\cf1\strike module Display\plain\f2\fs20 Display
\par \plain\f2\fs20\cf1\strike module File\plain\f2\fs20 File
\par \plain\f2\fs20\cf1\strike module Float\plain\f2\fs20 Float
\par \plain\f2\fs20\cf1\strike module In\plain\f2\fs20 In
\par \plain\f2\fs20\cf1\strike module OOBase\plain\f2\fs20 OOBase
\par \plain\f2\fs20\cf1\strike module Out\plain\f2\fs20 Out
\par \plain\f2\fs20\cf1\strike module Param\plain\f2\fs20 Param
\par \plain\f2\fs20\cf1\strike module Print\plain\f2\fs20 Print
\par \plain\f2\fs20\cf1\strike module Process\plain\f2\fs20 Process
\par \plain\f2\fs20\cf1\strike module Strings\plain\f2\fs20 Strings
\par \plain\f2\fs20\cf1\strike module Utils\plain\f2\fs20 Utils
\par \plain\f2\fs20\cf1\strike module Volume\plain\f2\fs20 Volume
\par \plain\f2\fs20\cf1\strike module XYplane\plain\f2\fs20 XYplane
\par \plain\f2\fs19\b\up14 #$K\plain\f2\fs28\b Module ColorPlane
\par \plain\f2\fs20 This module provides easy to use simple color graphics.
\par All output operations represent their output in a drawing region with fixed resolution. This implementation provides an area of 800 x 650 pixel (horizontal by vertical).
\par The left bottom corner of the output area has the co-ordinate (0,0), the same as for the Cartesian system of co-ordinates.
\par The definition of colors is based upon a true-color model which defines the colors by their relative concentrations of red, green and blue. As not every system supports a true-color display the desired colors are mapped to the nearest available colors.
\par A cursor is used to indicate the position for input and output of text. It can be positioned by calling the relevant procedures and appears as a flashing mark on the screen.
\par \plain\f2\fs24\b Constants
\par \pard\li2880\fi-2880\plain\f2\fs20 draw\tab \tab \tab \tab 
\par erase\tab \tab \tab \tab 
\par DRAW\tab \tab \tab \tab required with the parameter \plain\f2\fs20\b mode\plain\f2\fs20  to draw with the foreground color 
\par ERASE\tab \tab \tab required with the parameter \plain\f2\fs20\b mode\plain\f2\fs20  to draw with the background color 
\par RESOLUTIONX\tab \tab \tab horizontal resolution of the drawing area 
\par RESOLUTIONY\tab \tab vertical resolution of the drawing area 
\par CURSUP\tab \tab \tab 
\par CURSDOWN\tab \tab \tab 
\par CURSLEFT\tab \tab \tab 
\par CURSRIGHT\tab \tab \tab 
\par INSERT\tab \tab \tab 
\par DELETE\tab \tab \tab 
\par HOME\tab \tab \tab \tab 
\par ENDKEY\tab \tab \tab 
\par PAGEUP\tab \tab \tab 
\par PAGEDOWN\tab \tab \tab 
\par F1\tab \tab \tab \tab 
\par F2\tab \tab \tab \tab 
\par F3\tab \tab \tab \tab 
\par F4\tab \tab \tab \tab 
\par F5\tab \tab \tab \tab 
\par F6\tab \tab \tab \tab 
\par F7\tab \tab \tab \tab 
\par F8\tab \tab \tab \tab 
\par F9\tab \tab \tab \tab 
\par F10\tab \tab \tab \tab 
\par F11\tab \tab \tab \tab 
\par F12\tab \tab \tab \tab 
\par F13\tab \tab \tab \tab 
\par F14\tab \tab \tab \tab 
\par F15\tab \tab \tab \tab 
\par F16\tab \tab \tab \tab 
\par F17\tab \tab \tab \tab 
\par F18\tab \tab \tab \tab 
\par F19\tab \tab \tab \tab 
\par F20\tab \tab \tab \tab 
\par F21\tab \tab \tab \tab 
\par F22\tab \tab \tab \tab 
\par F23\tab \tab \tab \tab 
\par F24\tab \tab \tab \tab 
\par ENTER\tab \tab \tab \tab 
\par ESC\tab \tab \tab \tab 
\par TAB\tab \tab \tab \tab 
\par BACKSPACE\tab \tab \tab 
\par INPUTINVALID\tab \tab \tab 
\par \pard\plain\f2\fs24\b Procedures
\par \plain\f2\fs20\cf1\strike Open\plain\f2\fs20 ColorPlane_Open
\par \plain\f2\fs20\cf1\strike Close\plain\f2\fs20 ColorPlane_Close
\par \plain\f2\fs20\cf1\strike SetScreenUpdate\plain\f2\fs20 ColorPlane_SetScreenUpdate
\par \plain\f2\fs20\cf1\strike Dot\plain\f2\fs20 ColorPlane_Dot
\par \plain\f2\fs20\cf1\strike Line\plain\f2\fs20 ColorPlane_Line
\par \plain\f2\fs20\cf1\strike Bar\plain\f2\fs20 ColorPlane_Bar
\par \plain\f2\fs20\cf1\strike Box\plain\f2\fs20 ColorPlane_Box
\par \plain\f2\fs20\cf1\strike GetDot\plain\f2\fs20 ColorPlane_GetDot
\par \plain\f2\fs20\cf1\strike Clear\plain\f2\fs20 ColorPlane_Clear
\par \plain\f2\fs20\cf1\strike SetForeColor\plain\f2\fs20 ColorPlane_SetForeColor
\par \plain\f2\fs20\cf1\strike SetBackColor\plain\f2\fs20 ColorPlane_SetBackColor
\par \plain\f2\fs20\cf1\strike GetForeColor\plain\f2\fs20 ColorPlane_GetForeColor
\par \plain\f2\fs20\cf1\strike GetBackColor\plain\f2\fs20 ColorPlane_GetBackColor
\par \plain\f2\fs20\cf1\strike WriteStr\plain\f2\fs20 ColorPlane_WriteStr
\par \plain\f2\fs20\cf1\strike WriteLn\plain\f2\fs20 ColorPlane_WriteLn
\par \plain\f2\fs20\cf1\strike GotoXY\plain\f2\fs20 ColorPlane_GotoXY
\par \plain\f2\fs20\cf1\strike WhereX\plain\f2\fs20 ColorPlane_WhereX
\par \plain\f2\fs20\cf1\strike WhereY\plain\f2\fs20 ColorPlane_WhereY
\par \plain\f2\fs20\cf1\strike KeyPressed\plain\f2\fs20 ColorPlane_KeyPressed
\par \plain\f2\fs20\cf1\strike ReadKey\plain\f2\fs20 ColorPlane_ReadKey
\par \plain\f2\fs20\cf1\strike CursorOn\plain\f2\fs20 ColorPlane_CursorOn
\par \plain\f2\fs20\cf1\strike CursorOff\plain\f2\fs20 ColorPlane_CursorOff
\par \plain\f2\fs20\cf1\strike IsCursorOn\plain\f2\fs20 ColorPlane_IsCursorOn
\par \plain\f2\fs20\cf1\strike ReadStr\plain\f2\fs20 ColorPlane_ReadStr
\par \plain\f2\fs20\cf1\strike EditStr\plain\f2\fs20 ColorPlane_EditStr
\par \plain\f2\fs20\cf1\strike GetMouse\plain\f2\fs20 ColorPlane_GetMouse
\par \plain\f2\fs20\cf1\strike TextWidth\plain\f2\fs20 ColorPlane_TextWidth
\par \plain\f2\fs20\cf1\strike TextHeight\plain\f2\fs20 ColorPlane_TextHeight
\par \plain\f2\fs19\b\up14 #$K\plain\f2\fs28\b Open
\par \plain\f2\fs20\b defined in module \plain\f2\fs20\cf1\b\strike ColorPlane\plain\f2\fs20\b ColorPlane
\par \plain\f2\fs24\b Syntax
\par \plain\f5\fs20 PROCEDURE Open()
\par \plain\f2\fs24\b Description
\par \plain\f2\fs20 The display area for the graphics is created in the program window. This function must be called before any other function in the module as it provides the initialization. 
\par \plain\f2\fs19\b\up14 #$K\plain\f2\fs28\b Close
\par \plain\f2\fs20\b defined in module \plain\f2\fs20\cf1\b\strike ColorPlane\plain\f2\fs20\b ColorPlane
\par \plain\f2\fs24\b Syntax
\par \plain\f5\fs20 PROCEDURE Close()
\par \plain\f2\fs24\b Description
\par \plain\f2\fs20 The display area for the graphics is closed. The free space in the program window is divided for the remaining output areas (e.g., for the modules \plain\f2\fs20\b Display\plain\f2\fs20  or \plain\f2\fs20\b Out\plain\f2\fs20 ). 
\par \plain\f2\fs19\b\up14 #$K\plain\f2\fs28\b SetScreenUpdate
\par \plain\f2\fs20\b defined in module \plain\f2\fs20\cf1\b\strike ColorPlane\plain\f2\fs20\b ColorPlane
\par \plain\f2\fs24\b Syntax
\par \plain\f5\fs20 PROCEDURE SetScreenUpdate(x:BOOLEAN)
\par \plain\f2\fs24\b Description
\par \plain\f2\fs20 This function inhibits drawing visibly on the screen if \plain\f2\fs20\b x\plain\f2\fs20  is FALSE; if TRUE then drawing is as normal. When the update is re-enabled again all changes that have taken place in the meantime are displayed automatically. 
\par \plain\f2\fs19\b\up14 #$K\plain\f2\fs28\b Dot
\par \plain\f2\fs20\b defined in module \plain\f2\fs20\cf1\b\strike ColorPlane\plain\f2\fs20\b ColorPlane
\par \plain\f2\fs24\b Syntax
\par \plain\f5\fs20 PROCEDURE Dot(x, y, mode:INTEGER)
\par \plain\f2\fs19\b\up14 #$K\plain\f2\fs28\b Line
\par \plain\f2\fs20\b defined in module \plain\f2\fs20\cf1\b\strike ColorPlane\plain\f2\fs20\b ColorPlane
\par \plain\f2\fs24\b Syntax
\par \plain\f5\fs20 PROCEDURE Line(x1, y1, x2, y2, mode:INTEGER)
\par \plain\f2\fs19\b\up14 #$K\plain\f2\fs28\b Bar
\par \plain\f2\fs20\b defined in module \plain\f2\fs20\cf1\b\strike ColorPlane\plain\f2\fs20\b ColorPlane
\par \plain\f2\fs24\b Syntax
\par \plain\f5\fs20 PROCEDURE Bar(x1, y1, x2, y2, mode:INTEGER)
\par \plain\f2\fs19\b\up14 #$K\plain\f2\fs28\b Box
\par \plain\f2\fs20\b defined in module \plain\f2\fs20\cf1\b\strike ColorPlane\plain\f2\fs20\b ColorPlane
\par \plain\f2\fs24\b Syntax
\par \plain\f5\fs20 PROCEDURE Box(x1, y1, x2, y2, mode:INTEGER)
\par \plain\f2\fs19\b\up14 #$K\plain\f2\fs28\b GetDot
\par \plain\f2\fs20\b defined in module \plain\f2\fs20\cf1\b\strike ColorPlane\plain\f2\fs20\b ColorPlane
\par \plain\f2\fs24\b Syntax
\par \plain\f5\fs20 PROCEDURE GetDot(x, y:INTEGER; 
\par                  VAR r, g, b:INTEGER)
\par \plain\f2\fs19\b\up14 #$K\plain\f2\fs28\b Clear
\par \plain\f2\fs20\b defined in module \plain\f2\fs20\cf1\b\strike ColorPlane\plain\f2\fs20\b ColorPlane
\par \plain\f2\fs24\b Syntax
\par \plain\f5\fs20 PROCEDURE Clear()
\par \plain\f2\fs19\b\up14 #$K\plain\f2\fs28\b SetForeColor
\par \plain\f2\fs20\b defined in module \plain\f2\fs20\cf1\b\strike ColorPlane\plain\f2\fs20\b ColorPlane
\par \plain\f2\fs24\b Syntax
\par \plain\f5\fs20 PROCEDURE SetForeColor(r, g, b:INTEGER)
\par \plain\f2\fs19\b\up14 #$K\plain\f2\fs28\b SetBackColor
\par \plain\f2\fs20\b defined in module \plain\f2\fs20\cf1\b\strike ColorPlane\plain\f2\fs20\b ColorPlane
\par \plain\f2\fs24\b Syntax
\par \plain\f5\fs20 PROCEDURE SetBackColor(r, g, b:INTEGER)
\par \plain\f2\fs19\b\up14 #$K\plain\f2\fs28\b GetForeColor
\par \plain\f2\fs20\b defined in module \plain\f2\fs20\cf1\b\strike ColorPlane\plain\f2\fs20\b ColorPlane
\par \plain\f2\fs24\b Syntax
\par \plain\f5\fs20 PROCEDURE GetForeColor(VAR r, g, b:INTEGER)
\par \plain\f2\fs19\b\up14 #$K\plain\f2\fs28\b GetBackColor
\par \plain\f2\fs20\b defined in module \plain\f2\fs20\cf1\b\strike ColorPlane\plain\f2\fs20\b ColorPlane
\par \plain\f2\fs24\b Syntax
\par \plain\f5\fs20 PROCEDURE GetBackColor(VAR r, g, b:INTEGER)
\par \plain\f2\fs19\b\up14 #$K\plain\f2\fs28\b WriteStr
\par \plain\f2\fs20\b defined in module \plain\f2\fs20\cf1\b\strike ColorPlane\plain\f2\fs20\b ColorPlane
\par \plain\f2\fs24\b Syntax
\par \plain\f5\fs20 PROCEDURE WriteStr(txt:ARRAY OF CHAR)
\par \plain\f2\fs19\b\up14 #$K\plain\f2\fs28\b WriteLn
\par \plain\f2\fs20\b defined in module \plain\f2\fs20\cf1\b\strike ColorPlane\plain\f2\fs20\b ColorPlane
\par \plain\f2\fs24\b Syntax
\par \plain\f5\fs20 PROCEDURE WriteLn()
\par \plain\f2\fs19\b\up14 #$K\plain\f2\fs28\b GotoXY
\par \plain\f2\fs20\b defined in module \plain\f2\fs20\cf1\b\strike ColorPlane\plain\f2\fs20\b ColorPlane
\par \plain\f2\fs24\b Syntax
\par \plain\f5\fs20 PROCEDURE GotoXY(x, y:INTEGER)
\par \plain\f2\fs19\b\up14 #$K\plain\f2\fs28\b WhereX
\par \plain\f2\fs20\b defined in module \plain\f2\fs20\cf1\b\strike ColorPlane\plain\f2\fs20\b ColorPlane
\par \plain\f2\fs24\b Syntax
\par \plain\f5\fs20 PROCEDURE WhereX():INTEGER
\par \plain\f2\fs19\b\up14 #$K\plain\f2\fs28\b WhereY
\par \plain\f2\fs20\b defined in module \plain\f2\fs20\cf1\b\strike ColorPlane\plain\f2\fs20\b ColorPlane
\par \plain\f2\fs24\b Syntax
\par \plain\f5\fs20 PROCEDURE WhereY():INTEGER
\par \plain\f2\fs19\b\up14 #$K\plain\f2\fs28\b KeyPressed
\par \plain\f2\fs20\b defined in module \plain\f2\fs20\cf1\b\strike ColorPlane\plain\f2\fs20\b ColorPlane
\par \plain\f2\fs24\b Syntax
\par \plain\f5\fs20 PROCEDURE KeyPressed():BOOLEAN
\par \plain\f2\fs19\b\up14 #$K\plain\f2\fs28\b ReadKey
\par \plain\f2\fs20\b defined in module \plain\f2\fs20\cf1\b\strike ColorPlane\plain\f2\fs20\b ColorPlane
\par \plain\f2\fs24\b Syntax
\par \plain\f5\fs20 PROCEDURE ReadKey():CHAR
\par \plain\f2\fs19\b\up14 #$K\plain\f2\fs28\b CursorOn
\par \plain\f2\fs20\b defined in module \plain\f2\fs20\cf1\b\strike ColorPlane\plain\f2\fs20\b ColorPlane
\par \plain\f2\fs24\b Syntax
\par \plain\f5\fs20 PROCEDURE CursorOn()
\par \plain\f2\fs19\b\up14 #$K\plain\f2\fs28\b CursorOff
\par \plain\f2\fs20\b defined in module \plain\f2\fs20\cf1\b\strike ColorPlane\plain\f2\fs20\b ColorPlane
\par \plain\f2\fs24\b Syntax
\par \plain\f5\fs20 PROCEDURE CursorOff()
\par \plain\f2\fs19\b\up14 #$K\plain\f2\fs28\b IsCursorOn
\par \plain\f2\fs20\b defined in module \plain\f2\fs20\cf1\b\strike ColorPlane\plain\f2\fs20\b ColorPlane
\par \plain\f2\fs24\b Syntax
\par \plain\f5\fs20 PROCEDURE IsCursorOn():BOOLEAN
\par \plain\f2\fs19\b\up14 #$K\plain\f2\fs28\b ReadStr
\par \plain\f2\fs20\b defined in module \plain\f2\fs20\cf1\b\strike ColorPlane\plain\f2\fs20\b ColorPlane
\par \plain\f2\fs24\b Syntax
\par \plain\f5\fs20 PROCEDURE ReadStr(VAR t:ARRAY OF CHAR; 
\par                   maxLen:INTEGER; 
\par                   VAR resCode:CHAR)
\par \plain\f2\fs19\b\up14 #$K\plain\f2\fs28\b EditStr
\par \plain\f2\fs20\b defined in module \plain\f2\fs20\cf1\b\strike ColorPlane\plain\f2\fs20\b ColorPlane
\par \plain\f2\fs24\b Syntax
\par \plain\f5\fs20 PROCEDURE EditStr(VAR t:ARRAY OF CHAR; 
\par                   maxLen:INTEGER; 
\par                   VAR resCode:CHAR)
\par \plain\f2\fs19\b\up14 #$K\plain\f2\fs28\b GetMouse
\par \plain\f2\fs20\b defined in module \plain\f2\fs20\cf1\b\strike ColorPlane\plain\f2\fs20\b ColorPlane
\par \plain\f2\fs24\b Syntax
\par \plain\f5\fs20 PROCEDURE GetMouse(VAR buttons:SET; 
\par                    VAR x, y:INTEGER)
\par \plain\f2\fs19\b\up14 #$K\plain\f2\fs28\b TextWidth
\par \plain\f2\fs20\b defined in module \plain\f2\fs20\cf1\b\strike ColorPlane\plain\f2\fs20\b ColorPlane
\par \plain\f2\fs24\b Syntax
\par \plain\f5\fs20 PROCEDURE TextWidth(VAR txt:ARRAY OF CHAR):INTEGER
\par \plain\f2\fs19\b\up14 #$K\plain\f2\fs28\b TextHeight
\par \plain\f2\fs20\b defined in module \plain\f2\fs20\cf1\b\strike ColorPlane\plain\f2\fs20\b ColorPlane
\par \plain\f2\fs24\b Syntax
\par \plain\f5\fs20 PROCEDURE TextHeight():INTEGER
\par \plain\f2\fs19\b\up14 #$K\plain\f2\fs28\b Module Display
\par \plain\f2\fs20 This module provides a simple, text-oriented user interface. It is an easy to understand basis especially for programmers just starting to use Oberon-2. Its main purpose is to make it easy to display text from a Windows program. As far as its features are concerned it is adapted to the possibilities of usual devices operating in the text mode.
\par In this implementation a window is used for displaying up to 80 characters and 25 lines with a non-proportional font. If the size of the window is reduced any desired section of the whole window can be viewed using scroll bars.
\par \plain\f2\fs24\b Constants
\par \pard\li2880\fi-2880\plain\f2\fs20 CURSUP\tab \tab \tab 
\par CURSDOWN\tab \tab \tab 
\par CURSLEFT\tab \tab \tab 
\par CURSRIGHT\tab \tab \tab 
\par INSERT\tab \tab \tab 
\par DELETE\tab \tab \tab 
\par HOME\tab \tab \tab \tab 
\par ENDKEY\tab \tab \tab 
\par PAGEUP\tab \tab \tab 
\par PAGEDOWN\tab \tab \tab 
\par F1\tab \tab \tab \tab 
\par F2\tab \tab \tab \tab 
\par F3\tab \tab \tab \tab 
\par F4\tab \tab \tab \tab 
\par F5\tab \tab \tab \tab 
\par F6\tab \tab \tab \tab 
\par F7\tab \tab \tab \tab 
\par F8\tab \tab \tab \tab 
\par F9\tab \tab \tab \tab 
\par F10\tab \tab \tab \tab 
\par F11\tab \tab \tab \tab 
\par F12\tab \tab \tab \tab 
\par F13\tab \tab \tab \tab 
\par F14\tab \tab \tab \tab 
\par F15\tab \tab \tab \tab 
\par F16\tab \tab \tab \tab 
\par F17\tab \tab \tab \tab 
\par F18\tab \tab \tab \tab 
\par F19\tab \tab \tab \tab 
\par F20\tab \tab \tab \tab 
\par F21\tab \tab \tab \tab 
\par F22\tab \tab \tab \tab 
\par F23\tab \tab \tab \tab 
\par F24\tab \tab \tab \tab 
\par ENTER\tab \tab \tab \tab 
\par ESC\tab \tab \tab \tab 
\par TAB\tab \tab \tab \tab 
\par BACKSPACE\tab \tab \tab 
\par INPUTINVALID\tab \tab \tab 
\par \pard\plain\f2\fs24\b Procedures
\par \plain\f2\fs20\cf1\strike SetWindowTitle\plain\f2\fs20 Display_SetWindowTitle
\par \plain\f2\fs20\cf1\strike GotoXY\plain\f2\fs20 Display_GotoXY
\par \plain\f2\fs20\cf1\strike WhereX\plain\f2\fs20 Display_WhereX
\par \plain\f2\fs20\cf1\strike WhereY\plain\f2\fs20 Display_WhereY
\par \plain\f2\fs20\cf1\strike WriteCharXY\plain\f2\fs20 Display_WriteCharXY
\par \plain\f2\fs20\cf1\strike GetCharXY\plain\f2\fs20 Display_GetCharXY
\par \plain\f2\fs20\cf1\strike GetStrXY\plain\f2\fs20 Display_GetStrXY
\par \plain\f2\fs20\cf1\strike WriteLn\plain\f2\fs20 Display_WriteLn
\par \plain\f2\fs20\cf1\strike WriteChar\plain\f2\fs20 Display_WriteChar
\par \plain\f2\fs20\cf1\strike WriteStrXY\plain\f2\fs20 Display_WriteStrXY
\par \plain\f2\fs20\cf1\strike WriteStr\plain\f2\fs20 Display_WriteStr
\par \plain\f2\fs20\cf1\strike WriteSpacesXY\plain\f2\fs20 Display_WriteSpacesXY
\par \plain\f2\fs20\cf1\strike WriteSpaces\plain\f2\fs20 Display_WriteSpaces
\par \plain\f2\fs20\cf1\strike WriteIntXY\plain\f2\fs20 Display_WriteIntXY
\par \plain\f2\fs20\cf1\strike WriteInt\plain\f2\fs20 Display_WriteInt
\par \plain\f2\fs20\cf1\strike WriteRealXY\plain\f2\fs20 Display_WriteRealXY
\par \plain\f2\fs20\cf1\strike WriteReal\plain\f2\fs20 Display_WriteReal
\par \plain\f2\fs20\cf1\strike KeyPressed\plain\f2\fs20 Display_KeyPressed
\par \plain\f2\fs20\cf1\strike ReadKey\plain\f2\fs20 Display_ReadKey
\par \plain\f2\fs20\cf1\strike CursorOn\plain\f2\fs20 Display_CursorOn
\par \plain\f2\fs20\cf1\strike CursorOff\plain\f2\fs20 Display_CursorOff
\par \plain\f2\fs20\cf1\strike IsCursorOn\plain\f2\fs20 Display_IsCursorOn
\par \plain\f2\fs20\cf1\strike TerminalBell\plain\f2\fs20 Display_TerminalBell
\par \plain\f2\fs20\cf1\strike ReadChar\plain\f2\fs20 Display_ReadChar
\par \plain\f2\fs20\cf1\strike ReadLongInt\plain\f2\fs20 Display_ReadLongInt
\par \plain\f2\fs20\cf1\strike ReadReal\plain\f2\fs20 Display_ReadReal
\par \plain\f2\fs20\cf1\strike ReadLongReal\plain\f2\fs20 Display_ReadLongReal
\par \plain\f2\fs20\cf1\strike ReadInt\plain\f2\fs20 Display_ReadInt
\par \plain\f2\fs20\cf1\strike ReadStr\plain\f2\fs20 Display_ReadStr
\par \plain\f2\fs20\cf1\strike EditStr\plain\f2\fs20 Display_EditStr
\par \plain\f2\fs20\cf1\strike FlushKeyBuffer\plain\f2\fs20 Display_FlushKeyBuffer
\par \plain\f2\fs20\cf1\strike ClrScr\plain\f2\fs20 Display_ClrScr
\par \plain\f2\fs20\cf1\strike SetForeColor\plain\f2\fs20 Display_SetForeColor
\par \plain\f2\fs20\cf1\strike SetBackColor\plain\f2\fs20 Display_SetBackColor
\par \plain\f2\fs20\cf1\strike GetForeColor\plain\f2\fs20 Display_GetForeColor
\par \plain\f2\fs20\cf1\strike GetBackColor\plain\f2\fs20 Display_GetBackColor
\par \plain\f2\fs20\cf1\strike IsColorSupported\plain\f2\fs20 Display_IsColorSupported
\par \plain\f2\fs19\b\up14 #$K\plain\f2\fs28\b SetWindowTitle
\par \plain\f2\fs20\b defined in module \plain\f2\fs20\cf1\b\strike Display\plain\f2\fs20\b Display
\par \plain\f2\fs24\b Syntax
\par \plain\f5\fs20 PROCEDURE SetWindowTitle(t:ARRAY OF CHAR)
\par \plain\f2\fs19\b\up14 #$K\plain\f2\fs28\b GotoXY
\par \plain\f2\fs20\b defined in module \plain\f2\fs20\cf1\b\strike Display\plain\f2\fs20\b Display
\par \plain\f2\fs24\b Syntax
\par \plain\f5\fs20 PROCEDURE GotoXY(s, z:INTEGER)
\par \plain\f2\fs19\b\up14 #$K\plain\f2\fs28\b WhereX
\par \plain\f2\fs20\b defined in module \plain\f2\fs20\cf1\b\strike Display\plain\f2\fs20\b Display
\par \plain\f2\fs24\b Syntax
\par \plain\f5\fs20 PROCEDURE WhereX():INTEGER
\par \plain\f2\fs19\b\up14 #$K\plain\f2\fs28\b WhereY
\par \plain\f2\fs20\b defined in module \plain\f2\fs20\cf1\b\strike Display\plain\f2\fs20\b Display
\par \plain\f2\fs24\b Syntax
\par \plain\f5\fs20 PROCEDURE WhereY():INTEGER
\par \plain\f2\fs19\b\up14 #$K\plain\f2\fs28\b WriteCharXY
\par \plain\f2\fs20\b defined in module \plain\f2\fs20\cf1\b\strike Display\plain\f2\fs20\b Display
\par \plain\f2\fs24\b Syntax
\par \plain\f5\fs20 PROCEDURE WriteCharXY(s, z:INTEGER; 
\par                       x:CHAR)
\par \plain\f2\fs19\b\up14 #$K\plain\f2\fs28\b GetCharXY
\par \plain\f2\fs20\b defined in module \plain\f2\fs20\cf1\b\strike Display\plain\f2\fs20\b Display
\par \plain\f2\fs24\b Syntax
\par \plain\f5\fs20 PROCEDURE GetCharXY(s, z:INTEGER):CHAR
\par \plain\f2\fs19\b\up14 #$K\plain\f2\fs28\b GetStrXY
\par \plain\f2\fs20\b defined in module \plain\f2\fs20\cf1\b\strike Display\plain\f2\fs20\b Display
\par \plain\f2\fs24\b Syntax
\par \plain\f5\fs20 PROCEDURE GetStrXY(s, z, n:INTEGER; 
\par                    VAR t:ARRAY OF CHAR)
\par \plain\f2\fs19\b\up14 #$K\plain\f2\fs28\b WriteLn
\par \plain\f2\fs20\b defined in module \plain\f2\fs20\cf1\b\strike Display\plain\f2\fs20\b Display
\par \plain\f2\fs24\b Syntax
\par \plain\f5\fs20 PROCEDURE WriteLn()
\par \plain\f2\fs19\b\up14 #$K\plain\f2\fs28\b WriteChar
\par \plain\f2\fs20\b defined in module \plain\f2\fs20\cf1\b\strike Display\plain\f2\fs20\b Display
\par \plain\f2\fs24\b Syntax
\par \plain\f5\fs20 PROCEDURE WriteChar(x:CHAR)
\par \plain\f2\fs19\b\up14 #$K\plain\f2\fs28\b WriteStrXY
\par \plain\f2\fs20\b defined in module \plain\f2\fs20\cf1\b\strike Display\plain\f2\fs20\b Display
\par \plain\f2\fs24\b Syntax
\par \plain\f5\fs20 PROCEDURE WriteStrXY(s, z:INTEGER; 
\par                      t:ARRAY OF CHAR)
\par \plain\f2\fs19\b\up14 #$K\plain\f2\fs28\b WriteStr
\par \plain\f2\fs20\b defined in module \plain\f2\fs20\cf1\b\strike Display\plain\f2\fs20\b Display
\par \plain\f2\fs24\b Syntax
\par \plain\f5\fs20 PROCEDURE WriteStr(t:ARRAY OF CHAR)
\par \plain\f2\fs19\b\up14 #$K\plain\f2\fs28\b WriteSpacesXY
\par \plain\f2\fs20\b defined in module \plain\f2\fs20\cf1\b\strike Display\plain\f2\fs20\b Display
\par \plain\f2\fs24\b Syntax
\par \plain\f5\fs20 PROCEDURE WriteSpacesXY(s, z:INTEGER; 
\par                         n:INTEGER)
\par \plain\f2\fs19\b\up14 #$K\plain\f2\fs28\b WriteSpaces
\par \plain\f2\fs20\b defined in module \plain\f2\fs20\cf1\b\strike Display\plain\f2\fs20\b Display
\par \plain\f2\fs24\b Syntax
\par \plain\f5\fs20 PROCEDURE WriteSpaces(n:INTEGER)
\par \plain\f2\fs19\b\up14 #$K\plain\f2\fs28\b WriteIntXY
\par \plain\f2\fs20\b defined in module \plain\f2\fs20\cf1\b\strike Display\plain\f2\fs20\b Display
\par \plain\f2\fs24\b Syntax
\par \plain\f5\fs20 PROCEDURE WriteIntXY(s, z:INTEGER; 
\par                      x:LONGINT; 
\par                      len:INTEGER)
\par \plain\f2\fs19\b\up14 #$K\plain\f2\fs28\b WriteInt
\par \plain\f2\fs20\b defined in module \plain\f2\fs20\cf1\b\strike Display\plain\f2\fs20\b Display
\par \plain\f2\fs24\b Syntax
\par \plain\f5\fs20 PROCEDURE WriteInt(x:LONGINT; 
\par                    len:INTEGER)
\par \plain\f2\fs19\b\up14 #$K\plain\f2\fs28\b WriteRealXY
\par \plain\f2\fs20\b defined in module \plain\f2\fs20\cf1\b\strike Display\plain\f2\fs20\b Display
\par \plain\f2\fs24\b Syntax
\par \plain\f5\fs20 PROCEDURE WriteRealXY(s, z:INTEGER; 
\par                       x:LONGREAL; 
\par                       n:INTEGER)
\par \plain\f2\fs19\b\up14 #$K\plain\f2\fs28\b WriteReal
\par \plain\f2\fs20\b defined in module \plain\f2\fs20\cf1\b\strike Display\plain\f2\fs20\b Display
\par \plain\f2\fs24\b Syntax
\par \plain\f5\fs20 PROCEDURE WriteReal(x:LONGREAL; 
\par                     n:INTEGER)
\par \plain\f2\fs19\b\up14 #$K\plain\f2\fs28\b KeyPressed
\par \plain\f2\fs20\b defined in module \plain\f2\fs20\cf1\b\strike Display\plain\f2\fs20\b Display
\par \plain\f2\fs24\b Syntax
\par \plain\f5\fs20 PROCEDURE KeyPressed():BOOLEAN
\par \plain\f2\fs19\b\up14 #$K\plain\f2\fs28\b ReadKey
\par \plain\f2\fs20\b defined in module \plain\f2\fs20\cf1\b\strike Display\plain\f2\fs20\b Display
\par \plain\f2\fs24\b Syntax
\par \plain\f5\fs20 PROCEDURE ReadKey():CHAR
\par \plain\f2\fs19\b\up14 #$K\plain\f2\fs28\b CursorOn
\par \plain\f2\fs20\b defined in module \plain\f2\fs20\cf1\b\strike Display\plain\f2\fs20\b Display
\par \plain\f2\fs24\b Syntax
\par \plain\f5\fs20 PROCEDURE CursorOn()
\par \plain\f2\fs19\b\up14 #$K\plain\f2\fs28\b CursorOff
\par \plain\f2\fs20\b defined in module \plain\f2\fs20\cf1\b\strike Display\plain\f2\fs20\b Display
\par \plain\f2\fs24\b Syntax
\par \plain\f5\fs20 PROCEDURE CursorOff()
\par \plain\f2\fs19\b\up14 #$K\plain\f2\fs28\b IsCursorOn
\par \plain\f2\fs20\b defined in module \plain\f2\fs20\cf1\b\strike Display\plain\f2\fs20\b Display
\par \plain\f2\fs24\b Syntax
\par \plain\f5\fs20 PROCEDURE IsCursorOn():BOOLEAN
\par \plain\f2\fs19\b\up14 #$K\plain\f2\fs28\b TerminalBell
\par \plain\f2\fs20\b defined in module \plain\f2\fs20\cf1\b\strike Display\plain\f2\fs20\b Display
\par \plain\f2\fs24\b Syntax
\par \plain\f5\fs20 PROCEDURE TerminalBell()
\par \plain\f2\fs19\b\up14 #$K\plain\f2\fs28\b ReadChar
\par \plain\f2\fs20\b defined in module \plain\f2\fs20\cf1\b\strike Display\plain\f2\fs20\b Display
\par \plain\f2\fs24\b Syntax
\par \plain\f5\fs20 PROCEDURE ReadChar(VAR x:CHAR)
\par \plain\f2\fs19\b\up14 #$K\plain\f2\fs28\b ReadLongInt
\par \plain\f2\fs20\b defined in module \plain\f2\fs20\cf1\b\strike Display\plain\f2\fs20\b Display
\par \plain\f2\fs24\b Syntax
\par \plain\f5\fs20 PROCEDURE ReadLongInt(VAR x:LONGINT; 
\par                       maxl:INTEGER; 
\par                       VAR resCode:CHAR)
\par \plain\f2\fs19\b\up14 #$K\plain\f2\fs28\b ReadReal
\par \plain\f2\fs20\b defined in module \plain\f2\fs20\cf1\b\strike Display\plain\f2\fs20\b Display
\par \plain\f2\fs24\b Syntax
\par \plain\f5\fs20 PROCEDURE ReadReal(VAR x:REAL; 
\par                    maxl:INTEGER; 
\par                    VAR resCode:CHAR)
\par \plain\f2\fs19\b\up14 #$K\plain\f2\fs28\b ReadLongReal
\par \plain\f2\fs20\b defined in module \plain\f2\fs20\cf1\b\strike Display\plain\f2\fs20\b Display
\par \plain\f2\fs24\b Syntax
\par \plain\f5\fs20 PROCEDURE ReadLongReal(VAR x:LONGREAL; 
\par                        maxl:INTEGER; 
\par                        VAR resCode:CHAR)
\par \plain\f2\fs19\b\up14 #$K\plain\f2\fs28\b ReadInt
\par \plain\f2\fs20\b defined in module \plain\f2\fs20\cf1\b\strike Display\plain\f2\fs20\b Display
\par \plain\f2\fs24\b Syntax
\par \plain\f5\fs20 PROCEDURE ReadInt(VAR x:INTEGER; 
\par                   maxl:INTEGER; 
\par                   VAR resCode:CHAR)
\par \plain\f2\fs19\b\up14 #$K\plain\f2\fs28\b ReadStr
\par \plain\f2\fs20\b defined in module \plain\f2\fs20\cf1\b\strike Display\plain\f2\fs20\b Display
\par \plain\f2\fs24\b Syntax
\par \plain\f5\fs20 PROCEDURE ReadStr(VAR t:ARRAY OF CHAR; 
\par                   maxl:INTEGER; 
\par                   VAR resCode:CHAR)
\par \plain\f2\fs19\b\up14 #$K\plain\f2\fs28\b EditStr
\par \plain\f2\fs20\b defined in module \plain\f2\fs20\cf1\b\strike Display\plain\f2\fs20\b Display
\par \plain\f2\fs24\b Syntax
\par \plain\f5\fs20 PROCEDURE EditStr(VAR t:ARRAY OF CHAR; 
\par                   maxl:INTEGER; 
\par                   VAR resCode:CHAR)
\par \plain\f2\fs19\b\up14 #$K\plain\f2\fs28\b FlushKeyBuffer
\par \plain\f2\fs20\b defined in module \plain\f2\fs20\cf1\b\strike Display\plain\f2\fs20\b Display
\par \plain\f2\fs24\b Syntax
\par \plain\f5\fs20 PROCEDURE FlushKeyBuffer()
\par \plain\f2\fs19\b\up14 #$K\plain\f2\fs28\b ClrScr
\par \plain\f2\fs20\b defined in module \plain\f2\fs20\cf1\b\strike Display\plain\f2\fs20\b Display
\par \plain\f2\fs24\b Syntax
\par \plain\f5\fs20 PROCEDURE ClrScr()
\par \plain\f2\fs19\b\up14 #$K\plain\f2\fs28\b SetForeColor
\par \plain\f2\fs20\b defined in module \plain\f2\fs20\cf1\b\strike Display\plain\f2\fs20\b Display
\par \plain\f2\fs24\b Syntax
\par \plain\f5\fs20 PROCEDURE SetForeColor(r, g, b:INTEGER)
\par \plain\f2\fs19\b\up14 #$K\plain\f2\fs28\b SetBackColor
\par \plain\f2\fs20\b defined in module \plain\f2\fs20\cf1\b\strike Display\plain\f2\fs20\b Display
\par \plain\f2\fs24\b Syntax
\par \plain\f5\fs20 PROCEDURE SetBackColor(r, g, b:INTEGER)
\par \plain\f2\fs19\b\up14 #$K\plain\f2\fs28\b GetForeColor
\par \plain\f2\fs20\b defined in module \plain\f2\fs20\cf1\b\strike Display\plain\f2\fs20\b Display
\par \plain\f2\fs24\b Syntax
\par \plain\f5\fs20 PROCEDURE GetForeColor(VAR r, g, b:INTEGER)
\par \plain\f2\fs19\b\up14 #$K\plain\f2\fs28\b GetBackColor
\par \plain\f2\fs20\b defined in module \plain\f2\fs20\cf1\b\strike Display\plain\f2\fs20\b Display
\par \plain\f2\fs24\b Syntax
\par \plain\f5\fs20 PROCEDURE GetBackColor(VAR r, g, b:INTEGER)
\par \plain\f2\fs19\b\up14 #$K\plain\f2\fs28\b IsColorSupported
\par \plain\f2\fs20\b defined in module \plain\f2\fs20\cf1\b\strike Display\plain\f2\fs20\b Display
\par \plain\f2\fs24\b Syntax
\par \plain\f5\fs20 PROCEDURE IsColorSupported():BOOLEAN
\par \plain\f2\fs19\b\up14 #$K\plain\f2\fs28\b Module File
\par \plain\f2\fs20 This module provides the functionality needed for working with files and doing file management.
\par All functions for file processing need a so-called \plain\f2\fs20\b Handle\plain\f2\fs20  which is a unique reference which identifies a particular file. To obtain a valid handle a file must be opened with the function \plain\f2\fs20\b Open\plain\f2\fs20 . When all work on a file has been completed the file must be closed with the function \plain\f2\fs20\b Close\plain\f2\fs20 .
\par Functions that refer to a file as a whole rather than its contents require its file name as an argument instead of a handle.
\par Files are regarded as streams of characters without predefined type. Single characters or whole data blocks can be read one after another. In order to control the current reading position within a file the system provides an internal variable for every open file, the so-called "fle pointer", which is also used to define the writing position. Initially the value of the file pointer start with zero.
\par After data has been read or written at the current position, the file pointer is moved on for each read or written character. Additionally, there are functions \plain\f2\fs20\b Seek\plain\f2\fs20  and \plain\f2\fs20\b SeekRel\plain\f2\fs20  which make it possible to set the file pointer to a particular position.
\par \plain\f2\fs24\b Constants
\par \pard\li2880\fi-2880\plain\f2\fs20 MAXPATH\tab \tab \tab maximum length of a full pathname including the filename 
\par MAXFILENAME\tab \tab maximum length of a filename
\par 
\par \pard\plain\f2\fs20\b File Attributes 
\par \pard\li2880\fi-2880\plain\f2\fs20 ATTRREADONLY\tab \tab the file is read-only                     
\par ATTRHIDDEN\tab \tab \tab the file is hidden                        
\par ATTRSYSTEM\tab \tab \tab the file is part of the operating system  
\par ATTRVOLUME\tab \tab \tab maintained for compatibility only         
\par ATTRDIR\tab \tab \tab file entry is really a directory          
\par ATTRARCHIVE\tab \tab \tab file marked for backup                    
\par ATTRNORMAL\tab \tab \tab a plain file with no other attributes set 
\par ATTRTEMP\tab \tab \tab the file is used for temporary storage    
\par ATTRCOMPRESSED\tab \tab the file or directory is compressed       
\par ATTROFFLINE\tab \tab \tab file currently physically unavailable
\par 
\par \pard\plain\f2\fs20\b Constants for <mode> parameter of open command 
\par \pard\li2880\fi-2880\plain\f2\fs20 READONLY\tab \tab \tab 
\par WRITEONLY\tab \tab \tab 
\par READWRITE\tab \tab \tab 
\par \pard\plain\f2\fs20\b Constants for <deny> parameter of open command 
\par \pard\li2880\fi-2880\plain\f2\fs20 DENYALL\tab \tab \tab 
\par DENYWRITE\tab \tab \tab 
\par DENYREAD\tab \tab \tab 
\par DENYNONE\tab \tab \tab 
\par \pard\plain\f2\fs20\b Error Codes 
\par \pard\li2880\fi-2880\plain\f2\fs20 NOERROR\tab \tab \tab 
\par EOFREACHED\tab \tab 
\par INVALIDHANDLE\tab \tab 
\par FILENOTFOUND\tab \tab 
\par ACCESSDENIED\tab \tab 
\par WRITEPROTECTED\tab \tab 
\par SHARINGVIOLATION\tab \tab 
\par \pard\plain\f2\fs24\b Types
\par \plain\f2\fs20\cf1\ul Handle\plain\f2\fs20 File_Handle
\par \plain\f2\fs20\cf1\ul RetCodeT\plain\f2\fs20 File_RetCodeT
\par \plain\f2\fs24\b Procedures
\par \plain\f2\fs20\cf1\strike GetErrorMessage\plain\f2\fs20 File_GetErrorMessage
\par \plain\f2\fs20\cf1\strike Pos\plain\f2\fs20 File_Pos
\par \plain\f2\fs20\cf1\strike Seek\plain\f2\fs20 File_Seek
\par \plain\f2\fs20\cf1\strike SeekRel\plain\f2\fs20 File_SeekRel
\par \plain\f2\fs20\cf1\strike Size\plain\f2\fs20 File_Size
\par \plain\f2\fs20\cf1\strike Open\plain\f2\fs20 File_Open
\par \plain\f2\fs20\cf1\strike ReadChar\plain\f2\fs20 File_ReadChar
\par \plain\f2\fs20\cf1\strike WriteChar\plain\f2\fs20 File_WriteChar
\par \plain\f2\fs20\cf1\strike Truncate\plain\f2\fs20 File_Truncate
\par \plain\f2\fs20\cf1\strike ReadLn\plain\f2\fs20 File_ReadLn
\par \plain\f2\fs20\cf1\strike WriteLn\plain\f2\fs20 File_WriteLn
\par \plain\f2\fs20\cf1\strike ReadBlock\plain\f2\fs20 File_ReadBlock
\par \plain\f2\fs20\cf1\strike WriteBlock\plain\f2\fs20 File_WriteBlock
\par \plain\f2\fs20\cf1\strike AtEnd\plain\f2\fs20 File_AtEnd
\par \plain\f2\fs20\cf1\strike Close\plain\f2\fs20 File_Close
\par \plain\f2\fs20\cf1\strike GetModifyDate\plain\f2\fs20 File_GetModifyDate
\par \plain\f2\fs20\cf1\strike GetCreationDate\plain\f2\fs20 File_GetCreationDate
\par \plain\f2\fs20\cf1\strike GetAccessDate\plain\f2\fs20 File_GetAccessDate
\par \plain\f2\fs20\cf1\strike SetModifyDate\plain\f2\fs20 File_SetModifyDate
\par \plain\f2\fs20\cf1\strike Exist\plain\f2\fs20 File_Exist
\par \plain\f2\fs20\cf1\strike GetAttributes\plain\f2\fs20 File_GetAttributes
\par \plain\f2\fs20\cf1\strike SetAttributes\plain\f2\fs20 File_SetAttributes
\par \plain\f2\fs20\cf1\strike Rename\plain\f2\fs20 File_Rename
\par \plain\f2\fs20\cf1\strike Delete\plain\f2\fs20 File_Delete
\par \plain\f2\fs19\b\up14 #$K\plain\f2\fs28\b GetErrorMessage
\par \plain\f2\fs20\b defined in module \plain\f2\fs20\cf1\b\strike File\plain\f2\fs20\b File
\par \plain\f2\fs24\b Syntax
\par \plain\f5\fs20 PROCEDURE GetErrorMessage(error:\plain\f5\fs20\cf1\ul RetCodeT\plain\f5\fs20 File_RetCodeT; 
\par                           VAR message:ARRAY OF CHAR)
\par \plain\f2\fs19\b\up14 #$K\plain\f2\fs28\b Pos
\par \plain\f2\fs20\b defined in module \plain\f2\fs20\cf1\b\strike File\plain\f2\fs20\b File
\par \plain\f2\fs24\b Syntax
\par \plain\f5\fs20 PROCEDURE Pos(handle:\plain\f5\fs20\cf1\ul Handle\plain\f5\fs20 File_Handle; 
\par               VAR pos:LONGINT; 
\par               VAR res:\plain\f5\fs20\cf1\ul RetCodeT\plain\f5\fs20 File_RetCodeT)
\par \plain\f2\fs19\b\up14 #$K\plain\f2\fs28\b Seek
\par \plain\f2\fs20\b defined in module \plain\f2\fs20\cf1\b\strike File\plain\f2\fs20\b File
\par \plain\f2\fs24\b Syntax
\par \plain\f5\fs20 PROCEDURE Seek(handle:\plain\f5\fs20\cf1\ul Handle\plain\f5\fs20 File_Handle; 
\par                pos:LONGINT; 
\par                VAR res:\plain\f5\fs20\cf1\ul RetCodeT\plain\f5\fs20 File_RetCodeT)
\par \plain\f2\fs19\b\up14 #$K\plain\f2\fs28\b SeekRel
\par \plain\f2\fs20\b defined in module \plain\f2\fs20\cf1\b\strike File\plain\f2\fs20\b File
\par \plain\f2\fs24\b Syntax
\par \plain\f5\fs20 PROCEDURE SeekRel(handle:\plain\f5\fs20\cf1\ul Handle\plain\f5\fs20 File_Handle; 
\par                   pos:LONGINT; 
\par                   VAR res:\plain\f5\fs20\cf1\ul RetCodeT\plain\f5\fs20 File_RetCodeT)
\par \plain\f2\fs19\b\up14 #$K\plain\f2\fs28\b Size
\par \plain\f2\fs20\b defined in module \plain\f2\fs20\cf1\b\strike File\plain\f2\fs20\b File
\par \plain\f2\fs24\b Syntax
\par \plain\f5\fs20 PROCEDURE Size(handle:\plain\f5\fs20\cf1\ul Handle\plain\f5\fs20 File_Handle; 
\par                VAR len:LONGINT; 
\par                VAR res:\plain\f5\fs20\cf1\ul RetCodeT\plain\f5\fs20 File_RetCodeT)
\par \plain\f2\fs19\b\up14 #$K\plain\f2\fs28\b Open
\par \plain\f2\fs20\b defined in module \plain\f2\fs20\cf1\b\strike File\plain\f2\fs20\b File
\par \plain\f2\fs24\b Syntax
\par \plain\f5\fs20 PROCEDURE Open(name:ARRAY OF CHAR; 
\par                create:BOOLEAN; 
\par                deny:INTEGER; 
\par                mode:INTEGER; 
\par                VAR fHandle:\plain\f5\fs20\cf1\ul Handle\plain\f5\fs20 File_Handle; 
\par                VAR res:\plain\f5\fs20\cf1\ul RetCodeT\plain\f5\fs20 File_RetCodeT)
\par \plain\f2\fs19\b\up14 #$K\plain\f2\fs28\b ReadChar
\par \plain\f2\fs20\b defined in module \plain\f2\fs20\cf1\b\strike File\plain\f2\fs20\b File
\par \plain\f2\fs24\b Syntax
\par \plain\f5\fs20 PROCEDURE ReadChar(handle:\plain\f5\fs20\cf1\ul Handle\plain\f5\fs20 File_Handle; 
\par                    VAR x:CHAR; 
\par                    VAR res:\plain\f5\fs20\cf1\ul RetCodeT\plain\f5\fs20 File_RetCodeT)
\par \plain\f2\fs19\b\up14 #$K\plain\f2\fs28\b WriteChar
\par \plain\f2\fs20\b defined in module \plain\f2\fs20\cf1\b\strike File\plain\f2\fs20\b File
\par \plain\f2\fs24\b Syntax
\par \plain\f5\fs20 PROCEDURE WriteChar(handle:\plain\f5\fs20\cf1\ul Handle\plain\f5\fs20 File_Handle; 
\par                     x:CHAR; 
\par                     VAR res:\plain\f5\fs20\cf1\ul RetCodeT\plain\f5\fs20 File_RetCodeT)
\par \plain\f2\fs19\b\up14 #$K\plain\f2\fs28\b Truncate
\par \plain\f2\fs20\b defined in module \plain\f2\fs20\cf1\b\strike File\plain\f2\fs20\b File
\par \plain\f2\fs24\b Syntax
\par \plain\f5\fs20 PROCEDURE Truncate(handle:\plain\f5\fs20\cf1\ul Handle\plain\f5\fs20 File_Handle; 
\par                    VAR res:\plain\f5\fs20\cf1\ul RetCodeT\plain\f5\fs20 File_RetCodeT)
\par \plain\f2\fs19\b\up14 #$K\plain\f2\fs28\b ReadLn
\par \plain\f2\fs20\b defined in module \plain\f2\fs20\cf1\b\strike File\plain\f2\fs20\b File
\par \plain\f2\fs24\b Syntax
\par \plain\f5\fs20 PROCEDURE ReadLn(handle:\plain\f5\fs20\cf1\ul Handle\plain\f5\fs20 File_Handle; 
\par                  VAR t:ARRAY OF CHAR; 
\par                  VAR res:\plain\f5\fs20\cf1\ul RetCodeT\plain\f5\fs20 File_RetCodeT)
\par \plain\f2\fs19\b\up14 #$K\plain\f2\fs28\b WriteLn
\par \plain\f2\fs20\b defined in module \plain\f2\fs20\cf1\b\strike File\plain\f2\fs20\b File
\par \plain\f2\fs24\b Syntax
\par \plain\f5\fs20 PROCEDURE WriteLn(handle:\plain\f5\fs20\cf1\ul Handle\plain\f5\fs20 File_Handle; 
\par                   VAR txt-:ARRAY OF CHAR; 
\par                   VAR res:\plain\f5\fs20\cf1\ul RetCodeT\plain\f5\fs20 File_RetCodeT)
\par \plain\f2\fs19\b\up14 #$K\plain\f2\fs28\b ReadBlock
\par \plain\f2\fs20\b defined in module \plain\f2\fs20\cf1\b\strike File\plain\f2\fs20\b File
\par \plain\f2\fs24\b Syntax
\par \plain\f5\fs20 PROCEDURE ReadBlock(handle:\plain\f5\fs20\cf1\ul Handle\plain\f5\fs20 File_Handle; 
\par                     VAR data:ARRAY OF SYSTEM.BYTE; 
\par                     n:LONGINT; 
\par                     VAR bytesRead:LONGINT; 
\par                     VAR res:\plain\f5\fs20\cf1\ul RetCodeT\plain\f5\fs20 File_RetCodeT)
\par \plain\f2\fs19\b\up14 #$K\plain\f2\fs28\b WriteBlock
\par \plain\f2\fs20\b defined in module \plain\f2\fs20\cf1\b\strike File\plain\f2\fs20\b File
\par \plain\f2\fs24\b Syntax
\par \plain\f5\fs20 PROCEDURE WriteBlock(handle:\plain\f5\fs20\cf1\ul Handle\plain\f5\fs20 File_Handle; 
\par                      VAR data-:ARRAY OF SYSTEM.BYTE; 
\par                      n:LONGINT; 
\par                      VAR res:\plain\f5\fs20\cf1\ul RetCodeT\plain\f5\fs20 File_RetCodeT)
\par \plain\f2\fs19\b\up14 #$K\plain\f2\fs28\b AtEnd
\par \plain\f2\fs20\b defined in module \plain\f2\fs20\cf1\b\strike File\plain\f2\fs20\b File
\par \plain\f2\fs24\b Syntax
\par \plain\f5\fs20 PROCEDURE AtEnd(handle:\plain\f5\fs20\cf1\ul Handle\plain\f5\fs20 File_Handle):BOOLEAN
\par \plain\f2\fs19\b\up14 #$K\plain\f2\fs28\b Close
\par \plain\f2\fs20\b defined in module \plain\f2\fs20\cf1\b\strike File\plain\f2\fs20\b File
\par \plain\f2\fs24\b Syntax
\par \plain\f5\fs20 PROCEDURE Close(handle:\plain\f5\fs20\cf1\ul Handle\plain\f5\fs20 File_Handle)
\par \plain\f2\fs19\b\up14 #$K\plain\f2\fs28\b GetModifyDate
\par \plain\f2\fs20\b defined in module \plain\f2\fs20\cf1\b\strike File\plain\f2\fs20\b File
\par \plain\f2\fs24\b Syntax
\par \plain\f5\fs20 PROCEDURE GetModifyDate(handle:\plain\f5\fs20\cf1\ul Handle\plain\f5\fs20 File_Handle; 
\par                         VAR date:ARRAY OF CHAR; 
\par                         VAR res:\plain\f5\fs20\cf1\ul RetCodeT\plain\f5\fs20 File_RetCodeT)
\par \plain\f2\fs19\b\up14 #$K\plain\f2\fs28\b GetCreationDate
\par \plain\f2\fs20\b defined in module \plain\f2\fs20\cf1\b\strike File\plain\f2\fs20\b File
\par \plain\f2\fs24\b Syntax
\par \plain\f5\fs20 PROCEDURE GetCreationDate(handle:\plain\f5\fs20\cf1\ul Handle\plain\f5\fs20 File_Handle; 
\par                           VAR date:ARRAY OF CHAR; 
\par                           VAR res:\plain\f5\fs20\cf1\ul RetCodeT\plain\f5\fs20 File_RetCodeT)
\par \plain\f2\fs19\b\up14 #$K\plain\f2\fs28\b GetAccessDate
\par \plain\f2\fs20\b defined in module \plain\f2\fs20\cf1\b\strike File\plain\f2\fs20\b File
\par \plain\f2\fs24\b Syntax
\par \plain\f5\fs20 PROCEDURE GetAccessDate(handle:\plain\f5\fs20\cf1\ul Handle\plain\f5\fs20 File_Handle; 
\par                         VAR date:ARRAY OF CHAR; 
\par                         VAR res:\plain\f5\fs20\cf1\ul RetCodeT\plain\f5\fs20 File_RetCodeT)
\par \plain\f2\fs19\b\up14 #$K\plain\f2\fs28\b SetModifyDate
\par \plain\f2\fs20\b defined in module \plain\f2\fs20\cf1\b\strike File\plain\f2\fs20\b File
\par \plain\f2\fs24\b Syntax
\par \plain\f5\fs20 PROCEDURE SetModifyDate(handle:\plain\f5\fs20\cf1\ul Handle\plain\f5\fs20 File_Handle; 
\par                         VAR date-:ARRAY OF CHAR; 
\par                         VAR res:\plain\f5\fs20\cf1\ul RetCodeT\plain\f5\fs20 File_RetCodeT)
\par \plain\f2\fs19\b\up14 #$K\plain\f2\fs28\b Exist
\par \plain\f2\fs20\b defined in module \plain\f2\fs20\cf1\b\strike File\plain\f2\fs20\b File
\par \plain\f2\fs24\b Syntax
\par \plain\f5\fs20 PROCEDURE Exist(name:ARRAY OF CHAR):BOOLEAN
\par \plain\f2\fs24\b Description
\par \plain\f2\fs20 This function checks whether the file given in \plain\f2\fs20\b name\plain\f2\fs20  exists. \plain\f2\fs20\b name\plain\f2\fs20  may also contain wildchards. 
\par \plain\f2\fs19\b\up14 #$K\plain\f2\fs28\b GetAttributes
\par \plain\f2\fs20\b defined in module \plain\f2\fs20\cf1\b\strike File\plain\f2\fs20\b File
\par \plain\f2\fs24\b Syntax
\par \plain\f5\fs20 PROCEDURE GetAttributes(name:ARRAY OF CHAR; 
\par                         VAR attr:SET; 
\par                         VAR res:\plain\f5\fs20\cf1\ul RetCodeT\plain\f5\fs20 File_RetCodeT)
\par \plain\f2\fs19\b\up14 #$K\plain\f2\fs28\b SetAttributes
\par \plain\f2\fs20\b defined in module \plain\f2\fs20\cf1\b\strike File\plain\f2\fs20\b File
\par \plain\f2\fs24\b Syntax
\par \plain\f5\fs20 PROCEDURE SetAttributes(name:ARRAY OF CHAR; 
\par                         attr:SET; 
\par                         VAR res:\plain\f5\fs20\cf1\ul RetCodeT\plain\f5\fs20 File_RetCodeT)
\par \plain\f2\fs19\b\up14 #$K\plain\f2\fs28\b Rename
\par \plain\f2\fs20\b defined in module \plain\f2\fs20\cf1\b\strike File\plain\f2\fs20\b File
\par \plain\f2\fs24\b Syntax
\par \plain\f5\fs20 PROCEDURE Rename(oldName, newName:ARRAY OF CHAR; 
\par                  VAR res:\plain\f5\fs20\cf1\ul RetCodeT\plain\f5\fs20 File_RetCodeT)
\par \plain\f2\fs19\b\up14 #$K\plain\f2\fs28\b Delete
\par \plain\f2\fs20\b defined in module \plain\f2\fs20\cf1\b\strike File\plain\f2\fs20\b File
\par \plain\f2\fs24\b Syntax
\par \plain\f5\fs20 PROCEDURE Delete(name:ARRAY OF CHAR; 
\par                  VAR res:\plain\f5\fs20\cf1\ul RetCodeT\plain\f5\fs20 File_RetCodeT)
\par \plain\f2\fs13\up10 #$K\plain\f2\fs20\b Handle\plain\f2\fs20 
\par \plain\f5\fs20 Handle*=WD.HANDLE;
\par \plain\f2\fs13\up10 #$K\plain\f2\fs20\b RetCodeT\plain\f2\fs20 
\par \plain\f5\fs20 RetCodeT*=INTEGER;
\par \plain\f2\fs19\b\up14 #$K\plain\f2\fs28\b Module Float
\par \plain\f2\fs24\b Constants
\par \pard\li2880\fi-2880\plain\f2\fs20 ISREAL\tab \tab \tab 
\par ISLONGREAL\tab \tab \tab 
\par ISOUTOFRANGE\tab \tab 
\par STRINGEMPTY\tab \tab 
\par STRINGILLEGAL\tab \tab 
\par UNSUPPORTED\tab \tab 
\par NAN\tab \tab \tab \tab 
\par NORMAL\tab \tab \tab 
\par POSINF\tab \tab \tab 
\par ZERO\tab \tab \tab \tab 
\par DENORMAL\tab \tab \tab 
\par IMPOSSIBLE\tab \tab \tab 
\par NEGINF\tab \tab \tab 
\par Pi\tab \tab \tab \tab 
\par e\tab \tab \tab \tab 
\par \pard\plain\f2\fs24\b Procedures
\par \plain\f2\fs20\cf1\strike Log2\plain\f2\fs20 Float_Log2
\par \plain\f2\fs20\cf1\strike Log2L\plain\f2\fs20 Float_Log2L
\par \plain\f2\fs20\cf1\strike Ln\plain\f2\fs20 Float_Ln
\par \plain\f2\fs20\cf1\strike LnL\plain\f2\fs20 Float_LnL
\par \plain\f2\fs20\cf1\strike Log10\plain\f2\fs20 Float_Log10
\par \plain\f2\fs20\cf1\strike Log10L\plain\f2\fs20 Float_Log10L
\par \plain\f2\fs20\cf1\strike Exp\plain\f2\fs20 Float_Exp
\par \plain\f2\fs20\cf1\strike ExpL\plain\f2\fs20 Float_ExpL
\par \plain\f2\fs20\cf1\strike Sqrt\plain\f2\fs20 Float_Sqrt
\par \plain\f2\fs20\cf1\strike SqrtL\plain\f2\fs20 Float_SqrtL
\par \plain\f2\fs20\cf1\strike Cos\plain\f2\fs20 Float_Cos
\par \plain\f2\fs20\cf1\strike CosL\plain\f2\fs20 Float_CosL
\par \plain\f2\fs20\cf1\strike Sin\plain\f2\fs20 Float_Sin
\par \plain\f2\fs20\cf1\strike SinL\plain\f2\fs20 Float_SinL
\par \plain\f2\fs20\cf1\strike Tan\plain\f2\fs20 Float_Tan
\par \plain\f2\fs20\cf1\strike TanL\plain\f2\fs20 Float_TanL
\par \plain\f2\fs20\cf1\strike ArcTan\plain\f2\fs20 Float_ArcTan
\par \plain\f2\fs20\cf1\strike ArcTanL\plain\f2\fs20 Float_ArcTanL
\par \plain\f2\fs20\cf1\strike ArcSin\plain\f2\fs20 Float_ArcSin
\par \plain\f2\fs20\cf1\strike ArcSinL\plain\f2\fs20 Float_ArcSinL
\par \plain\f2\fs20\cf1\strike KindOfNumber\plain\f2\fs20 Float_KindOfNumber
\par \plain\f2\fs20\cf1\strike KindOfNumberL\plain\f2\fs20 Float_KindOfNumberL
\par \plain\f2\fs20\cf1\strike ValResult\plain\f2\fs20 Float_ValResult
\par \plain\f2\fs20\cf1\strike Val\plain\f2\fs20 Float_Val
\par \plain\f2\fs20\cf1\strike StrF\plain\f2\fs20 Float_StrF
\par \plain\f2\fs20\cf1\strike Str\plain\f2\fs20 Float_Str
\par \plain\f2\fs20\cf1\strike StrL\plain\f2\fs20 Float_StrL
\par \plain\f2\fs19\b\up14 #$K\plain\f2\fs28\b Log2
\par \plain\f2\fs20\b defined in module \plain\f2\fs20\cf1\b\strike Float\plain\f2\fs20\b Float
\par \plain\f2\fs24\b Syntax
\par \plain\f5\fs20 PROCEDURE Log2(x:REAL):REAL
\par \plain\f2\fs24\b Description
\par \plain\f2\fs20 The return value is the logarithm base 2 of \plain\f2\fs20\b x\plain\f2\fs20 . 
\par \plain\f2\fs19\b\up14 #$K\plain\f2\fs28\b Log2L
\par \plain\f2\fs20\b defined in module \plain\f2\fs20\cf1\b\strike Float\plain\f2\fs20\b Float
\par \plain\f2\fs24\b Syntax
\par \plain\f5\fs20 PROCEDURE Log2L(x:LONGREAL):LONGREAL
\par \plain\f2\fs24\b Description
\par \plain\f2\fs20 The return value is the logarithm base 2 of \plain\f2\fs20\b x\plain\f2\fs20 . 
\par \plain\f2\fs19\b\up14 #$K\plain\f2\fs28\b Ln
\par \plain\f2\fs20\b defined in module \plain\f2\fs20\cf1\b\strike Float\plain\f2\fs20\b Float
\par \plain\f2\fs24\b Syntax
\par \plain\f5\fs20 PROCEDURE Ln(x:REAL):REAL
\par \plain\f2\fs24\b Description
\par \plain\f2\fs20 The return value is the natural logarithm (base e) of \plain\f2\fs20\b x\plain\f2\fs20 . 
\par \plain\f2\fs19\b\up14 #$K\plain\f2\fs28\b LnL
\par \plain\f2\fs20\b defined in module \plain\f2\fs20\cf1\b\strike Float\plain\f2\fs20\b Float
\par \plain\f2\fs24\b Syntax
\par \plain\f5\fs20 PROCEDURE LnL(x:LONGREAL):LONGREAL
\par \plain\f2\fs24\b Description
\par \plain\f2\fs20 The return value is the natural logarithm (base e) of \plain\f2\fs20\b x\plain\f2\fs20 . 
\par \plain\f2\fs19\b\up14 #$K\plain\f2\fs28\b Log10
\par \plain\f2\fs20\b defined in module \plain\f2\fs20\cf1\b\strike Float\plain\f2\fs20\b Float
\par \plain\f2\fs24\b Syntax
\par \plain\f5\fs20 PROCEDURE Log10(x:REAL):REAL
\par \plain\f2\fs24\b Description
\par \plain\f2\fs20 The return value is the logarithm base 10 of \plain\f2\fs20\b x\plain\f2\fs20 . 
\par \plain\f2\fs19\b\up14 #$K\plain\f2\fs28\b Log10L
\par \plain\f2\fs20\b defined in module \plain\f2\fs20\cf1\b\strike Float\plain\f2\fs20\b Float
\par \plain\f2\fs24\b Syntax
\par \plain\f5\fs20 PROCEDURE Log10L(x:LONGREAL):LONGREAL
\par \plain\f2\fs24\b Description
\par \plain\f2\fs20 The return value is the logarithm base 10 of \plain\f2\fs20\b x\plain\f2\fs20 . 
\par \plain\f2\fs19\b\up14 #$K\plain\f2\fs28\b Exp
\par \plain\f2\fs20\b defined in module \plain\f2\fs20\cf1\b\strike Float\plain\f2\fs20\b Float
\par \plain\f2\fs24\b Syntax
\par \plain\f5\fs20 PROCEDURE Exp(x, y:REAL):REAL
\par \plain\f2\fs24\b Description
\par \plain\f2\fs20 The return value is \plain\f2\fs20\b x\plain\f2\fs20  to the power of \plain\f2\fs20\b y\plain\f2\fs20 . 
\par \plain\f2\fs19\b\up14 #$K\plain\f2\fs28\b ExpL
\par \plain\f2\fs20\b defined in module \plain\f2\fs20\cf1\b\strike Float\plain\f2\fs20\b Float
\par \plain\f2\fs24\b Syntax
\par \plain\f5\fs20 PROCEDURE ExpL(x, y:LONGREAL):LONGREAL
\par \plain\f2\fs24\b Description
\par \plain\f2\fs20 The return value is \plain\f2\fs20\b x\plain\f2\fs20  to the power of \plain\f2\fs20\b y\plain\f2\fs20 . 
\par \plain\f2\fs19\b\up14 #$K\plain\f2\fs28\b Sqrt
\par \plain\f2\fs20\b defined in module \plain\f2\fs20\cf1\b\strike Float\plain\f2\fs20\b Float
\par \plain\f2\fs24\b Syntax
\par \plain\f5\fs20 PROCEDURE Sqrt(x:REAL):REAL
\par \plain\f2\fs24\b Description
\par \plain\f2\fs20 The return value is the square root of \plain\f2\fs20\b x\plain\f2\fs20 . 
\par \plain\f2\fs19\b\up14 #$K\plain\f2\fs28\b SqrtL
\par \plain\f2\fs20\b defined in module \plain\f2\fs20\cf1\b\strike Float\plain\f2\fs20\b Float
\par \plain\f2\fs24\b Syntax
\par \plain\f5\fs20 PROCEDURE SqrtL(x:LONGREAL):LONGREAL
\par \plain\f2\fs24\b Description
\par \plain\f2\fs20 The return value is the square root of \plain\f2\fs20\b x\plain\f2\fs20 . 
\par \plain\f2\fs19\b\up14 #$K\plain\f2\fs28\b Cos
\par \plain\f2\fs20\b defined in module \plain\f2\fs20\cf1\b\strike Float\plain\f2\fs20\b Float
\par \plain\f2\fs24\b Syntax
\par \plain\f5\fs20 PROCEDURE Cos(x:REAL):REAL
\par \plain\f2\fs24\b Description
\par \plain\f2\fs20 The return value is the cosine of \plain\f2\fs20\b x\plain\f2\fs20  in radians. 
\par \plain\f2\fs19\b\up14 #$K\plain\f2\fs28\b CosL
\par \plain\f2\fs20\b defined in module \plain\f2\fs20\cf1\b\strike Float\plain\f2\fs20\b Float
\par \plain\f2\fs24\b Syntax
\par \plain\f5\fs20 PROCEDURE CosL(x:LONGREAL):LONGREAL
\par \plain\f2\fs24\b Description
\par \plain\f2\fs20 The return value is the cosine of \plain\f2\fs20\b x\plain\f2\fs20  in radians. 
\par \plain\f2\fs19\b\up14 #$K\plain\f2\fs28\b Sin
\par \plain\f2\fs20\b defined in module \plain\f2\fs20\cf1\b\strike Float\plain\f2\fs20\b Float
\par \plain\f2\fs24\b Syntax
\par \plain\f5\fs20 PROCEDURE Sin(x:REAL):REAL
\par \plain\f2\fs24\b Description
\par \plain\f2\fs20 The return value is the sine of \plain\f2\fs20\b x\plain\f2\fs20  in radians. 
\par \plain\f2\fs19\b\up14 #$K\plain\f2\fs28\b SinL
\par \plain\f2\fs20\b defined in module \plain\f2\fs20\cf1\b\strike Float\plain\f2\fs20\b Float
\par \plain\f2\fs24\b Syntax
\par \plain\f5\fs20 PROCEDURE SinL(x:LONGREAL):LONGREAL
\par \plain\f2\fs24\b Description
\par \plain\f2\fs20 The return value is the sine of \plain\f2\fs20\b x\plain\f2\fs20  in radians. 
\par \plain\f2\fs19\b\up14 #$K\plain\f2\fs28\b Tan
\par \plain\f2\fs20\b defined in module \plain\f2\fs20\cf1\b\strike Float\plain\f2\fs20\b Float
\par \plain\f2\fs24\b Syntax
\par \plain\f5\fs20 PROCEDURE Tan(x:REAL):REAL
\par \plain\f2\fs24\b Description
\par \plain\f2\fs20 The return value is the tangent of \plain\f2\fs20\b x\plain\f2\fs20  in radians. 
\par \plain\f2\fs19\b\up14 #$K\plain\f2\fs28\b TanL
\par \plain\f2\fs20\b defined in module \plain\f2\fs20\cf1\b\strike Float\plain\f2\fs20\b Float
\par \plain\f2\fs24\b Syntax
\par \plain\f5\fs20 PROCEDURE TanL(x:LONGREAL):LONGREAL
\par \plain\f2\fs24\b Description
\par \plain\f2\fs20 The return value is the tangent of \plain\f2\fs20\b x\plain\f2\fs20  in radians. 
\par \plain\f2\fs19\b\up14 #$K\plain\f2\fs28\b ArcTan
\par \plain\f2\fs20\b defined in module \plain\f2\fs20\cf1\b\strike Float\plain\f2\fs20\b Float
\par \plain\f2\fs24\b Syntax
\par \plain\f5\fs20 PROCEDURE ArcTan(x:REAL):REAL
\par \plain\f2\fs24\b Description
\par \plain\f2\fs20 The return value is the arc tangent of \plain\f2\fs20\b x\plain\f2\fs20  in radians. 
\par \plain\f2\fs19\b\up14 #$K\plain\f2\fs28\b ArcTanL
\par \plain\f2\fs20\b defined in module \plain\f2\fs20\cf1\b\strike Float\plain\f2\fs20\b Float
\par \plain\f2\fs24\b Syntax
\par \plain\f5\fs20 PROCEDURE ArcTanL(x:LONGREAL):LONGREAL
\par \plain\f2\fs24\b Description
\par \plain\f2\fs20 The return value is the arc tangent of \plain\f2\fs20\b x\plain\f2\fs20  in radians. 
\par \plain\f2\fs19\b\up14 #$K\plain\f2\fs28\b ArcSin
\par \plain\f2\fs20\b defined in module \plain\f2\fs20\cf1\b\strike Float\plain\f2\fs20\b Float
\par \plain\f2\fs24\b Syntax
\par \plain\f5\fs20 PROCEDURE ArcSin(x:REAL):REAL
\par \plain\f2\fs24\b Description
\par \plain\f2\fs20 The return value is the arc sine of \plain\f2\fs20\b x\plain\f2\fs20  in radians. 
\par \plain\f2\fs19\b\up14 #$K\plain\f2\fs28\b ArcSinL
\par \plain\f2\fs20\b defined in module \plain\f2\fs20\cf1\b\strike Float\plain\f2\fs20\b Float
\par \plain\f2\fs24\b Syntax
\par \plain\f5\fs20 PROCEDURE ArcSinL(x:LONGREAL):LONGREAL
\par \plain\f2\fs24\b Description
\par \plain\f2\fs20 The return value is the arc sine of \plain\f2\fs20\b x\plain\f2\fs20  in radians. 
\par \plain\f2\fs19\b\up14 #$K\plain\f2\fs28\b KindOfNumber
\par \plain\f2\fs20\b defined in module \plain\f2\fs20\cf1\b\strike Float\plain\f2\fs20\b Float
\par \plain\f2\fs24\b Syntax
\par \plain\f5\fs20 PROCEDURE KindOfNumber(x:REAL):INTEGER
\par \plain\f2\fs24\b Description
\par \plain\f2\fs20 Returns one of the following values which characterizes the contents of \plain\f2\fs20\b x\plain\f2\fs20 :
\par NAN          not a number
\par NORMAL       ordinary number
\par POSINF       positive infinity
\par ZERO         zero
\par DENORMAL     number stored with reduced precision
\par NEGINF       negative infinity
\par \plain\f2\fs19\b\up14 #$K\plain\f2\fs28\b KindOfNumberL
\par \plain\f2\fs20\b defined in module \plain\f2\fs20\cf1\b\strike Float\plain\f2\fs20\b Float
\par \plain\f2\fs24\b Syntax
\par \plain\f5\fs20 PROCEDURE KindOfNumberL(x:LONGREAL):INTEGER
\par \plain\f2\fs24\b Description
\par \plain\f2\fs20 Returns one of the following values which characterizes the contents of \plain\f2\fs20\b x\plain\f2\fs20 :
\par UNSUPPORTED NAN          not a number NORMAL       ordinary number POSINF       positive infinity ZERO         zero DENORMAL     number stored with reduced precision NEGINF       negative infinity
\par \plain\f2\fs19\b\up14 #$K\plain\f2\fs28\b ValResult
\par \plain\f2\fs20\b defined in module \plain\f2\fs20\cf1\b\strike Float\plain\f2\fs20\b Float
\par \plain\f2\fs24\b Syntax
\par \plain\f5\fs20 PROCEDURE ValResult(t:ARRAY OF CHAR):INTEGER
\par \plain\f2\fs19\b\up14 #$K\plain\f2\fs28\b Val
\par \plain\f2\fs20\b defined in module \plain\f2\fs20\cf1\b\strike Float\plain\f2\fs20\b Float
\par \plain\f2\fs24\b Syntax
\par \plain\f5\fs20 PROCEDURE Val(t:ARRAY OF CHAR):LONGREAL
\par \plain\f2\fs19\b\up14 #$K\plain\f2\fs28\b StrF
\par \plain\f2\fs20\b defined in module \plain\f2\fs20\cf1\b\strike Float\plain\f2\fs20\b Float
\par \plain\f2\fs24\b Syntax
\par \plain\f5\fs20 PROCEDURE StrF(x:LONGREAL; 
\par                n1, n2:INTEGER; 
\par                VAR t:ARRAY OF CHAR)
\par \plain\f2\fs19\b\up14 #$K\plain\f2\fs28\b Str
\par \plain\f2\fs20\b defined in module \plain\f2\fs20\cf1\b\strike Float\plain\f2\fs20\b Float
\par \plain\f2\fs24\b Syntax
\par \plain\f5\fs20 PROCEDURE Str(x:LONGREAL; 
\par               VAR t:ARRAY OF CHAR)
\par \plain\f2\fs19\b\up14 #$K\plain\f2\fs28\b StrL
\par \plain\f2\fs20\b defined in module \plain\f2\fs20\cf1\b\strike Float\plain\f2\fs20\b Float
\par \plain\f2\fs24\b Syntax
\par \plain\f5\fs20 PROCEDURE StrL(x:LONGREAL; 
\par                n:INTEGER; 
\par                VAR t:ARRAY OF CHAR)
\par \plain\f2\fs19\b\up14 #$K\plain\f2\fs28\b Module In
\par \plain\f2\fs20 This module provides simple, data-stream-oriented input. The source of input can be from the keyboard or from a file. The input from a file is especially useful for the program development as input test data can be prepared and saved in a file. This file is then selected as input source after each program start to run a complete test.
\par \plain\f2\fs24\b Variables
\par \plain\f2\fs20\cf1\ul Done\plain\f2\fs20 In_Done
\par \plain\f2\fs20\cf1\ul echo\plain\f2\fs20 In_echo
\par \plain\f2\fs24\b Procedures
\par \plain\f2\fs20\cf1\strike Echo\plain\f2\fs20 In_Echo
\par \plain\f2\fs20\cf1\strike Prompt\plain\f2\fs20 In_Prompt
\par \plain\f2\fs20\cf1\strike Open\plain\f2\fs20 In_Open
\par \plain\f2\fs20\cf1\strike Char\plain\f2\fs20 In_Char
\par \plain\f2\fs20\cf1\strike Int\plain\f2\fs20 In_Int
\par \plain\f2\fs20\cf1\strike LongInt\plain\f2\fs20 In_LongInt
\par \plain\f2\fs20\cf1\strike Real\plain\f2\fs20 In_Real
\par \plain\f2\fs20\cf1\strike LongReal\plain\f2\fs20 In_LongReal
\par \plain\f2\fs20\cf1\strike Name\plain\f2\fs20 In_Name
\par \plain\f2\fs20\cf1\strike String\plain\f2\fs20 In_String
\par \plain\f2\fs19\b\up14 #$K\plain\f2\fs28\b Echo
\par \plain\f2\fs20\b defined in module \plain\f2\fs20\cf1\b\strike In\plain\f2\fs20\b In
\par \plain\f2\fs24\b Syntax
\par \plain\f5\fs20 PROCEDURE Echo(x:BOOLEAN)
\par \plain\f2\fs19\b\up14 #$K\plain\f2\fs28\b Prompt
\par \plain\f2\fs20\b defined in module \plain\f2\fs20\cf1\b\strike In\plain\f2\fs20\b In
\par \plain\f2\fs24\b Syntax
\par \plain\f5\fs20 PROCEDURE Prompt(txt:ARRAY OF CHAR)
\par \plain\f2\fs19\b\up14 #$K\plain\f2\fs28\b Open
\par \plain\f2\fs20\b defined in module \plain\f2\fs20\cf1\b\strike In\plain\f2\fs20\b In
\par \plain\f2\fs24\b Syntax
\par \plain\f5\fs20 PROCEDURE Open()
\par \plain\f2\fs19\b\up14 #$K\plain\f2\fs28\b Char
\par \plain\f2\fs20\b defined in module \plain\f2\fs20\cf1\b\strike In\plain\f2\fs20\b In
\par \plain\f2\fs24\b Syntax
\par \plain\f5\fs20 PROCEDURE Char(VAR ch:CHAR)
\par \plain\f2\fs19\b\up14 #$K\plain\f2\fs28\b Int
\par \plain\f2\fs20\b defined in module \plain\f2\fs20\cf1\b\strike In\plain\f2\fs20\b In
\par \plain\f2\fs24\b Syntax
\par \plain\f5\fs20 PROCEDURE Int(VAR i:INTEGER)
\par \plain\f2\fs19\b\up14 #$K\plain\f2\fs28\b LongInt
\par \plain\f2\fs20\b defined in module \plain\f2\fs20\cf1\b\strike In\plain\f2\fs20\b In
\par \plain\f2\fs24\b Syntax
\par \plain\f5\fs20 PROCEDURE LongInt(VAR l:LONGINT)
\par \plain\f2\fs19\b\up14 #$K\plain\f2\fs28\b Real
\par \plain\f2\fs20\b defined in module \plain\f2\fs20\cf1\b\strike In\plain\f2\fs20\b In
\par \plain\f2\fs24\b Syntax
\par \plain\f5\fs20 PROCEDURE Real(VAR x:REAL)
\par \plain\f2\fs19\b\up14 #$K\plain\f2\fs28\b LongReal
\par \plain\f2\fs20\b defined in module \plain\f2\fs20\cf1\b\strike In\plain\f2\fs20\b In
\par \plain\f2\fs24\b Syntax
\par \plain\f5\fs20 PROCEDURE LongReal(VAR x:LONGREAL)
\par \plain\f2\fs19\b\up14 #$K\plain\f2\fs28\b Name
\par \plain\f2\fs20\b defined in module \plain\f2\fs20\cf1\b\strike In\plain\f2\fs20\b In
\par \plain\f2\fs24\b Syntax
\par \plain\f5\fs20 PROCEDURE Name(VAR nme:ARRAY OF CHAR)
\par \plain\f2\fs19\b\up14 #$K\plain\f2\fs28\b String
\par \plain\f2\fs20\b defined in module \plain\f2\fs20\cf1\b\strike In\plain\f2\fs20\b In
\par \plain\f2\fs24\b Syntax
\par \plain\f5\fs20 PROCEDURE String(VAR str:ARRAY OF CHAR)
\par \plain\f2\fs13\up10 #$K\plain\f2\fs20\b Done\plain\f2\fs20 
\par \plain\f5\fs20 Done*:BOOLEAN;
\par \plain\f2\fs13\up10 #$K\plain\f2\fs20\b echo\plain\f2\fs20 
\par \plain\f5\fs20 echo-:BOOLEAN;
\par \plain\f2\fs19\b\up14 #$K\plain\f2\fs28\b Module OOBase
\par \plain\f2\fs24\b Constants
\par \pard\li2880\fi-2880\plain\f2\fs20 TYP_ARRAY\tab \tab \tab 
\par TYP_DYNARRAY\tab \tab 
\par TYP_RECORD\tab \tab \tab 
\par TYP_ENDRECORD\tab \tab 
\par TYP_UNDEF\tab \tab \tab 
\par TYP_BYTE\tab \tab \tab 
\par TYP_BOOL\tab \tab \tab 
\par TYP_CHAR\tab \tab \tab 
\par TYP_SHORTINT\tab \tab 
\par TYP_INT\tab \tab \tab 
\par TYP_LONGINT\tab \tab \tab 
\par TYP_REAL\tab \tab \tab 
\par TYP_LONGREAL\tab \tab 
\par TYP_SET\tab \tab \tab 
\par TYP_STRING\tab \tab \tab 
\par TYP_NIL\tab \tab \tab 
\par TYP_NOTYP\tab \tab \tab 
\par TYP_POINTER\tab \tab \tab 
\par TYP_HDPOINTER\tab \tab 
\par TYP_PROCTYP\tab \tab 
\par \pard\plain\f2\fs24\b Types
\par \plain\f2\fs20\cf1\ul Object\plain\f2\fs20 OOBase_Object
\par \plain\f2\fs24\b Classes / Record Types
\par \plain\f2\fs20\cf1\strike ObjectT\plain\f2\fs20 OOBase_ObjectT
\par \plain\f2\fs20\cf1\strike ObjMetaToolT\plain\f2\fs20 OOBase_ObjMetaToolT
\par \plain\f2\fs20\cf1\strike ObjMetaToolMarkerT\plain\f2\fs20 OOBase_ObjMetaToolMarkerT
\par \plain\f2\fs24\b Procedures
\par \plain\f2\fs20\cf1\strike Clone\plain\f2\fs20 OOBase_Clone
\par \plain\f2\fs20\cf1\strike ObjToName\plain\f2\fs20 OOBase_ObjToName
\par \plain\f2\fs20\cf1\strike NameToObj\plain\f2\fs20 OOBase_NameToObj
\par \plain\f2\fs20\cf1\strike TypeHasOffset\plain\f2\fs20 OOBase_TypeHasOffset
\par \plain\f2\fs20\cf1\strike TypeToName\plain\f2\fs20 OOBase_TypeToName
\par \plain\f2\fs19\b\up14 #$K\plain\f2\fs28\b Clone
\par \plain\f2\fs20\b defined in module \plain\f2\fs20\cf1\b\strike OOBase\plain\f2\fs20\b OOBase
\par \plain\f2\fs24\b Syntax
\par \plain\f5\fs20 PROCEDURE Clone(obj:\plain\f5\fs20\cf1\ul Object\plain\f5\fs20 OOBase_Object):\plain\f5\fs20\cf1\ul Object\plain\f5\fs20 OOBase_Object
\par \plain\f2\fs24\b Description
\par \plain\f2\fs20 The object passed in obj is cloned. This means that a new object of the same class is created, which has the same state as the original object.
\par The same state has to be taken literal: if the original object contains any pointers to other objects, which should by design be private, the new object will contain pointers to the same objects and not possess new private copies of those.
\par The return value is either a pointer to the cloned object or NIL if the function failed. 
\par \plain\f2\fs19\b\up14 #$K\plain\f2\fs28\b ObjToName
\par \plain\f2\fs20\b defined in module \plain\f2\fs20\cf1\b\strike OOBase\plain\f2\fs20\b OOBase
\par \plain\f2\fs24\b Syntax
\par \plain\f5\fs20 PROCEDURE ObjToName(p:\plain\f5\fs20\cf1\ul Object\plain\f5\fs20 OOBase_Object; 
\par                     VAR codeName, name:ARRAY OF CHAR)
\par \plain\f2\fs24\b Parameters
\par \pard\li2880\fi-2880\plain\f2\fs20 p\tab \tab \tab \tab pointer to the object whose symbolic name should be determined 
\par codeName\tab \tab \tab returns the full pathname of the .EXE or .DLL file containing the code of the class implementation 
\par name\tab \tab \tab \tab returns the qualified class name of the object in the form moduleName.typeName 
\par \pard\plain\f2\fs24\b Description
\par \plain\f2\fs20 The symbolic name of an objects qualified class name and the name of its code module are returned. 
\par \plain\f2\fs19\b\up14 #$K\plain\f2\fs28\b NameToObj
\par \plain\f2\fs20\b defined in module \plain\f2\fs20\cf1\b\strike OOBase\plain\f2\fs20\b OOBase
\par \plain\f2\fs24\b Syntax
\par \plain\f5\fs20 PROCEDURE NameToObj(VAR codeName-, name-:ARRAY OF CHAR; 
\par                     VAR p:\plain\f5\fs20\cf1\ul Object\plain\f5\fs20 OOBase_Object)
\par \plain\f2\fs24\b Parameters
\par \pard\li2880\fi-2880\plain\f2\fs20 codeName\tab \tab \tab the full pathname of the .EXE or .DLL file containig the implementation of the desired class 
\par name\tab \tab \tab \tab the qualified class name in the form moduleName.className 
\par p\tab \tab \tab \tab returns a pointer to the object created or NIL if the call failed 
\par \pard\plain\f2\fs24\b Description
\par \plain\f2\fs20 A new object is created according to a given class and code module name.
\par The code module name has to be given because the class might be implemented in a DLL which has not yet been loaded and whose name can not be derived from the Oberon class name.
\par It is possible to implement different modules with the same name in different DLLs. In this case it is not adviseable to use both DLLs in the same program. 
\par \plain\f2\fs19\b\up14 #$K\plain\f2\fs28\b TypeHasOffset
\par \plain\f2\fs20\b defined in module \plain\f2\fs20\cf1\b\strike OOBase\plain\f2\fs20\b OOBase
\par \plain\f2\fs24\b Syntax
\par \plain\f5\fs20 PROCEDURE TypeHasOffset(typeCode:INTEGER):BOOLEAN
\par \plain\f2\fs24\b Description
\par \plain\f2\fs20 return TRUE if the given type is accompanied by an offset in the RTTI 
\par \plain\f2\fs19\b\up14 #$K\plain\f2\fs28\b TypeToName
\par \plain\f2\fs20\b defined in module \plain\f2\fs20\cf1\b\strike OOBase\plain\f2\fs20\b OOBase
\par \plain\f2\fs24\b Syntax
\par \plain\f5\fs20 PROCEDURE TypeToName(typeCode:INTEGER; 
\par                      VAR txt:ARRAY OF CHAR)
\par \plain\f2\fs24\b Description
\par \plain\f2\fs20 returns the symbolic name of the type given in typeCode 
\par \plain\f2\fs13\up10 #$K\plain\f2\fs20\b Object\plain\f2\fs20 
\par \plain\f5\fs20 Object*=POINTER TO \plain\f5\fs20\cf1\strike ObjectT\plain\f5\fs20 OOBase_ObjectT;
\par \plain\f2\fs19\b\up14 #$K\plain\f2\fs28\b ObjectT
\par \plain\f2\fs20\b defined in module \plain\f2\fs20\cf1\b\strike OOBase\plain\f2\fs20\b OOBase
\par \plain\f2\fs24\b Description
\par \plain\f2\fs20 This class should be the base of any class hierarchy. This class only contains the empty method Init.
\par \plain\f2\fs24\b Syntax
\par \plain\f5\fs20 ObjectT=RECORD 
\par END;
\par \plain\f2\fs24\b Methods
\par \plain\f2\fs20\cf1\strike Init\plain\f2\fs20 OOBase_ObjectT_Init
\par \plain\f2\fs20\cf1\strike GetFieldType\plain\f2\fs20 OOBase_ObjectT_GetFieldType
\par \plain\f2\fs20\cf1\strike PutIntField\plain\f2\fs20 OOBase_ObjectT_PutIntField
\par \plain\f2\fs20\cf1\strike GetIntField\plain\f2\fs20 OOBase_ObjectT_GetIntField
\par \plain\f2\fs20\cf1\strike PutLongIntField\plain\f2\fs20 OOBase_ObjectT_PutLongIntField
\par \plain\f2\fs20\cf1\strike GetLongIntField\plain\f2\fs20 OOBase_ObjectT_GetLongIntField
\par \plain\f2\fs20\cf1\strike PutShortIntField\plain\f2\fs20 OOBase_ObjectT_PutShortIntField
\par \plain\f2\fs20\cf1\strike GetShortIntField\plain\f2\fs20 OOBase_ObjectT_GetShortIntField
\par \plain\f2\fs20\cf1\strike PutCharField\plain\f2\fs20 OOBase_ObjectT_PutCharField
\par \plain\f2\fs20\cf1\strike GetCharField\plain\f2\fs20 OOBase_ObjectT_GetCharField
\par \plain\f2\fs20\cf1\strike PutBoolField\plain\f2\fs20 OOBase_ObjectT_PutBoolField
\par \plain\f2\fs20\cf1\strike GetBoolField\plain\f2\fs20 OOBase_ObjectT_GetBoolField
\par \plain\f2\fs20\cf1\strike PutSetField\plain\f2\fs20 OOBase_ObjectT_PutSetField
\par \plain\f2\fs20\cf1\strike GetSetField\plain\f2\fs20 OOBase_ObjectT_GetSetField
\par \plain\f2\fs20\cf1\strike PutRealField\plain\f2\fs20 OOBase_ObjectT_PutRealField
\par \plain\f2\fs20\cf1\strike GetRealField\plain\f2\fs20 OOBase_ObjectT_GetRealField
\par \plain\f2\fs20\cf1\strike PutLongRealField\plain\f2\fs20 OOBase_ObjectT_PutLongRealField
\par \plain\f2\fs20\cf1\strike GetLongRealField\plain\f2\fs20 OOBase_ObjectT_GetLongRealField
\par \plain\f2\fs20\cf1\strike PutStrField\plain\f2\fs20 OOBase_ObjectT_PutStrField
\par \plain\f2\fs20\cf1\strike GetStrField\plain\f2\fs20 OOBase_ObjectT_GetStrField
\par \plain\f2\fs20\cf1\strike GetStrFieldLen\plain\f2\fs20 OOBase_ObjectT_GetStrFieldLen
\par \plain\f2\fs20\cf1\strike PutPointerField\plain\f2\fs20 OOBase_ObjectT_PutPointerField
\par \plain\f2\fs20\cf1\strike GetPointerField\plain\f2\fs20 OOBase_ObjectT_GetPointerField
\par \plain\f2\fs19\b\up14 #$K\plain\f2\fs28\b Init
\par \plain\f2\fs20\b defined in module \plain\f2\fs20\cf1\b\strike OOBase\plain\f2\fs20\b OOBase, bound to type \plain\f2\fs20\cf1\b\strike ObjectT\plain\f2\fs20\b OOBase_ObjectT
\par \plain\f2\fs24\b Syntax
\par \plain\f5\fs20 PROCEDURE (VAR) Init()
\par \plain\f2\fs24\b Description
\par \plain\f2\fs20 This is an abstract method. The initialization methods of all classes should be called Init. This makes it possible to have a general convention for object creation: after allocating an object with NEW the method Init can be called regardless of the objects class. 
\par \plain\f2\fs19\b\up14 #$K\plain\f2\fs28\b GetFieldType
\par \plain\f2\fs20\b defined in module \plain\f2\fs20\cf1\b\strike OOBase\plain\f2\fs20\b OOBase, bound to type \plain\f2\fs20\cf1\b\strike ObjectT\plain\f2\fs20\b OOBase_ObjectT
\par \plain\f2\fs24\b Syntax
\par \plain\f5\fs20 PROCEDURE (POINTER) GetFieldType(VAR fieldName:ARRAY OF CHAR; 
\par                                  VAR typeCode:INTEGER; 
\par                                  VAR done:BOOLEAN)
\par \plain\f2\fs24\b Description
\par \plain\f2\fs20 Returns the type code of a specific record field; the specified field must be of a basic type or an array of char in which case typeCode is set to TYP_STRING. 
\par \plain\f2\fs19\b\up14 #$K\plain\f2\fs28\b PutIntField
\par \plain\f2\fs20\b defined in module \plain\f2\fs20\cf1\b\strike OOBase\plain\f2\fs20\b OOBase, bound to type \plain\f2\fs20\cf1\b\strike ObjectT\plain\f2\fs20\b OOBase_ObjectT
\par \plain\f2\fs24\b Syntax
\par \plain\f5\fs20 PROCEDURE (POINTER) PutIntField(fieldName:ARRAY OF CHAR; 
\par                                 x:INTEGER; 
\par                                 VAR done:BOOLEAN)
\par \plain\f2\fs19\b\up14 #$K\plain\f2\fs28\b GetIntField
\par \plain\f2\fs20\b defined in module \plain\f2\fs20\cf1\b\strike OOBase\plain\f2\fs20\b OOBase, bound to type \plain\f2\fs20\cf1\b\strike ObjectT\plain\f2\fs20\b OOBase_ObjectT
\par \plain\f2\fs24\b Syntax
\par \plain\f5\fs20 PROCEDURE (POINTER) GetIntField(fieldName:ARRAY OF CHAR; 
\par                                 VAR x:INTEGER; 
\par                                 VAR done:BOOLEAN)
\par \plain\f2\fs19\b\up14 #$K\plain\f2\fs28\b PutLongIntField
\par \plain\f2\fs20\b defined in module \plain\f2\fs20\cf1\b\strike OOBase\plain\f2\fs20\b OOBase, bound to type \plain\f2\fs20\cf1\b\strike ObjectT\plain\f2\fs20\b OOBase_ObjectT
\par \plain\f2\fs24\b Syntax
\par \plain\f5\fs20 PROCEDURE (POINTER) PutLongIntField(fieldName:ARRAY OF CHAR; 
\par                                     x:LONGINT; 
\par                                     VAR done:BOOLEAN)
\par \plain\f2\fs19\b\up14 #$K\plain\f2\fs28\b GetLongIntField
\par \plain\f2\fs20\b defined in module \plain\f2\fs20\cf1\b\strike OOBase\plain\f2\fs20\b OOBase, bound to type \plain\f2\fs20\cf1\b\strike ObjectT\plain\f2\fs20\b OOBase_ObjectT
\par \plain\f2\fs24\b Syntax
\par \plain\f5\fs20 PROCEDURE (POINTER) GetLongIntField(fieldName:ARRAY OF CHAR; 
\par                                     VAR x:LONGINT; 
\par                                     VAR done:BOOLEAN)
\par \plain\f2\fs19\b\up14 #$K\plain\f2\fs28\b PutShortIntField
\par \plain\f2\fs20\b defined in module \plain\f2\fs20\cf1\b\strike OOBase\plain\f2\fs20\b OOBase, bound to type \plain\f2\fs20\cf1\b\strike ObjectT\plain\f2\fs20\b OOBase_ObjectT
\par \plain\f2\fs24\b Syntax
\par \plain\f5\fs20 PROCEDURE (POINTER) PutShortIntField(fieldName:ARRAY OF CHAR; 
\par                                      x:SHORTINT; 
\par                                      VAR done:BOOLEAN)
\par \plain\f2\fs19\b\up14 #$K\plain\f2\fs28\b GetShortIntField
\par \plain\f2\fs20\b defined in module \plain\f2\fs20\cf1\b\strike OOBase\plain\f2\fs20\b OOBase, bound to type \plain\f2\fs20\cf1\b\strike ObjectT\plain\f2\fs20\b OOBase_ObjectT
\par \plain\f2\fs24\b Syntax
\par \plain\f5\fs20 PROCEDURE (POINTER) GetShortIntField(fieldName:ARRAY OF CHAR; 
\par                                      VAR x:SHORTINT; 
\par                                      VAR done:BOOLEAN)
\par \plain\f2\fs19\b\up14 #$K\plain\f2\fs28\b PutCharField
\par \plain\f2\fs20\b defined in module \plain\f2\fs20\cf1\b\strike OOBase\plain\f2\fs20\b OOBase, bound to type \plain\f2\fs20\cf1\b\strike ObjectT\plain\f2\fs20\b OOBase_ObjectT
\par \plain\f2\fs24\b Syntax
\par \plain\f5\fs20 PROCEDURE (POINTER) PutCharField(fieldName:ARRAY OF CHAR; 
\par                                  x:CHAR; 
\par                                  VAR done:BOOLEAN)
\par \plain\f2\fs19\b\up14 #$K\plain\f2\fs28\b GetCharField
\par \plain\f2\fs20\b defined in module \plain\f2\fs20\cf1\b\strike OOBase\plain\f2\fs20\b OOBase, bound to type \plain\f2\fs20\cf1\b\strike ObjectT\plain\f2\fs20\b OOBase_ObjectT
\par \plain\f2\fs24\b Syntax
\par \plain\f5\fs20 PROCEDURE (POINTER) GetCharField(fieldName:ARRAY OF CHAR; 
\par                                  VAR x:CHAR; 
\par                                  VAR done:BOOLEAN)
\par \plain\f2\fs19\b\up14 #$K\plain\f2\fs28\b PutBoolField
\par \plain\f2\fs20\b defined in module \plain\f2\fs20\cf1\b\strike OOBase\plain\f2\fs20\b OOBase, bound to type \plain\f2\fs20\cf1\b\strike ObjectT\plain\f2\fs20\b OOBase_ObjectT
\par \plain\f2\fs24\b Syntax
\par \plain\f5\fs20 PROCEDURE (POINTER) PutBoolField(fieldName:ARRAY OF CHAR; 
\par                                  x:BOOLEAN; 
\par                                  VAR done:BOOLEAN)
\par \plain\f2\fs19\b\up14 #$K\plain\f2\fs28\b GetBoolField
\par \plain\f2\fs20\b defined in module \plain\f2\fs20\cf1\b\strike OOBase\plain\f2\fs20\b OOBase, bound to type \plain\f2\fs20\cf1\b\strike ObjectT\plain\f2\fs20\b OOBase_ObjectT
\par \plain\f2\fs24\b Syntax
\par \plain\f5\fs20 PROCEDURE (POINTER) GetBoolField(fieldName:ARRAY OF CHAR; 
\par                                  VAR x:BOOLEAN; 
\par                                  VAR done:BOOLEAN)
\par \plain\f2\fs19\b\up14 #$K\plain\f2\fs28\b PutSetField
\par \plain\f2\fs20\b defined in module \plain\f2\fs20\cf1\b\strike OOBase\plain\f2\fs20\b OOBase, bound to type \plain\f2\fs20\cf1\b\strike ObjectT\plain\f2\fs20\b OOBase_ObjectT
\par \plain\f2\fs24\b Syntax
\par \plain\f5\fs20 PROCEDURE (POINTER) PutSetField(fieldName:ARRAY OF CHAR; 
\par                                 x:SET; 
\par                                 VAR done:BOOLEAN)
\par \plain\f2\fs19\b\up14 #$K\plain\f2\fs28\b GetSetField
\par \plain\f2\fs20\b defined in module \plain\f2\fs20\cf1\b\strike OOBase\plain\f2\fs20\b OOBase, bound to type \plain\f2\fs20\cf1\b\strike ObjectT\plain\f2\fs20\b OOBase_ObjectT
\par \plain\f2\fs24\b Syntax
\par \plain\f5\fs20 PROCEDURE (POINTER) GetSetField(fieldName:ARRAY OF CHAR; 
\par                                 VAR x:SET; 
\par                                 VAR done:BOOLEAN)
\par \plain\f2\fs19\b\up14 #$K\plain\f2\fs28\b PutRealField
\par \plain\f2\fs20\b defined in module \plain\f2\fs20\cf1\b\strike OOBase\plain\f2\fs20\b OOBase, bound to type \plain\f2\fs20\cf1\b\strike ObjectT\plain\f2\fs20\b OOBase_ObjectT
\par \plain\f2\fs24\b Syntax
\par \plain\f5\fs20 PROCEDURE (POINTER) PutRealField(fieldName:ARRAY OF CHAR; 
\par                                  x:REAL; 
\par                                  VAR done:BOOLEAN)
\par \plain\f2\fs19\b\up14 #$K\plain\f2\fs28\b GetRealField
\par \plain\f2\fs20\b defined in module \plain\f2\fs20\cf1\b\strike OOBase\plain\f2\fs20\b OOBase, bound to type \plain\f2\fs20\cf1\b\strike ObjectT\plain\f2\fs20\b OOBase_ObjectT
\par \plain\f2\fs24\b Syntax
\par \plain\f5\fs20 PROCEDURE (POINTER) GetRealField(fieldName:ARRAY OF CHAR; 
\par                                  VAR x:REAL; 
\par                                  VAR done:BOOLEAN)
\par \plain\f2\fs19\b\up14 #$K\plain\f2\fs28\b PutLongRealField
\par \plain\f2\fs20\b defined in module \plain\f2\fs20\cf1\b\strike OOBase\plain\f2\fs20\b OOBase, bound to type \plain\f2\fs20\cf1\b\strike ObjectT\plain\f2\fs20\b OOBase_ObjectT
\par \plain\f2\fs24\b Syntax
\par \plain\f5\fs20 PROCEDURE (POINTER) PutLongRealField(fieldName:ARRAY OF CHAR; 
\par                                      x:LONGREAL; 
\par                                      VAR done:BOOLEAN)
\par \plain\f2\fs19\b\up14 #$K\plain\f2\fs28\b GetLongRealField
\par \plain\f2\fs20\b defined in module \plain\f2\fs20\cf1\b\strike OOBase\plain\f2\fs20\b OOBase, bound to type \plain\f2\fs20\cf1\b\strike ObjectT\plain\f2\fs20\b OOBase_ObjectT
\par \plain\f2\fs24\b Syntax
\par \plain\f5\fs20 PROCEDURE (POINTER) GetLongRealField(fieldName:ARRAY OF CHAR; 
\par                                      VAR x:LONGREAL; 
\par                                      VAR done:BOOLEAN)
\par \plain\f2\fs19\b\up14 #$K\plain\f2\fs28\b PutStrField
\par \plain\f2\fs20\b defined in module \plain\f2\fs20\cf1\b\strike OOBase\plain\f2\fs20\b OOBase, bound to type \plain\f2\fs20\cf1\b\strike ObjectT\plain\f2\fs20\b OOBase_ObjectT
\par \plain\f2\fs24\b Syntax
\par \plain\f5\fs20 PROCEDURE (POINTER) PutStrField(fieldName:ARRAY OF CHAR; 
\par                                 x:ARRAY OF CHAR; 
\par                                 VAR done:BOOLEAN)
\par \plain\f2\fs19\b\up14 #$K\plain\f2\fs28\b GetStrField
\par \plain\f2\fs20\b defined in module \plain\f2\fs20\cf1\b\strike OOBase\plain\f2\fs20\b OOBase, bound to type \plain\f2\fs20\cf1\b\strike ObjectT\plain\f2\fs20\b OOBase_ObjectT
\par \plain\f2\fs24\b Syntax
\par \plain\f5\fs20 PROCEDURE (POINTER) GetStrField(fieldName:ARRAY OF CHAR; 
\par                                 VAR x:ARRAY OF CHAR; 
\par                                 VAR done:BOOLEAN)
\par \plain\f2\fs24\b Description
\par \plain\f2\fs20\b done\plain\f2\fs20  is set to FALSE if either the desired field can not be found, the field has the wrong type or \plain\f2\fs20\b x\plain\f2\fs20  is not large enough to store the contents of the field. If \plain\f2\fs20\b x\plain\f2\fs20  is not large enough to hold the result it is truncated. In all other cases of error \plain\f2\fs20\b x\plain\f2\fs20  is set to the empty string. 
\par \plain\f2\fs19\b\up14 #$K\plain\f2\fs28\b GetStrFieldLen
\par \plain\f2\fs20\b defined in module \plain\f2\fs20\cf1\b\strike OOBase\plain\f2\fs20\b OOBase, bound to type \plain\f2\fs20\cf1\b\strike ObjectT\plain\f2\fs20\b OOBase_ObjectT
\par \plain\f2\fs24\b Syntax
\par \plain\f5\fs20 PROCEDURE (POINTER) GetStrFieldLen(fieldName:ARRAY OF CHAR; 
\par                                    VAR x:LONGINT; 
\par                                    VAR done:BOOLEAN)
\par \plain\f2\fs24\b Description
\par \plain\f2\fs20 returns the length of the string stored in the record field with the name fieldName 
\par \plain\f2\fs19\b\up14 #$K\plain\f2\fs28\b PutPointerField
\par \plain\f2\fs20\b defined in module \plain\f2\fs20\cf1\b\strike OOBase\plain\f2\fs20\b OOBase, bound to type \plain\f2\fs20\cf1\b\strike ObjectT\plain\f2\fs20\b OOBase_ObjectT
\par \plain\f2\fs24\b Syntax
\par \plain\f5\fs20 PROCEDURE (POINTER) PutPointerField(fieldName:ARRAY OF CHAR; 
\par                                     x:\plain\f5\fs20\cf1\ul Object\plain\f5\fs20 OOBase_Object; 
\par                                     VAR done:BOOLEAN)
\par \plain\f2\fs19\b\up14 #$K\plain\f2\fs28\b GetPointerField
\par \plain\f2\fs20\b defined in module \plain\f2\fs20\cf1\b\strike OOBase\plain\f2\fs20\b OOBase, bound to type \plain\f2\fs20\cf1\b\strike ObjectT\plain\f2\fs20\b OOBase_ObjectT
\par \plain\f2\fs24\b Syntax
\par \plain\f5\fs20 PROCEDURE (POINTER) GetPointerField(fieldName:ARRAY OF CHAR; 
\par                                     VAR x:\plain\f5\fs20\cf1\ul Object\plain\f5\fs20 OOBase_Object; 
\par                                     VAR done:BOOLEAN)
\par \plain\f2\fs19\b\up14 #$K\plain\f2\fs28\b ObjMetaToolT
\par \plain\f2\fs20\b defined in module \plain\f2\fs20\cf1\b\strike OOBase\plain\f2\fs20\b OOBase
\par \plain\f2\fs24\b Syntax
\par \plain\f5\fs20 ObjMetaToolT=RECORD 
\par END;
\par \plain\f2\fs24\b Methods
\par \plain\f2\fs20\cf1\strike InitToObj\plain\f2\fs20 OOBase_ObjMetaToolT_InitToObj
\par \plain\f2\fs20\cf1\strike GetNextName\plain\f2\fs20 OOBase_ObjMetaToolT_GetNextName
\par \plain\f2\fs20\cf1\strike SetMarker\plain\f2\fs20 OOBase_ObjMetaToolT_SetMarker
\par \plain\f2\fs20\cf1\strike ToMarker\plain\f2\fs20 OOBase_ObjMetaToolT_ToMarker
\par \plain\f2\fs20\cf1\strike GetTypeEntry\plain\f2\fs20 OOBase_ObjMetaToolT_GetTypeEntry
\par \plain\f2\fs20\cf1\strike GetNextSymbol\plain\f2\fs20 OOBase_ObjMetaToolT_GetNextSymbol
\par \plain\f2\fs20\cf1\strike GetSymbolInfo\plain\f2\fs20 OOBase_ObjMetaToolT_GetSymbolInfo
\par \plain\f2\fs19\b\up14 #$K\plain\f2\fs28\b InitToObj
\par \plain\f2\fs20\b defined in module \plain\f2\fs20\cf1\b\strike OOBase\plain\f2\fs20\b OOBase, bound to type \plain\f2\fs20\cf1\b\strike ObjMetaToolT\plain\f2\fs20\b OOBase_ObjMetaToolT
\par \plain\f2\fs24\b Syntax
\par \plain\f5\fs20 PROCEDURE (VAR) InitToObj(obj:\plain\f5\fs20\cf1\ul Object\plain\f5\fs20 OOBase_Object)
\par \plain\f2\fs24\b Description
\par \plain\f2\fs20 The object meta information tool has to be initialized to work on a specific object prior to a call to any other method of this class. 
\par \plain\f2\fs19\b\up14 #$K\plain\f2\fs28\b GetNextName
\par \plain\f2\fs20\b defined in module \plain\f2\fs20\cf1\b\strike OOBase\plain\f2\fs20\b OOBase, bound to type \plain\f2\fs20\cf1\b\strike ObjMetaToolT\plain\f2\fs20\b OOBase_ObjMetaToolT
\par \plain\f2\fs24\b Syntax
\par \plain\f5\fs20 PROCEDURE (VAR) GetNextName(VAR name:ARRAY OF CHAR; 
\par                             VAR table:LONGINT; 
\par                             VAR codeInx:INTEGER)
\par \plain\f2\fs24\b Description
\par \plain\f2\fs20 retrieve next name from RTTI string table. codeInx is set to -1 if there is no directly associated entry in the code table. The name contains the empty string if the last name has already been read. 
\par \plain\f2\fs19\b\up14 #$K\plain\f2\fs28\b SetMarker
\par \plain\f2\fs20\b defined in module \plain\f2\fs20\cf1\b\strike OOBase\plain\f2\fs20\b OOBase, bound to type \plain\f2\fs20\cf1\b\strike ObjMetaToolT\plain\f2\fs20\b OOBase_ObjMetaToolT
\par \plain\f2\fs24\b Syntax
\par \plain\f5\fs20 PROCEDURE (VAR) SetMarker(VAR marker:\plain\f5\fs20\cf1\strike ObjMetaToolMarkerT\plain\f5\fs20 OOBase_ObjMetaToolMarkerT)
\par \plain\f2\fs24\b Description
\par \plain\f2\fs20 store the internal reader position in the marker 
\par \plain\f2\fs19\b\up14 #$K\plain\f2\fs28\b ToMarker
\par \plain\f2\fs20\b defined in module \plain\f2\fs20\cf1\b\strike OOBase\plain\f2\fs20\b OOBase, bound to type \plain\f2\fs20\cf1\b\strike ObjMetaToolT\plain\f2\fs20\b OOBase_ObjMetaToolT
\par \plain\f2\fs24\b Syntax
\par \plain\f5\fs20 PROCEDURE (VAR) ToMarker(VAR marker:\plain\f5\fs20\cf1\strike ObjMetaToolMarkerT\plain\f5\fs20 OOBase_ObjMetaToolMarkerT)
\par \plain\f2\fs24\b Description
\par \plain\f2\fs20 Set the internal reader position to the state recorded in the given marker 
\par \plain\f2\fs19\b\up14 #$K\plain\f2\fs28\b GetTypeEntry
\par \plain\f2\fs20\b defined in module \plain\f2\fs20\cf1\b\strike OOBase\plain\f2\fs20\b OOBase, bound to type \plain\f2\fs20\cf1\b\strike ObjMetaToolT\plain\f2\fs20\b OOBase_ObjMetaToolT
\par \plain\f2\fs24\b Syntax
\par \plain\f5\fs20 PROCEDURE (VAR) GetTypeEntry(table:LONGINT; 
\par                              inx:INTEGER; 
\par                              VAR code:INTEGER; 
\par                              VAR offset:LONGINT; 
\par                              VAR elemSize:LONGINT; 
\par                              VAR nofElems:LONGINT)
\par \plain\f2\fs24\b Description
\par \plain\f2\fs20 Retrieves a specific entry in the RTTI code table. Properties which do not apply are set to -1. 
\par \plain\f2\fs19\b\up14 #$K\plain\f2\fs28\b GetNextSymbol
\par \plain\f2\fs20\b defined in module \plain\f2\fs20\cf1\b\strike OOBase\plain\f2\fs20\b OOBase, bound to type \plain\f2\fs20\cf1\b\strike ObjMetaToolT\plain\f2\fs20\b OOBase_ObjMetaToolT
\par \plain\f2\fs24\b Syntax
\par \plain\f5\fs20 PROCEDURE (VAR) GetNextSymbol(VAR symName:ARRAY OF CHAR; 
\par                               VAR done:BOOLEAN)
\par \plain\f2\fs24\b Description
\par \plain\f2\fs20 retrieve only symbols at top level; returns an empty string if the last symbol has already been read. 
\par \plain\f2\fs19\b\up14 #$K\plain\f2\fs28\b GetSymbolInfo
\par \plain\f2\fs20\b defined in module \plain\f2\fs20\cf1\b\strike OOBase\plain\f2\fs20\b OOBase, bound to type \plain\f2\fs20\cf1\b\strike ObjMetaToolT\plain\f2\fs20\b OOBase_ObjMetaToolT
\par \plain\f2\fs24\b Syntax
\par \plain\f5\fs20 PROCEDURE (VAR) GetSymbolInfo(VAR typeCode:INTEGER; 
\par                               VAR offs:LONGINT)
\par \plain\f2\fs24\b Description
\par \plain\f2\fs20 retrieve information about the last symbol read by GetNextSymbol; typeCode is -1 if call failed 
\par \plain\f2\fs19\b\up14 #$K\plain\f2\fs28\b ObjMetaToolMarkerT
\par \plain\f2\fs20\b defined in module \plain\f2\fs20\cf1\b\strike OOBase\plain\f2\fs20\b OOBase
\par \plain\f2\fs24\b Syntax
\par \plain\f5\fs20 ObjMetaToolMarkerT=RECORD 
\par END;
\par \plain\f2\fs19\b\up14 #$K\plain\f2\fs28\b Module Out
\par \plain\f2\fs20 This module offers a simple sequential output to the screen. A particular advantage is that the whole output is always accessible, even if it is far longer than one screen page.
\par \plain\f2\fs24\b Procedures
\par \plain\f2\fs20\cf1\strike SetScreenUpdate\plain\f2\fs20 Out_SetScreenUpdate
\par \plain\f2\fs20\cf1\strike Char\plain\f2\fs20 Out_Char
\par \plain\f2\fs20\cf1\strike String\plain\f2\fs20 Out_String
\par \plain\f2\fs20\cf1\strike Real\plain\f2\fs20 Out_Real
\par \plain\f2\fs20\cf1\strike Int\plain\f2\fs20 Out_Int
\par \plain\f2\fs20\cf1\strike Ln\plain\f2\fs20 Out_Ln
\par \plain\f2\fs20\cf1\strike Open\plain\f2\fs20 Out_Open
\par \plain\f2\fs20\cf1\strike Close\plain\f2\fs20 Out_Close
\par \plain\f2\fs20\cf1\strike LongReal\plain\f2\fs20 Out_LongReal
\par \plain\f2\fs20\cf1\strike F\plain\f2\fs20 Out_F
\par \plain\f2\fs20\cf1\strike F2\plain\f2\fs20 Out_F2
\par \plain\f2\fs20\cf1\strike F3\plain\f2\fs20 Out_F3
\par \plain\f2\fs20\cf1\strike F4\plain\f2\fs20 Out_F4
\par \plain\f2\fs19\b\up14 #$K\plain\f2\fs28\b SetScreenUpdate
\par \plain\f2\fs20\b defined in module \plain\f2\fs20\cf1\b\strike Out\plain\f2\fs20\b Out
\par \plain\f2\fs24\b Syntax
\par \plain\f5\fs20 PROCEDURE SetScreenUpdate(x:BOOLEAN)
\par \plain\f2\fs19\b\up14 #$K\plain\f2\fs28\b Char
\par \plain\f2\fs20\b defined in module \plain\f2\fs20\cf1\b\strike Out\plain\f2\fs20\b Out
\par \plain\f2\fs24\b Syntax
\par \plain\f5\fs20 PROCEDURE Char(ch:CHAR)
\par \plain\f2\fs19\b\up14 #$K\plain\f2\fs28\b String
\par \plain\f2\fs20\b defined in module \plain\f2\fs20\cf1\b\strike Out\plain\f2\fs20\b Out
\par \plain\f2\fs24\b Syntax
\par \plain\f5\fs20 PROCEDURE String(str:ARRAY OF CHAR)
\par \plain\f2\fs19\b\up14 #$K\plain\f2\fs28\b Real
\par \plain\f2\fs20\b defined in module \plain\f2\fs20\cf1\b\strike Out\plain\f2\fs20\b Out
\par \plain\f2\fs24\b Syntax
\par \plain\f5\fs20 PROCEDURE Real(x:LONGREAL; 
\par                n:INTEGER)
\par \plain\f2\fs19\b\up14 #$K\plain\f2\fs28\b Int
\par \plain\f2\fs20\b defined in module \plain\f2\fs20\cf1\b\strike Out\plain\f2\fs20\b Out
\par \plain\f2\fs24\b Syntax
\par \plain\f5\fs20 PROCEDURE Int(i, n:LONGINT)
\par \plain\f2\fs19\b\up14 #$K\plain\f2\fs28\b Ln
\par \plain\f2\fs20\b defined in module \plain\f2\fs20\cf1\b\strike Out\plain\f2\fs20\b Out
\par \plain\f2\fs24\b Syntax
\par \plain\f5\fs20 PROCEDURE Ln()
\par \plain\f2\fs19\b\up14 #$K\plain\f2\fs28\b Open
\par \plain\f2\fs20\b defined in module \plain\f2\fs20\cf1\b\strike Out\plain\f2\fs20\b Out
\par \plain\f2\fs24\b Syntax
\par \plain\f5\fs20 PROCEDURE Open()
\par \plain\f2\fs19\b\up14 #$K\plain\f2\fs28\b Close
\par \plain\f2\fs20\b defined in module \plain\f2\fs20\cf1\b\strike Out\plain\f2\fs20\b Out
\par \plain\f2\fs24\b Syntax
\par \plain\f5\fs20 PROCEDURE Close()
\par \plain\f2\fs19\b\up14 #$K\plain\f2\fs28\b LongReal
\par \plain\f2\fs20\b defined in module \plain\f2\fs20\cf1\b\strike Out\plain\f2\fs20\b Out
\par \plain\f2\fs24\b Syntax
\par \plain\f5\fs20 PROCEDURE LongReal(x:LONGREAL; 
\par                    n:INTEGER)
\par \plain\f2\fs19\b\up14 #$K\plain\f2\fs28\b F
\par \plain\f2\fs20\b defined in module \plain\f2\fs20\cf1\b\strike Out\plain\f2\fs20\b Out
\par \plain\f2\fs24\b Syntax
\par \plain\f5\fs20 PROCEDURE F(t:ARRAY OF CHAR; 
\par             x1:LONGINT)
\par \plain\f2\fs19\b\up14 #$K\plain\f2\fs28\b F2
\par \plain\f2\fs20\b defined in module \plain\f2\fs20\cf1\b\strike Out\plain\f2\fs20\b Out
\par \plain\f2\fs24\b Syntax
\par \plain\f5\fs20 PROCEDURE F2(t:ARRAY OF CHAR; 
\par              x1, x2:LONGINT)
\par \plain\f2\fs19\b\up14 #$K\plain\f2\fs28\b F3
\par \plain\f2\fs20\b defined in module \plain\f2\fs20\cf1\b\strike Out\plain\f2\fs20\b Out
\par \plain\f2\fs24\b Syntax
\par \plain\f5\fs20 PROCEDURE F3(t:ARRAY OF CHAR; 
\par              x1, x2, x3:LONGINT)
\par \plain\f2\fs19\b\up14 #$K\plain\f2\fs28\b F4
\par \plain\f2\fs20\b defined in module \plain\f2\fs20\cf1\b\strike Out\plain\f2\fs20\b Out
\par \plain\f2\fs24\b Syntax
\par \plain\f5\fs20 PROCEDURE F4(t:ARRAY OF CHAR; 
\par              x1, x2, x3, x4:LONGINT)
\par \plain\f2\fs19\b\up14 #$K\plain\f2\fs28\b Module Param
\par \plain\f2\fs20 This module offers access to the command line which was used to start the program. It is possible to access the command line as a whole or only single parameters. It is assumed that the single parameters of the command line are separated either by blanks, commas or both.
\par \plain\f2\fs24\b Constants
\par \pard\li2880\fi-2880\plain\f2\fs20 MAXPARAMLEN\tab \tab maximum length of the entire parameter string 
\par MAXSTR\tab \tab \tab maximum number of different parts of the parameter string 
\par \pard\plain\f2\fs24\b Procedures
\par \plain\f2\fs20\cf1\strike CompleteStr\plain\f2\fs20 Param_CompleteStr
\par \plain\f2\fs20\cf1\strike Count\plain\f2\fs20 Param_Count
\par \plain\f2\fs20\cf1\strike Parse\plain\f2\fs20 Param_Parse
\par \plain\f2\fs20\cf1\strike Str\plain\f2\fs20 Param_Str
\par \plain\f2\fs19\b\up14 #$K\plain\f2\fs28\b CompleteStr
\par \plain\f2\fs20\b defined in module \plain\f2\fs20\cf1\b\strike Param\plain\f2\fs20\b Param
\par \plain\f2\fs24\b Syntax
\par \plain\f5\fs20 PROCEDURE CompleteStr(VAR t:ARRAY OF CHAR)
\par \plain\f2\fs19\b\up14 #$K\plain\f2\fs28\b Count
\par \plain\f2\fs20\b defined in module \plain\f2\fs20\cf1\b\strike Param\plain\f2\fs20\b Param
\par \plain\f2\fs24\b Syntax
\par \plain\f5\fs20 PROCEDURE Count():INTEGER
\par \plain\f2\fs19\b\up14 #$K\plain\f2\fs28\b Parse
\par \plain\f2\fs20\b defined in module \plain\f2\fs20\cf1\b\strike Param\plain\f2\fs20\b Param
\par \plain\f2\fs24\b Syntax
\par \plain\f5\fs20 PROCEDURE Parse(VAR line:ARRAY OF CHAR)
\par \plain\f2\fs19\b\up14 #$K\plain\f2\fs28\b Str
\par \plain\f2\fs20\b defined in module \plain\f2\fs20\cf1\b\strike Param\plain\f2\fs20\b Param
\par \plain\f2\fs24\b Syntax
\par \plain\f5\fs20 PROCEDURE Str(i:INTEGER; 
\par               VAR t:ARRAY OF CHAR)
\par \plain\f2\fs19\b\up14 #$K\plain\f2\fs28\b Module Print
\par \plain\f2\fs20 This module provides character based access to printers.
\par \plain\f2\fs24\b Procedures
\par \plain\f2\fs20\cf1\strike StartWithDialog\plain\f2\fs20 Print_StartWithDialog
\par \plain\f2\fs20\cf1\strike Start\plain\f2\fs20 Print_Start
\par \plain\f2\fs20\cf1\strike Page\plain\f2\fs20 Print_Page
\par \plain\f2\fs20\cf1\strike Ln\plain\f2\fs20 Print_Ln
\par \plain\f2\fs20\cf1\strike GetInfo\plain\f2\fs20 Print_GetInfo
\par \plain\f2\fs20\cf1\strike Char\plain\f2\fs20 Print_Char
\par \plain\f2\fs20\cf1\strike Str\plain\f2\fs20 Print_Str
\par \plain\f2\fs20\cf1\strike Real\plain\f2\fs20 Print_Real
\par \plain\f2\fs20\cf1\strike Int\plain\f2\fs20 Print_Int
\par \plain\f2\fs20\cf1\strike Finished\plain\f2\fs20 Print_Finished
\par \plain\f2\fs20\cf1\strike SetLeftMargin\plain\f2\fs20 Print_SetLeftMargin
\par \plain\f2\fs20\cf1\strike SetTopMargin\plain\f2\fs20 Print_SetTopMargin
\par \plain\f2\fs20\cf1\strike RemainingLines\plain\f2\fs20 Print_RemainingLines
\par \plain\f2\fs19\b\up14 #$K\plain\f2\fs28\b StartWithDialog
\par \plain\f2\fs20\b defined in module \plain\f2\fs20\cf1\b\strike Print\plain\f2\fs20\b Print
\par \plain\f2\fs24\b Syntax
\par \plain\f5\fs20 PROCEDURE StartWithDialog():BOOLEAN
\par \plain\f2\fs19\b\up14 #$K\plain\f2\fs28\b Start
\par \plain\f2\fs20\b defined in module \plain\f2\fs20\cf1\b\strike Print\plain\f2\fs20\b Print
\par \plain\f2\fs24\b Syntax
\par \plain\f5\fs20 PROCEDURE Start()
\par \plain\f2\fs19\b\up14 #$K\plain\f2\fs28\b Page
\par \plain\f2\fs20\b defined in module \plain\f2\fs20\cf1\b\strike Print\plain\f2\fs20\b Print
\par \plain\f2\fs24\b Syntax
\par \plain\f5\fs20 PROCEDURE Page()
\par \plain\f2\fs19\b\up14 #$K\plain\f2\fs28\b Ln
\par \plain\f2\fs20\b defined in module \plain\f2\fs20\cf1\b\strike Print\plain\f2\fs20\b Print
\par \plain\f2\fs24\b Syntax
\par \plain\f5\fs20 PROCEDURE Ln()
\par \plain\f2\fs19\b\up14 #$K\plain\f2\fs28\b GetInfo
\par \plain\f2\fs20\b defined in module \plain\f2\fs20\cf1\b\strike Print\plain\f2\fs20\b Print
\par \plain\f2\fs24\b Syntax
\par \plain\f5\fs20 PROCEDURE GetInfo(VAR x, y:LONGINT; 
\par                   VAR hdc:WD.HDC)
\par \plain\f2\fs19\b\up14 #$K\plain\f2\fs28\b Char
\par \plain\f2\fs20\b defined in module \plain\f2\fs20\cf1\b\strike Print\plain\f2\fs20\b Print
\par \plain\f2\fs24\b Syntax
\par \plain\f5\fs20 PROCEDURE Char(x:CHAR)
\par \plain\f2\fs19\b\up14 #$K\plain\f2\fs28\b Str
\par \plain\f2\fs20\b defined in module \plain\f2\fs20\cf1\b\strike Print\plain\f2\fs20\b Print
\par \plain\f2\fs24\b Syntax
\par \plain\f5\fs20 PROCEDURE Str(t:ARRAY OF CHAR)
\par \plain\f2\fs19\b\up14 #$K\plain\f2\fs28\b Real
\par \plain\f2\fs20\b defined in module \plain\f2\fs20\cf1\b\strike Print\plain\f2\fs20\b Print
\par \plain\f2\fs24\b Syntax
\par \plain\f5\fs20 PROCEDURE Real(x:LONGREAL; 
\par                n:INTEGER)
\par \plain\f2\fs19\b\up14 #$K\plain\f2\fs28\b Int
\par \plain\f2\fs20\b defined in module \plain\f2\fs20\cf1\b\strike Print\plain\f2\fs20\b Print
\par \plain\f2\fs24\b Syntax
\par \plain\f5\fs20 PROCEDURE Int(i, n:LONGINT)
\par \plain\f2\fs19\b\up14 #$K\plain\f2\fs28\b Finished
\par \plain\f2\fs20\b defined in module \plain\f2\fs20\cf1\b\strike Print\plain\f2\fs20\b Print
\par \plain\f2\fs24\b Syntax
\par \plain\f5\fs20 PROCEDURE Finished()
\par \plain\f2\fs19\b\up14 #$K\plain\f2\fs28\b SetLeftMargin
\par \plain\f2\fs20\b defined in module \plain\f2\fs20\cf1\b\strike Print\plain\f2\fs20\b Print
\par \plain\f2\fs24\b Syntax
\par \plain\f5\fs20 PROCEDURE SetLeftMargin(marg:INTEGER)
\par \plain\f2\fs19\b\up14 #$K\plain\f2\fs28\b SetTopMargin
\par \plain\f2\fs20\b defined in module \plain\f2\fs20\cf1\b\strike Print\plain\f2\fs20\b Print
\par \plain\f2\fs24\b Syntax
\par \plain\f5\fs20 PROCEDURE SetTopMargin(marg:INTEGER)
\par \plain\f2\fs19\b\up14 #$K\plain\f2\fs28\b RemainingLines
\par \plain\f2\fs20\b defined in module \plain\f2\fs20\cf1\b\strike Print\plain\f2\fs20\b Print
\par \plain\f2\fs24\b Syntax
\par \plain\f5\fs20 PROCEDURE RemainingLines():INTEGER
\par \plain\f2\fs19\b\up14 #$K\plain\f2\fs28\b Module Process
\par \plain\f2\fs20 This module helps to control the execution of a program.
\par \plain\f2\fs24\b Types
\par \plain\f2\fs20\cf1\ul ExitProc\plain\f2\fs20 Process_ExitProc
\par \plain\f2\fs24\b Variables
\par \plain\f2\fs20\cf1\ul exitProc\plain\f2\fs20 Process_exitProc
\par \plain\f2\fs20\cf1\ul importantExitProc\plain\f2\fs20 Process_importantExitProc
\par \plain\f2\fs20\cf1\ul terminateMsgLoops\plain\f2\fs20 Process_terminateMsgLoops
\par \plain\f2\fs20\cf1\ul breakEnabled\plain\f2\fs20 Process_breakEnabled
\par \plain\f2\fs24\b Procedures
\par \plain\f2\fs20\cf1\strike NumberOfActiveThreads\plain\f2\fs20 Process_NumberOfActiveThreads
\par \plain\f2\fs20\cf1\strike Yield\plain\f2\fs20 Process_Yield
\par \plain\f2\fs20\cf1\strike SetIdleStatus\plain\f2\fs20 Process_SetIdleStatus
\par \plain\f2\fs20\cf1\strike ResetIdleStatus\plain\f2\fs20 Process_ResetIdleStatus
\par \plain\f2\fs20\cf1\strike WaitForAllToTerminate\plain\f2\fs20 Process_WaitForAllToTerminate
\par \plain\f2\fs20\cf1\strike SetBreak\plain\f2\fs20 Process_SetBreak
\par \plain\f2\fs20\cf1\strike SetExitProc\plain\f2\fs20 Process_SetExitProc
\par \plain\f2\fs20\cf1\strike GetExitProc\plain\f2\fs20 Process_GetExitProc
\par \plain\f2\fs19\b\up14 #$K\plain\f2\fs28\b NumberOfActiveThreads
\par \plain\f2\fs20\b defined in module \plain\f2\fs20\cf1\b\strike Process\plain\f2\fs20\b Process
\par \plain\f2\fs24\b Syntax
\par \plain\f5\fs20 PROCEDURE NumberOfActiveThreads():INTEGER
\par \plain\f2\fs19\b\up14 #$K\plain\f2\fs28\b Yield
\par \plain\f2\fs20\b defined in module \plain\f2\fs20\cf1\b\strike Process\plain\f2\fs20\b Process
\par \plain\f2\fs24\b Syntax
\par \plain\f5\fs20 PROCEDURE Yield()
\par \plain\f2\fs19\b\up14 #$K\plain\f2\fs28\b SetIdleStatus
\par \plain\f2\fs20\b defined in module \plain\f2\fs20\cf1\b\strike Process\plain\f2\fs20\b Process
\par \plain\f2\fs24\b Syntax
\par \plain\f5\fs20 PROCEDURE SetIdleStatus()
\par \plain\f2\fs19\b\up14 #$K\plain\f2\fs28\b ResetIdleStatus
\par \plain\f2\fs20\b defined in module \plain\f2\fs20\cf1\b\strike Process\plain\f2\fs20\b Process
\par \plain\f2\fs24\b Syntax
\par \plain\f5\fs20 PROCEDURE ResetIdleStatus()
\par \plain\f2\fs19\b\up14 #$K\plain\f2\fs28\b WaitForAllToTerminate
\par \plain\f2\fs20\b defined in module \plain\f2\fs20\cf1\b\strike Process\plain\f2\fs20\b Process
\par \plain\f2\fs24\b Syntax
\par \plain\f5\fs20 PROCEDURE WaitForAllToTerminate()
\par \plain\f2\fs19\b\up14 #$K\plain\f2\fs28\b SetBreak
\par \plain\f2\fs20\b defined in module \plain\f2\fs20\cf1\b\strike Process\plain\f2\fs20\b Process
\par \plain\f2\fs24\b Syntax
\par \plain\f5\fs20 PROCEDURE SetBreak(x:BOOLEAN)
\par \plain\f2\fs19\b\up14 #$K\plain\f2\fs28\b SetExitProc
\par \plain\f2\fs20\b defined in module \plain\f2\fs20\cf1\b\strike Process\plain\f2\fs20\b Process
\par \plain\f2\fs24\b Syntax
\par \plain\f5\fs20 PROCEDURE SetExitProc(proc:\plain\f5\fs20\cf1\ul ExitProc\plain\f5\fs20 Process_ExitProc)
\par \plain\f2\fs19\b\up14 #$K\plain\f2\fs28\b GetExitProc
\par \plain\f2\fs20\b defined in module \plain\f2\fs20\cf1\b\strike Process\plain\f2\fs20\b Process
\par \plain\f2\fs24\b Syntax
\par \plain\f5\fs20 PROCEDURE GetExitProc(VAR proc:\plain\f5\fs20\cf1\ul ExitProc\plain\f5\fs20 Process_ExitProc)
\par \plain\f2\fs13\up10 #$K\plain\f2\fs20\b exitProc\plain\f2\fs20 
\par \plain\f5\fs20 exitProc-:\plain\f5\fs20\cf1\ul ExitProc\plain\f5\fs20 Process_ExitProc;
\par \plain\f2\fs13\up10 #$K\plain\f2\fs20\b importantExitProc\plain\f2\fs20 
\par \plain\f5\fs20 importantExitProc*:;
\par \plain\f2\fs13\up10 #$K\plain\f2\fs20\b terminateMsgLoops\plain\f2\fs20 
\par \plain\f5\fs20 terminateMsgLoops*:BOOLEAN;
\par \plain\f2\fs13\up10 #$K\plain\f2\fs20\b breakEnabled\plain\f2\fs20 
\par \plain\f5\fs20 breakEnabled*:BOOLEAN;
\par \plain\f2\fs13\up10 #$K\plain\f2\fs20\b ExitProc\plain\f2\fs20 
\par \plain\f5\fs20 ExitProc*=PROCEDURE ();
\par \plain\f2\fs19\b\up14 #$K\plain\f2\fs28\b Module Strings
\par \plain\f2\fs20 This module provides functions for string processing. This includes combining strings, copying parts of a string, the conversion of a string to a number or vice-versa etc.
\par All procedures should be save. If character arrays are being used which are to short for a result, the result will be truncated accordingly.
\par All functions of this module start to count the character positions with one i.e. the first character of a string is at position one.
\par All procedures applying to characters instead of strings have a trailing "Char" in their names.
\par \plain\f2\fs24\b Constants
\par \pard\li2880\fi-2880\plain\f2\fs20 ISSHORTINT\tab \tab \tab 
\par ISINTEGER\tab \tab \tab 
\par ISLONGINT\tab \tab \tab 
\par ISOUTOFRANGE\tab \tab 
\par STRINGEMPTY\tab \tab 
\par STRINGILLEGAL\tab \tab 
\par \pard\plain\f2\fs24\b Types
\par \plain\f2\fs20\cf1\ul StringT\plain\f2\fs20 Strings_StringT
\par \plain\f2\fs20\cf1\ul String\plain\f2\fs20 Strings_String
\par \plain\f2\fs24\b Procedures
\par \plain\f2\fs20\cf1\strike Length\plain\f2\fs20 Strings_Length
\par \plain\f2\fs20\cf1\strike PosChar\plain\f2\fs20 Strings_PosChar
\par \plain\f2\fs20\cf1\strike Pos\plain\f2\fs20 Strings_Pos
\par \plain\f2\fs20\cf1\strike Copy\plain\f2\fs20 Strings_Copy
\par \plain\f2\fs20\cf1\strike Append\plain\f2\fs20 Strings_Append
\par \plain\f2\fs20\cf1\strike AppendChar\plain\f2\fs20 Strings_AppendChar
\par \plain\f2\fs20\cf1\strike UpCaseChar\plain\f2\fs20 Strings_UpCaseChar
\par \plain\f2\fs20\cf1\strike UpCase\plain\f2\fs20 Strings_UpCase
\par \plain\f2\fs20\cf1\strike Delete\plain\f2\fs20 Strings_Delete
\par \plain\f2\fs20\cf1\strike RemoveTrailingSpaces\plain\f2\fs20 Strings_RemoveTrailingSpaces
\par \plain\f2\fs20\cf1\strike RemoveLeadingSpaces\plain\f2\fs20 Strings_RemoveLeadingSpaces
\par \plain\f2\fs20\cf1\strike Val\plain\f2\fs20 Strings_Val
\par \plain\f2\fs20\cf1\strike ValResult\plain\f2\fs20 Strings_ValResult
\par \plain\f2\fs20\cf1\strike Str\plain\f2\fs20 Strings_Str
\par \plain\f2\fs20\cf1\strike HexStr\plain\f2\fs20 Strings_HexStr
\par \plain\f2\fs20\cf1\strike InsertChar\plain\f2\fs20 Strings_InsertChar
\par \plain\f2\fs20\cf1\strike Insert\plain\f2\fs20 Strings_Insert
\par \plain\f2\fs20\cf1\strike LeftAlign\plain\f2\fs20 Strings_LeftAlign
\par \plain\f2\fs20\cf1\strike RightAlign\plain\f2\fs20 Strings_RightAlign
\par \plain\f2\fs19\b\up14 #$K\plain\f2\fs28\b Length
\par \plain\f2\fs20\b defined in module \plain\f2\fs20\cf1\b\strike Strings\plain\f2\fs20\b Strings
\par \plain\f2\fs24\b Syntax
\par \plain\f5\fs20 PROCEDURE Length(VAR t-:\plain\f5\fs20\cf1\ul StringT\plain\f5\fs20 Strings_StringT):LONGINT
\par \plain\f2\fs24\b Description
\par \plain\f2\fs20 Returns the length of a zero terminated string in characters. 
\par \plain\f2\fs19\b\up14 #$K\plain\f2\fs28\b PosChar
\par \plain\f2\fs20\b defined in module \plain\f2\fs20\cf1\b\strike Strings\plain\f2\fs20\b Strings
\par \plain\f2\fs24\b Syntax
\par \plain\f5\fs20 PROCEDURE PosChar(x:CHAR; 
\par                   VAR t-:\plain\f5\fs20\cf1\ul StringT\plain\f5\fs20 Strings_StringT; 
\par                   start:LONGINT):LONGINT
\par \plain\f2\fs24\b Parameters
\par \pard\li2880\fi-2880\plain\f2\fs20 start\tab \tab \tab \tab Indicates the position starting from which the search is to be carried out. If start is less than one it is set to one. If start denotes a position beyond the end of t the function returns zero. 
\par \pard\plain\f2\fs24\b Description
\par \plain\f2\fs20 This function returns the position of the character \plain\f2\fs20\b x\plain\f2\fs20  in the string \plain\f2\fs20\b t\plain\f2\fs20 . If \plain\f2\fs20\b x\plain\f2\fs20  does not occur in \plain\f2\fs20\b t\plain\f2\fs20  zero is returned. If \plain\f2\fs20\b x\plain\f2\fs20  occurs several times the position of the first occurrence is returned. 
\par \plain\f2\fs19\b\up14 #$K\plain\f2\fs28\b Pos
\par \plain\f2\fs20\b defined in module \plain\f2\fs20\cf1\b\strike Strings\plain\f2\fs20\b Strings
\par \plain\f2\fs24\b Syntax
\par \plain\f5\fs20 PROCEDURE Pos(VAR pattern-:\plain\f5\fs20\cf1\ul StringT\plain\f5\fs20 Strings_StringT; 
\par               VAR t-:\plain\f5\fs20\cf1\ul StringT\plain\f5\fs20 Strings_StringT; 
\par               start:LONGINT):LONGINT
\par \plain\f2\fs24\b Parameters
\par \pard\li2880\fi-2880\plain\f2\fs20 start\tab \tab \tab \tab Indicates the position starting from which the search shall be carried out. If start is less than one it is set to one. If start denotes a position beyond the end of t the function returns zero. 
\par \pard\plain\f2\fs24\b Description
\par \plain\f2\fs20 This function returns the position of the string pattern in the string \plain\f2\fs20\b t\plain\f2\fs20 . If pattern does not occur in \plain\f2\fs20\b t\plain\f2\fs20  zero is returned. If the pattern occurs several times the position of the first occurrence is returned. 
\par \plain\f2\fs19\b\up14 #$K\plain\f2\fs28\b Copy
\par \plain\f2\fs20\b defined in module \plain\f2\fs20\cf1\b\strike Strings\plain\f2\fs20\b Strings
\par \plain\f2\fs24\b Syntax
\par \plain\f5\fs20 PROCEDURE Copy(VAR source-, dest:\plain\f5\fs20\cf1\ul StringT\plain\f5\fs20 Strings_StringT; 
\par                pos, n:LONGINT)
\par \plain\f2\fs24\b Parameters
\par \pard\li2880\fi-2880\plain\f2\fs20 pos\tab \tab \tab \tab character position of the source fragment 
\par n\tab \tab \tab \tab length of the source fragment 
\par \pard\plain\f2\fs24\b Description
\par \plain\f2\fs20 A section of the string \plain\f2\fs20\b source\plain\f2\fs20  is copied to the string \plain\f2\fs20\b dest\plain\f2\fs20 . The former contents of \plain\f2\fs20\b dest\plain\f2\fs20  are overwritten and therefore lost.
\par The copied section in \plain\f2\fs20\b source\plain\f2\fs20  starts at the position \plain\f2\fs20\b pos\plain\f2\fs20  and is \plain\f2\fs20\b n\plain\f2\fs20  characters long.
\par If \plain\f2\fs20\b dest\plain\f2\fs20  is not large enough to hold the copied string then only the part that fits into \plain\f2\fs20\b dest\plain\f2\fs20  is copied. 
\par \plain\f2\fs19\b\up14 #$K\plain\f2\fs28\b Append
\par \plain\f2\fs20\b defined in module \plain\f2\fs20\cf1\b\strike Strings\plain\f2\fs20\b Strings
\par \plain\f2\fs24\b Syntax
\par \plain\f5\fs20 PROCEDURE Append(VAR dest:\plain\f5\fs20\cf1\ul StringT\plain\f5\fs20 Strings_StringT; 
\par                  VAR src-:\plain\f5\fs20\cf1\ul StringT\plain\f5\fs20 Strings_StringT)
\par \plain\f2\fs24\b Description
\par \plain\f2\fs20 The string \plain\f2\fs20\b src\plain\f2\fs20  is appended to the string \plain\f2\fs20\b dest\plain\f2\fs20 . 
\par \plain\f2\fs19\b\up14 #$K\plain\f2\fs28\b AppendChar
\par \plain\f2\fs20\b defined in module \plain\f2\fs20\cf1\b\strike Strings\plain\f2\fs20\b Strings
\par \plain\f2\fs24\b Syntax
\par \plain\f5\fs20 PROCEDURE AppendChar(VAR dest:\plain\f5\fs20\cf1\ul StringT\plain\f5\fs20 Strings_StringT; 
\par                      ch:CHAR)
\par \plain\f2\fs24\b Description
\par \plain\f2\fs20 The character \plain\f2\fs20\b ch\plain\f2\fs20  is appended to the string \plain\f2\fs20\b dest\plain\f2\fs20 . 
\par \plain\f2\fs19\b\up14 #$K\plain\f2\fs28\b UpCaseChar
\par \plain\f2\fs20\b defined in module \plain\f2\fs20\cf1\b\strike Strings\plain\f2\fs20\b Strings
\par \plain\f2\fs24\b Syntax
\par \plain\f5\fs20 PROCEDURE UpCaseChar(x:CHAR):CHAR
\par \plain\f2\fs24\b Description
\par \plain\f2\fs20 For all lower case letters the corresponding capital letter is returned. This also applies to international characters such as \'e4, \'e1, \'e0, \'e2... All other characters are returned unchanged. The difference between this function and the Oberon-2 function CAP(x:CHAR): CHAR is that the return value for characters other than lower case letters of the latter function depends on the individual compiler implementation. 
\par \plain\f2\fs19\b\up14 #$K\plain\f2\fs28\b UpCase
\par \plain\f2\fs20\b defined in module \plain\f2\fs20\cf1\b\strike Strings\plain\f2\fs20\b Strings
\par \plain\f2\fs24\b Syntax
\par \plain\f5\fs20 PROCEDURE UpCase(VAR t:\plain\f5\fs20\cf1\ul StringT\plain\f5\fs20 Strings_StringT)
\par \plain\f2\fs24\b Description
\par \plain\f2\fs20 All lower case letters in \plain\f2\fs20\b t\plain\f2\fs20  are converted to upper case. This also applies to international characters such as \'e4, \'e1, \'e0, \'e2... All other characters are returned unchanged. 
\par \plain\f2\fs19\b\up14 #$K\plain\f2\fs28\b Delete
\par \plain\f2\fs20\b defined in module \plain\f2\fs20\cf1\b\strike Strings\plain\f2\fs20\b Strings
\par \plain\f2\fs24\b Syntax
\par \plain\f5\fs20 PROCEDURE Delete(VAR t:\plain\f5\fs20\cf1\ul StringT\plain\f5\fs20 Strings_StringT; 
\par                  pos, n:LONGINT)
\par \plain\f2\fs24\b Description
\par \plain\f2\fs20 Starting at the position \plain\f2\fs20\b pos\plain\f2\fs20  \plain\f2\fs20\b n\plain\f2\fs20  characters of the string \plain\f2\fs20\b t\plain\f2\fs20  are deleted. 
\par \plain\f2\fs19\b\up14 #$K\plain\f2\fs28\b RemoveTrailingSpaces
\par \plain\f2\fs20\b defined in module \plain\f2\fs20\cf1\b\strike Strings\plain\f2\fs20\b Strings
\par \plain\f2\fs24\b Syntax
\par \plain\f5\fs20 PROCEDURE RemoveTrailingSpaces(VAR t:\plain\f5\fs20\cf1\ul StringT\plain\f5\fs20 Strings_StringT)
\par \plain\f2\fs24\b Description
\par \plain\f2\fs20 All blanks at the end of \plain\f2\fs20\b t\plain\f2\fs20  are removed. 
\par \plain\f2\fs19\b\up14 #$K\plain\f2\fs28\b RemoveLeadingSpaces
\par \plain\f2\fs20\b defined in module \plain\f2\fs20\cf1\b\strike Strings\plain\f2\fs20\b Strings
\par \plain\f2\fs24\b Syntax
\par \plain\f5\fs20 PROCEDURE RemoveLeadingSpaces(VAR t:\plain\f5\fs20\cf1\ul StringT\plain\f5\fs20 Strings_StringT)
\par \plain\f2\fs24\b Description
\par \plain\f2\fs20 All blanks at the beginning of \plain\f2\fs20\b t\plain\f2\fs20  are removed. 
\par \plain\f2\fs19\b\up14 #$K\plain\f2\fs28\b Val
\par \plain\f2\fs20\b defined in module \plain\f2\fs20\cf1\b\strike Strings\plain\f2\fs20\b Strings
\par \plain\f2\fs24\b Syntax
\par \plain\f5\fs20 PROCEDURE Val(t:\plain\f5\fs20\cf1\ul StringT\plain\f5\fs20 Strings_StringT):LONGINT
\par \plain\f2\fs24\b Description
\par \plain\f2\fs20 The string \plain\f2\fs20\b t\plain\f2\fs20  is converted to a number and returned as result of the function.
\par If the character sequence in \plain\f2\fs20\b t\plain\f2\fs20  does not represent a number and thus the conversion to a number fails the smallest negative number (MIN(LONGINT)) is returned. Blanks at the beginning and the end of \plain\f2\fs20\b t\plain\f2\fs20  are ignored. The number must not contain blanks. 
\par \plain\f2\fs19\b\up14 #$K\plain\f2\fs28\b ValResult
\par \plain\f2\fs20\b defined in module \plain\f2\fs20\cf1\b\strike Strings\plain\f2\fs20\b Strings
\par \plain\f2\fs24\b Syntax
\par \plain\f5\fs20 PROCEDURE ValResult(t:\plain\f5\fs20\cf1\ul StringT\plain\f5\fs20 Strings_StringT):INTEGER
\par \plain\f2\fs24\b Description
\par \plain\f2\fs20 This function can be used to discover whether the string \plain\f2\fs20\b t\plain\f2\fs20  can be converted to a number, and which kind of integer is at least necessary for storing it.
\par The IS??? constants defined for the return value have a numerical order defined relative to each other:
\par ISSHORTINT < ISINTEGER < ISLONGINT < ISOUTOFRANGE < (STRINGEMPTY, STRINGILLEGAL)
\par This definition makes it easier to find out if e.g. a number is small enough to be stored in a INTEGER variable.
\par IF Strings.ValResult(txt)<=Strings.ISINTEGER THEN ... END;
\par instead of
\par IF (Strings.ValResult(txt)=Strings.ISSHORTINT) OR (Strings.ValResult(txt)=Strings.ISINTEGER) THEN ... 
\par \plain\f2\fs19\b\up14 #$K\plain\f2\fs28\b Str
\par \plain\f2\fs20\b defined in module \plain\f2\fs20\cf1\b\strike Strings\plain\f2\fs20\b Strings
\par \plain\f2\fs24\b Syntax
\par \plain\f5\fs20 PROCEDURE Str(x:LONGINT; 
\par               VAR t:\plain\f5\fs20\cf1\ul StringT\plain\f5\fs20 Strings_StringT)
\par \plain\f2\fs24\b Description
\par \plain\f2\fs20 The number \plain\f2\fs20\b x\plain\f2\fs20  is converted to a string and the result is stored in \plain\f2\fs20\b t\plain\f2\fs20 . If \plain\f2\fs20\b t\plain\f2\fs20  is not large enough to hold all characters of the number, \plain\f2\fs20\b t\plain\f2\fs20  is filled with "$" characters. 
\par \plain\f2\fs19\b\up14 #$K\plain\f2\fs28\b HexStr
\par \plain\f2\fs20\b defined in module \plain\f2\fs20\cf1\b\strike Strings\plain\f2\fs20\b Strings
\par \plain\f2\fs24\b Syntax
\par \plain\f5\fs20 PROCEDURE HexStr(x:LONGINT; 
\par                  VAR t:\plain\f5\fs20\cf1\ul StringT\plain\f5\fs20 Strings_StringT)
\par \plain\f2\fs24\b Description
\par \plain\f2\fs20 The number \plain\f2\fs20\b x\plain\f2\fs20  is converted to a string of hexadecimal format and the result is stored in \plain\f2\fs20\b t\plain\f2\fs20 . At the end of the string an "h" is appended to indicate the hexadecimal representation of the number.
\par If \plain\f2\fs20\b t\plain\f2\fs20  is not large enough to hold all characters of the number, \plain\f2\fs20\b t\plain\f2\fs20  is filled with "$" characters. Example: 0 becomes "0h", 15 becomes "Fh", 16 becomes "10h". 
\par \plain\f2\fs19\b\up14 #$K\plain\f2\fs28\b InsertChar
\par \plain\f2\fs20\b defined in module \plain\f2\fs20\cf1\b\strike Strings\plain\f2\fs20\b Strings
\par \plain\f2\fs24\b Syntax
\par \plain\f5\fs20 PROCEDURE InsertChar(x:CHAR; 
\par                      VAR t:\plain\f5\fs20\cf1\ul StringT\plain\f5\fs20 Strings_StringT; 
\par                      pos:LONGINT)
\par \plain\f2\fs24\b Description
\par \plain\f2\fs20 The character \plain\f2\fs20\b x\plain\f2\fs20  is inserted into the string \plain\f2\fs20\b t\plain\f2\fs20  at the position \plain\f2\fs20\b pos\plain\f2\fs20  if \plain\f2\fs20\b t\plain\f2\fs20  provides space for it. 
\par \plain\f2\fs19\b\up14 #$K\plain\f2\fs28\b Insert
\par \plain\f2\fs20\b defined in module \plain\f2\fs20\cf1\b\strike Strings\plain\f2\fs20\b Strings
\par \plain\f2\fs24\b Syntax
\par \plain\f5\fs20 PROCEDURE Insert(VAR source-:\plain\f5\fs20\cf1\ul StringT\plain\f5\fs20 Strings_StringT; 
\par                  VAR dest:\plain\f5\fs20\cf1\ul StringT\plain\f5\fs20 Strings_StringT; 
\par                  pos:LONGINT)
\par \plain\f2\fs24\b Description
\par \plain\f2\fs20 The string \plain\f2\fs20\b source\plain\f2\fs20  is inserted into the string \plain\f2\fs20\b dest\plain\f2\fs20  at the position \plain\f2\fs20\b pos\plain\f2\fs20 . If the maximum length of \plain\f2\fs20\b dest\plain\f2\fs20  is insufficient to store the result only the part of \plain\f2\fs20\b source\plain\f2\fs20  fitting in \plain\f2\fs20\b dest\plain\f2\fs20  is inserted. 
\par \plain\f2\fs19\b\up14 #$K\plain\f2\fs28\b LeftAlign
\par \plain\f2\fs20\b defined in module \plain\f2\fs20\cf1\b\strike Strings\plain\f2\fs20\b Strings
\par \plain\f2\fs24\b Syntax
\par \plain\f5\fs20 PROCEDURE LeftAlign(VAR t:\plain\f5\fs20\cf1\ul StringT\plain\f5\fs20 Strings_StringT; 
\par                     n:LONGINT)
\par \plain\f2\fs24\b Description
\par \plain\f2\fs20 The length of \plain\f2\fs20\b t\plain\f2\fs20  is increased to \plain\f2\fs20\b n\plain\f2\fs20  characters by appending blanks. If \plain\f2\fs20\b t\plain\f2\fs20  has already the appropriate length or is longer \plain\f2\fs20\b t\plain\f2\fs20  remains unchanged. 
\par \plain\f2\fs19\b\up14 #$K\plain\f2\fs28\b RightAlign
\par \plain\f2\fs20\b defined in module \plain\f2\fs20\cf1\b\strike Strings\plain\f2\fs20\b Strings
\par \plain\f2\fs24\b Syntax
\par \plain\f5\fs20 PROCEDURE RightAlign(VAR t:\plain\f5\fs20\cf1\ul StringT\plain\f5\fs20 Strings_StringT; 
\par                      n:LONGINT)
\par \plain\f2\fs24\b Description
\par \plain\f2\fs20 The length of \plain\f2\fs20\b t\plain\f2\fs20  is increased to \plain\f2\fs20\b n\plain\f2\fs20  characters by inserting blanks at the beginning. If \plain\f2\fs20\b t\plain\f2\fs20  has already the appropriate length or is longer \plain\f2\fs20\b t\plain\f2\fs20  remains unchanged. 
\par \plain\f2\fs13\up10 #$K\plain\f2\fs20\b StringT\plain\f2\fs20 
\par \plain\f5\fs20 StringT*=ARRAY OF CHAR;
\par \plain\f2\fs13\up10 #$K\plain\f2\fs20\b String\plain\f2\fs20 
\par \plain\f5\fs20 String*=POINTER TO \plain\f5\fs20\cf1\ul StringT\plain\f5\fs20 Strings_StringT;
\par \plain\f2\fs19\b\up14 #$K\plain\f2\fs28\b Module Utils
\par \plain\f2\fs20 The functions implemented here tend to be system dependent. Therefore the module Utils is a relative of the module SYSTEM. The import of Utils is an indicator that the program using it is non-portable
\par \plain\f2\fs24\b Procedures
\par \plain\f2\fs20\cf1\strike BitAnd\plain\f2\fs20 Utils_BitAnd
\par \plain\f2\fs20\cf1\strike BitXOr\plain\f2\fs20 Utils_BitXOr
\par \plain\f2\fs20\cf1\strike BitOr\plain\f2\fs20 Utils_BitOr
\par \plain\f2\fs20\cf1\strike BitNot\plain\f2\fs20 Utils_BitNot
\par \plain\f2\fs20\cf1\strike BitAndL\plain\f2\fs20 Utils_BitAndL
\par \plain\f2\fs20\cf1\strike BitXOrL\plain\f2\fs20 Utils_BitXOrL
\par \plain\f2\fs20\cf1\strike BitOrL\plain\f2\fs20 Utils_BitOrL
\par \plain\f2\fs20\cf1\strike BitNotL\plain\f2\fs20 Utils_BitNotL
\par \plain\f2\fs20\cf1\strike LoWord\plain\f2\fs20 Utils_LoWord
\par \plain\f2\fs20\cf1\strike HiWord\plain\f2\fs20 Utils_HiWord
\par \plain\f2\fs20\cf1\strike LoByte\plain\f2\fs20 Utils_LoByte
\par \plain\f2\fs20\cf1\strike HiByte\plain\f2\fs20 Utils_HiByte
\par \plain\f2\fs20\cf1\strike MakeLong\plain\f2\fs20 Utils_MakeLong
\par \plain\f2\fs20\cf1\strike MakeWord\plain\f2\fs20 Utils_MakeWord
\par \plain\f2\fs20\cf1\strike GetDate\plain\f2\fs20 Utils_GetDate
\par \plain\f2\fs20\cf1\strike GetTime\plain\f2\fs20 Utils_GetTime
\par \plain\f2\fs20\cf1\strike GetDateStr\plain\f2\fs20 Utils_GetDateStr
\par \plain\f2\fs20\cf1\strike GetTimeStr\plain\f2\fs20 Utils_GetTimeStr
\par \plain\f2\fs19\b\up14 #$K\plain\f2\fs28\b BitAnd
\par \plain\f2\fs20\b defined in module \plain\f2\fs20\cf1\b\strike Utils\plain\f2\fs20\b Utils
\par \plain\f2\fs24\b Syntax
\par \plain\f5\fs20 PROCEDURE BitAnd(a, b:INTEGER):INTEGER
\par \plain\f2\fs19\b\up14 #$K\plain\f2\fs28\b BitXOr
\par \plain\f2\fs20\b defined in module \plain\f2\fs20\cf1\b\strike Utils\plain\f2\fs20\b Utils
\par \plain\f2\fs24\b Syntax
\par \plain\f5\fs20 PROCEDURE BitXOr(a, b:INTEGER):INTEGER
\par \plain\f2\fs19\b\up14 #$K\plain\f2\fs28\b BitOr
\par \plain\f2\fs20\b defined in module \plain\f2\fs20\cf1\b\strike Utils\plain\f2\fs20\b Utils
\par \plain\f2\fs24\b Syntax
\par \plain\f5\fs20 PROCEDURE BitOr(a, b:INTEGER):INTEGER
\par \plain\f2\fs19\b\up14 #$K\plain\f2\fs28\b BitNot
\par \plain\f2\fs20\b defined in module \plain\f2\fs20\cf1\b\strike Utils\plain\f2\fs20\b Utils
\par \plain\f2\fs24\b Syntax
\par \plain\f5\fs20 PROCEDURE BitNot(a:INTEGER):INTEGER
\par \plain\f2\fs19\b\up14 #$K\plain\f2\fs28\b BitAndL
\par \plain\f2\fs20\b defined in module \plain\f2\fs20\cf1\b\strike Utils\plain\f2\fs20\b Utils
\par \plain\f2\fs24\b Syntax
\par \plain\f5\fs20 PROCEDURE BitAndL(a, b:LONGINT):LONGINT
\par \plain\f2\fs19\b\up14 #$K\plain\f2\fs28\b BitXOrL
\par \plain\f2\fs20\b defined in module \plain\f2\fs20\cf1\b\strike Utils\plain\f2\fs20\b Utils
\par \plain\f2\fs24\b Syntax
\par \plain\f5\fs20 PROCEDURE BitXOrL(a, b:LONGINT):LONGINT
\par \plain\f2\fs19\b\up14 #$K\plain\f2\fs28\b BitOrL
\par \plain\f2\fs20\b defined in module \plain\f2\fs20\cf1\b\strike Utils\plain\f2\fs20\b Utils
\par \plain\f2\fs24\b Syntax
\par \plain\f5\fs20 PROCEDURE BitOrL(a, b:LONGINT):LONGINT
\par \plain\f2\fs19\b\up14 #$K\plain\f2\fs28\b BitNotL
\par \plain\f2\fs20\b defined in module \plain\f2\fs20\cf1\b\strike Utils\plain\f2\fs20\b Utils
\par \plain\f2\fs24\b Syntax
\par \plain\f5\fs20 PROCEDURE BitNotL(a:LONGINT):LONGINT
\par \plain\f2\fs19\b\up14 #$K\plain\f2\fs28\b LoWord
\par \plain\f2\fs20\b defined in module \plain\f2\fs20\cf1\b\strike Utils\plain\f2\fs20\b Utils
\par \plain\f2\fs24\b Syntax
\par \plain\f5\fs20 PROCEDURE LoWord(x:LONGINT):INTEGER
\par \plain\f2\fs19\b\up14 #$K\plain\f2\fs28\b HiWord
\par \plain\f2\fs20\b defined in module \plain\f2\fs20\cf1\b\strike Utils\plain\f2\fs20\b Utils
\par \plain\f2\fs24\b Syntax
\par \plain\f5\fs20 PROCEDURE HiWord(x:LONGINT):INTEGER
\par \plain\f2\fs19\b\up14 #$K\plain\f2\fs28\b LoByte
\par \plain\f2\fs20\b defined in module \plain\f2\fs20\cf1\b\strike Utils\plain\f2\fs20\b Utils
\par \plain\f2\fs24\b Syntax
\par \plain\f5\fs20 PROCEDURE LoByte(x:INTEGER):CHAR
\par \plain\f2\fs19\b\up14 #$K\plain\f2\fs28\b HiByte
\par \plain\f2\fs20\b defined in module \plain\f2\fs20\cf1\b\strike Utils\plain\f2\fs20\b Utils
\par \plain\f2\fs24\b Syntax
\par \plain\f5\fs20 PROCEDURE HiByte(x:INTEGER):CHAR
\par \plain\f2\fs19\b\up14 #$K\plain\f2\fs28\b MakeLong
\par \plain\f2\fs20\b defined in module \plain\f2\fs20\cf1\b\strike Utils\plain\f2\fs20\b Utils
\par \plain\f2\fs24\b Syntax
\par \plain\f5\fs20 PROCEDURE MakeLong(hi, lo:INTEGER):LONGINT
\par \plain\f2\fs19\b\up14 #$K\plain\f2\fs28\b MakeWord
\par \plain\f2\fs20\b defined in module \plain\f2\fs20\cf1\b\strike Utils\plain\f2\fs20\b Utils
\par \plain\f2\fs24\b Syntax
\par \plain\f5\fs20 PROCEDURE MakeWord(hi, lo:CHAR):INTEGER
\par \plain\f2\fs19\b\up14 #$K\plain\f2\fs28\b GetDate
\par \plain\f2\fs20\b defined in module \plain\f2\fs20\cf1\b\strike Utils\plain\f2\fs20\b Utils
\par \plain\f2\fs24\b Syntax
\par \plain\f5\fs20 PROCEDURE GetDate(VAR day, month, year, dayOfWeek:INTEGER)
\par \plain\f2\fs19\b\up14 #$K\plain\f2\fs28\b GetTime
\par \plain\f2\fs20\b defined in module \plain\f2\fs20\cf1\b\strike Utils\plain\f2\fs20\b Utils
\par \plain\f2\fs24\b Syntax
\par \plain\f5\fs20 PROCEDURE GetTime(VAR sec, min, hour:INTEGER)
\par \plain\f2\fs19\b\up14 #$K\plain\f2\fs28\b GetDateStr
\par \plain\f2\fs20\b defined in module \plain\f2\fs20\cf1\b\strike Utils\plain\f2\fs20\b Utils
\par \plain\f2\fs24\b Syntax
\par \plain\f5\fs20 PROCEDURE GetDateStr(VAR t:ARRAY OF CHAR)
\par \plain\f2\fs19\b\up14 #$K\plain\f2\fs28\b GetTimeStr
\par \plain\f2\fs20\b defined in module \plain\f2\fs20\cf1\b\strike Utils\plain\f2\fs20\b Utils
\par \plain\f2\fs24\b Syntax
\par \plain\f5\fs20 PROCEDURE GetTimeStr(VAR t:ARRAY OF CHAR)
\par \plain\f2\fs19\b\up14 #$K\plain\f2\fs28\b Module Volume
\par \plain\f2\fs20 The Volume module provides facilities for creating, searching, and modifying file directories.
\par \plain\f2\fs24\b Constants
\par \pard\li2880\fi-2880\plain\f2\fs20 MAXPATH\tab \tab \tab 
\par MAXFILENAME\tab \tab 
\par \pard\plain\f2\fs20\b Error Codes 
\par \pard\li2880\fi-2880\plain\f2\fs20 NOERROR\tab \tab \tab the operation was successfull              
\par WRITEPROTECTED\tab \tab attempted write to a write-protected drive 
\par PATHNOTFOUND\tab \tab the stated path could not be found         
\par INVALIDDRIVE\tab \tab \tab the indicated drive could not be found     
\par NOMOREFILES\tab \tab no further suitable files could be found 
\par \pard\plain\f2\fs20\b File Attributes 
\par \pard\li2880\fi-2880\plain\f2\fs20 ATTRREADONLY\tab \tab the file is read-only                     
\par ATTRHIDDEN\tab \tab \tab the file is hidden                        
\par ATTRSYSTEM\tab \tab \tab the file is part of the operating system  
\par ATTRVOLUME\tab \tab \tab maintained for compatibility only         
\par ATTRDIR\tab \tab \tab file entry is really a directory          
\par ATTRARCHIVE\tab \tab \tab file marked for backup                    
\par ATTRNORMAL\tab \tab \tab a plain file with no other attributes set 
\par ATTRTEMP\tab \tab \tab the file is used for temporary storage    
\par ATTRCOMPRESSED\tab \tab the file or directory is compressed       
\par ATTROFFLINE\tab \tab \tab file currently physically unavailable     
\par \pard\plain\f2\fs24\b Types
\par \plain\f2\fs20\cf1\ul ScanP\plain\f2\fs20 Volume_ScanP
\par \plain\f2\fs20\cf1\ul RetCodeT\plain\f2\fs20 Volume_RetCodeT
\par \plain\f2\fs24\b Classes / Record Types
\par \plain\f2\fs20\cf1\strike Scan\plain\f2\fs20 Volume_Scan
\par \plain\f2\fs24\b Procedures
\par \plain\f2\fs20\cf1\strike GetErrorMessage\plain\f2\fs20 Volume_GetErrorMessage
\par \plain\f2\fs20\cf1\strike CurrentDirectory\plain\f2\fs20 Volume_CurrentDirectory
\par \plain\f2\fs20\cf1\strike ChangeDirectory\plain\f2\fs20 Volume_ChangeDirectory
\par \plain\f2\fs20\cf1\strike CreateDirectory\plain\f2\fs20 Volume_CreateDirectory
\par \plain\f2\fs20\cf1\strike RemoveDirectory\plain\f2\fs20 Volume_RemoveDirectory
\par \plain\f2\fs20\cf1\strike FreeSpace\plain\f2\fs20 Volume_FreeSpace
\par \plain\f2\fs20\cf1\strike TotalSpace\plain\f2\fs20 Volume_TotalSpace
\par \plain\f2\fs19\b\up14 #$K\plain\f2\fs28\b GetErrorMessage
\par \plain\f2\fs20\b defined in module \plain\f2\fs20\cf1\b\strike Volume\plain\f2\fs20\b Volume
\par \plain\f2\fs24\b Syntax
\par \plain\f5\fs20 PROCEDURE GetErrorMessage(error:\plain\f5\fs20\cf1\ul RetCodeT\plain\f5\fs20 Volume_RetCodeT; 
\par                           VAR message:ARRAY OF CHAR)
\par \plain\f2\fs19\b\up14 #$K\plain\f2\fs28\b CurrentDirectory
\par \plain\f2\fs20\b defined in module \plain\f2\fs20\cf1\b\strike Volume\plain\f2\fs20\b Volume
\par \plain\f2\fs24\b Syntax
\par \plain\f5\fs20 PROCEDURE CurrentDirectory(VAR dir:ARRAY OF CHAR; 
\par                            VAR resCode:\plain\f5\fs20\cf1\ul RetCodeT\plain\f5\fs20 Volume_RetCodeT)
\par \plain\f2\fs24\b Description
\par \plain\f2\fs20 The interface has changed from OPAL 16 bit: the drive is no longer a parameter of this function. 
\par \plain\f2\fs19\b\up14 #$K\plain\f2\fs28\b ChangeDirectory
\par \plain\f2\fs20\b defined in module \plain\f2\fs20\cf1\b\strike Volume\plain\f2\fs20\b Volume
\par \plain\f2\fs24\b Syntax
\par \plain\f5\fs20 PROCEDURE ChangeDirectory(dir:ARRAY OF CHAR; 
\par                           VAR resCode:\plain\f5\fs20\cf1\ul RetCodeT\plain\f5\fs20 Volume_RetCodeT)
\par \plain\f2\fs19\b\up14 #$K\plain\f2\fs28\b CreateDirectory
\par \plain\f2\fs20\b defined in module \plain\f2\fs20\cf1\b\strike Volume\plain\f2\fs20\b Volume
\par \plain\f2\fs24\b Syntax
\par \plain\f5\fs20 PROCEDURE CreateDirectory(dir:ARRAY OF CHAR; 
\par                           VAR resCode:\plain\f5\fs20\cf1\ul RetCodeT\plain\f5\fs20 Volume_RetCodeT)
\par \plain\f2\fs19\b\up14 #$K\plain\f2\fs28\b RemoveDirectory
\par \plain\f2\fs20\b defined in module \plain\f2\fs20\cf1\b\strike Volume\plain\f2\fs20\b Volume
\par \plain\f2\fs24\b Syntax
\par \plain\f5\fs20 PROCEDURE RemoveDirectory(dir:ARRAY OF CHAR; 
\par                           VAR resCode:\plain\f5\fs20\cf1\ul RetCodeT\plain\f5\fs20 Volume_RetCodeT)
\par \plain\f2\fs19\b\up14 #$K\plain\f2\fs28\b FreeSpace
\par \plain\f2\fs20\b defined in module \plain\f2\fs20\cf1\b\strike Volume\plain\f2\fs20\b Volume
\par \plain\f2\fs24\b Syntax
\par \plain\f5\fs20 PROCEDURE FreeSpace(drive:ARRAY OF CHAR; 
\par                     VAR space:LONGINT; 
\par                     VAR unit:LONGINT; 
\par                     VAR resCode:\plain\f5\fs20\cf1\ul RetCodeT\plain\f5\fs20 Volume_RetCodeT)
\par \plain\f2\fs24\b Parameters
\par \pard\li2880\fi-2880\plain\f2\fs20 unit\tab \tab \tab \tab \plain\f2\fs20\b unit\plain\f2\fs20  determins the unit used for the number returned in \plain\f2\fs20\b space\plain\f2\fs20 . The returned value is either 1 for 1 byte or 1024 for kBytes. The smallest possible unit is used which still allows \plain\f2\fs20\b space\plain\f2\fs20  to be expressed as a LONGINT. 
\par \pard\plain\f2\fs19\b\up14 #$K\plain\f2\fs28\b TotalSpace
\par \plain\f2\fs20\b defined in module \plain\f2\fs20\cf1\b\strike Volume\plain\f2\fs20\b Volume
\par \plain\f2\fs24\b Syntax
\par \plain\f5\fs20 PROCEDURE TotalSpace(drive:ARRAY OF CHAR; 
\par                      VAR space:LONGINT; 
\par                      VAR unit:LONGINT; 
\par                      VAR resCode:\plain\f5\fs20\cf1\ul RetCodeT\plain\f5\fs20 Volume_RetCodeT)
\par \plain\f2\fs24\b Parameters
\par \pard\li2880\fi-2880\plain\f2\fs20 unit\tab \tab \tab \tab \plain\f2\fs20\b unit\plain\f2\fs20  determins the unit used for the number returned in \plain\f2\fs20\b space\plain\f2\fs20 . The returned value is either 1 for 1 byte or 1024 for kBytes. The smallest possible unit is used which still allows \plain\f2\fs20\b space\plain\f2\fs20  to be expressed as a LONGINT. 
\par \pard\plain\f2\fs13\up10 #$K\plain\f2\fs20\b ScanP\plain\f2\fs20 
\par \plain\f5\fs20 ScanP*=POINTER TO \plain\f5\fs20\cf1\strike Scan\plain\f5\fs20 Volume_Scan;
\par \plain\f2\fs13\up10 #$K\plain\f2\fs20\b RetCodeT\plain\f2\fs20 
\par \plain\f5\fs20 RetCodeT*=INTEGER;
\par \plain\f2\fs19\b\up14 #$K\plain\f2\fs28\b Scan
\par \plain\f2\fs20\b defined in module \plain\f2\fs20\cf1\b\strike Volume\plain\f2\fs20\b Volume
\par \plain\f2\fs24\b Syntax
\par \plain\f5\fs20 Scan=RECORD 
\par END;
\par \plain\f2\fs24\b Methods
\par \plain\f2\fs20\cf1\strike First\plain\f2\fs20 Volume_Scan_First
\par \plain\f2\fs20\cf1\strike Next\plain\f2\fs20 Volume_Scan_Next
\par \plain\f2\fs20\cf1\strike GetName\plain\f2\fs20 Volume_Scan_GetName
\par \plain\f2\fs20\cf1\strike GetCreationDate\plain\f2\fs20 Volume_Scan_GetCreationDate
\par \plain\f2\fs20\cf1\strike GetModifyDate\plain\f2\fs20 Volume_Scan_GetModifyDate
\par \plain\f2\fs20\cf1\strike GetAccessDate\plain\f2\fs20 Volume_Scan_GetAccessDate
\par \plain\f2\fs20\cf1\strike GetAttr\plain\f2\fs20 Volume_Scan_GetAttr
\par \plain\f2\fs20\cf1\strike GetSize\plain\f2\fs20 Volume_Scan_GetSize
\par \plain\f2\fs19\b\up14 #$K\plain\f2\fs28\b First
\par \plain\f2\fs20\b defined in module \plain\f2\fs20\cf1\b\strike Volume\plain\f2\fs20\b Volume, bound to type \plain\f2\fs20\cf1\b\strike Scan\plain\f2\fs20\b Volume_Scan
\par \plain\f2\fs24\b Syntax
\par \plain\f5\fs20 PROCEDURE (VAR) First(searchName:ARRAY OF CHAR; 
\par                       VAR resCode:\plain\f5\fs20\cf1\ul RetCodeT\plain\f5\fs20 Volume_RetCodeT)
\par \plain\f2\fs19\b\up14 #$K\plain\f2\fs28\b Next
\par \plain\f2\fs20\b defined in module \plain\f2\fs20\cf1\b\strike Volume\plain\f2\fs20\b Volume, bound to type \plain\f2\fs20\cf1\b\strike Scan\plain\f2\fs20\b Volume_Scan
\par \plain\f2\fs24\b Syntax
\par \plain\f5\fs20 PROCEDURE (VAR) Next(VAR resCode:\plain\f5\fs20\cf1\ul RetCodeT\plain\f5\fs20 Volume_RetCodeT)
\par \plain\f2\fs19\b\up14 #$K\plain\f2\fs28\b GetName
\par \plain\f2\fs20\b defined in module \plain\f2\fs20\cf1\b\strike Volume\plain\f2\fs20\b Volume, bound to type \plain\f2\fs20\cf1\b\strike Scan\plain\f2\fs20\b Volume_Scan
\par \plain\f2\fs24\b Syntax
\par \plain\f5\fs20 PROCEDURE (VAR) GetName(VAR fileName:ARRAY OF CHAR)
\par \plain\f2\fs19\b\up14 #$K\plain\f2\fs28\b GetCreationDate
\par \plain\f2\fs20\b defined in module \plain\f2\fs20\cf1\b\strike Volume\plain\f2\fs20\b Volume, bound to type \plain\f2\fs20\cf1\b\strike Scan\plain\f2\fs20\b Volume_Scan
\par \plain\f2\fs24\b Syntax
\par \plain\f5\fs20 PROCEDURE (VAR) GetCreationDate(VAR dateStr:ARRAY OF CHAR)
\par \plain\f2\fs19\b\up14 #$K\plain\f2\fs28\b GetModifyDate
\par \plain\f2\fs20\b defined in module \plain\f2\fs20\cf1\b\strike Volume\plain\f2\fs20\b Volume, bound to type \plain\f2\fs20\cf1\b\strike Scan\plain\f2\fs20\b Volume_Scan
\par \plain\f2\fs24\b Syntax
\par \plain\f5\fs20 PROCEDURE (VAR) GetModifyDate(VAR dateStr:ARRAY OF CHAR)
\par \plain\f2\fs19\b\up14 #$K\plain\f2\fs28\b GetAccessDate
\par \plain\f2\fs20\b defined in module \plain\f2\fs20\cf1\b\strike Volume\plain\f2\fs20\b Volume, bound to type \plain\f2\fs20\cf1\b\strike Scan\plain\f2\fs20\b Volume_Scan
\par \plain\f2\fs24\b Syntax
\par \plain\f5\fs20 PROCEDURE (VAR) GetAccessDate(VAR dateStr:ARRAY OF CHAR)
\par \plain\f2\fs19\b\up14 #$K\plain\f2\fs28\b GetAttr
\par \plain\f2\fs20\b defined in module \plain\f2\fs20\cf1\b\strike Volume\plain\f2\fs20\b Volume, bound to type \plain\f2\fs20\cf1\b\strike Scan\plain\f2\fs20\b Volume_Scan
\par \plain\f2\fs24\b Syntax
\par \plain\f5\fs20 PROCEDURE (VAR) GetAttr():SET
\par \plain\f2\fs19\b\up14 #$K\plain\f2\fs28\b GetSize
\par \plain\f2\fs20\b defined in module \plain\f2\fs20\cf1\b\strike Volume\plain\f2\fs20\b Volume, bound to type \plain\f2\fs20\cf1\b\strike Scan\plain\f2\fs20\b Volume_Scan
\par \plain\f2\fs24\b Syntax
\par \plain\f5\fs20 PROCEDURE (VAR) GetSize():LONGINT
\par \plain\f2\fs19\b\up14 #$K\plain\f2\fs28\b Module XYplane
\par \plain\f2\fs20 This module supports very simple, monochrome graphics.
\par \plain\f2\fs24\b Constants
\par \pard\li2880\fi-2880\plain\f2\fs20 erase\tab \tab \tab \tab 
\par draw\tab \tab \tab \tab 
\par \pard\plain\f2\fs24\b Variables
\par \plain\f2\fs20\cf1\ul X\plain\f2\fs20 XYplane_X
\par \plain\f2\fs20\cf1\ul Y\plain\f2\fs20 XYplane_Y
\par \plain\f2\fs20\cf1\ul W\plain\f2\fs20 XYplane_W
\par \plain\f2\fs20\cf1\ul H\plain\f2\fs20 XYplane_H
\par \plain\f2\fs24\b Procedures
\par \plain\f2\fs20\cf1\strike Open\plain\f2\fs20 XYplane_Open
\par \plain\f2\fs20\cf1\strike Close\plain\f2\fs20 XYplane_Close
\par \plain\f2\fs20\cf1\strike Dot\plain\f2\fs20 XYplane_Dot
\par \plain\f2\fs20\cf1\strike IsDot\plain\f2\fs20 XYplane_IsDot
\par \plain\f2\fs20\cf1\strike Key\plain\f2\fs20 XYplane_Key
\par \plain\f2\fs20\cf1\strike Clear\plain\f2\fs20 XYplane_Clear
\par \plain\f2\fs19\b\up14 #$K\plain\f2\fs28\b Open
\par \plain\f2\fs20\b defined in module \plain\f2\fs20\cf1\b\strike XYplane\plain\f2\fs20\b XYplane
\par \plain\f2\fs24\b Syntax
\par \plain\f5\fs20 PROCEDURE Open()
\par \plain\f2\fs19\b\up14 #$K\plain\f2\fs28\b Close
\par \plain\f2\fs20\b defined in module \plain\f2\fs20\cf1\b\strike XYplane\plain\f2\fs20\b XYplane
\par \plain\f2\fs24\b Syntax
\par \plain\f5\fs20 PROCEDURE Close()
\par \plain\f2\fs19\b\up14 #$K\plain\f2\fs28\b Dot
\par \plain\f2\fs20\b defined in module \plain\f2\fs20\cf1\b\strike XYplane\plain\f2\fs20\b XYplane
\par \plain\f2\fs24\b Syntax
\par \plain\f5\fs20 PROCEDURE Dot(x, y, mode:INTEGER)
\par \plain\f2\fs19\b\up14 #$K\plain\f2\fs28\b IsDot
\par \plain\f2\fs20\b defined in module \plain\f2\fs20\cf1\b\strike XYplane\plain\f2\fs20\b XYplane
\par \plain\f2\fs24\b Syntax
\par \plain\f5\fs20 PROCEDURE IsDot(x, y:INTEGER):BOOLEAN
\par \plain\f2\fs19\b\up14 #$K\plain\f2\fs28\b Key
\par \plain\f2\fs20\b defined in module \plain\f2\fs20\cf1\b\strike XYplane\plain\f2\fs20\b XYplane
\par \plain\f2\fs24\b Syntax
\par \plain\f5\fs20 PROCEDURE Key():CHAR
\par \plain\f2\fs19\b\up14 #$K\plain\f2\fs28\b Clear
\par \plain\f2\fs20\b defined in module \plain\f2\fs20\cf1\b\strike XYplane\plain\f2\fs20\b XYplane
\par \plain\f2\fs24\b Syntax
\par \plain\f5\fs20 PROCEDURE Clear()
\par \plain\f2\fs13\up10 #$K\plain\f2\fs20\b X\plain\f2\fs20 
\par \plain\f5\fs20 X-:INTEGER;
\par \plain\f2\fs13\up10 #$K\plain\f2\fs20\b Y\plain\f2\fs20 
\par \plain\f5\fs20 Y-:INTEGER;
\par \plain\f2\fs13\up10 #$K\plain\f2\fs20\b W\plain\f2\fs20 
\par \plain\f5\fs20 W-:INTEGER;
\par \plain\f2\fs13\up10 #$K\plain\f2\fs20\b H\plain\f2\fs20 
\par \plain\f5\fs20 H-:INTEGER;
\par 
\par \plain\lang2057\f2\fs20 
\par }
 