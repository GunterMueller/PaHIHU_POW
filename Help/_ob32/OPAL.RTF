{\rtf1\ansi\deff0 
{\colortbl;
\red0\green0\blue0;
\red255\green255\blue255;
\red0\green0\blue255;
\red0\green255\blue255;
\red0\green155\blue0;
\red255\green0\blue255;
\red255\green0\blue0;
\red255\green255\blue0;
}
{\fonttbl
{\f0\froman\fcharset0\fprq2 Times New Roman;}
{\f1\fswiss\fcharset0\fprq2 Arial;}
{\f2\fmodern\fcharset0\fprq1 Courier New;}
{\f3\fnil\fcharset2\fprq2 Wingdings;}
}
{\stylesheet
{\s0\plain\sb6\f1\lang1031\ql\fs20 \snext0 Normal;}
{\s1\sb0\keep\keepn\pagebb{\*\pn \pnlvl1\pndec\pnprev1\pnstart1\pnsp144\pnhang{\pntxta .}}\b\f1\fs40 
\sbasedon0\snext0 heading 1;}
{\s2\plain\sb480\keep\keepn{\*\pn \pnlvl2\pndec\pnprev1\pnstart1\pnsp144\pnhang}\b\f1\fs36 
\sbasedon0\snext0 heading 2;}
{\s3\plain\sb360\keep\keepn{\*\pn \pnlvl3\pndec\pnprev1\pnstart1\pnsp144\pnhang{\pntxtb .}}\b\f1\fs28 
\sbasedon0\snext0 heading 3;}
{\s4\plain\sb360\keep\keepn{\*\pn \pnlvl4\pnstart1\pnsp144 }\b\f1 \sbasedon0\snext0 heading 4;}

{\s5\plain\li567\sb360\keep\keepn{\*\pn \pnlvl5\pnstart1\pnsp144 }\b\f1 \sbasedon0\snext0 heading 5;}

{\s6\plain\li567\sb240\keep\keepn{\*\pn \pnlvl6\pnstart1\pnsp144 }\i\f1 \sbasedon0\snext0 heading 6;}

{\s10\tqc\tx4819\tqr\tx9071\f1 \sbasedon0\snext0 footer;}
{\*\cs11\additive\sbasedon0 page number;}
{\s20\plain\li567\sb120\tx1702\f2 \sbasedon0\snext20 source;}
{\s21\plain\f1\sb120 \sbasedon0\snext21  descr;}
{\s22\plain\f1\li567\sb120 \sbasedon0\snext22 procdescr;}
{\s23\plain\f1\sb60\keep\keepn\fi-2835\li3402 \sbasedon0\snext23 parameter;}
{\s24\plain\f1\fi-2835\li3402\sb120\keep \sbasedon0\snext24 constant;}
{\s25\plain\f1\li567\sb120 \sbasedon0\snext25 method;}
{\s26\plain\f1\fi-2835\li3402\sb120\keep\keepn \sbasedon0\snext26 variable;}
{\s27\plain\li0\sb120\tx1702\f2\fs20 \sbasedon0\snext27 helpsource;}
{\s28\plain\li0\sb120\sa120\keepn\f1\fs28\b \sbasedon0\snext27 helpheading1;}
{\s29\plain\li0\sb180\f1\fs24\b \sbasedon0\snext28 helpheading2;}
{\s30\plain\li0\sb60\f1\fs20 \sbasedon0\snext29 helpNormal;}
{\s31\plain\li0\sb120\sa120\f1\fs20\b \sbasedon0\snext31 helpModuleRef;}
{\s32\plain\f1\fs20\sb60\fi-2880\li2880 \sbasedon0\snext32 help Parameter;}
{\s33\plain\li0\sb160\f1\fs22\b \sbasedon0\snext33 helpheading3;}
{\s34\plain\li0\sb90\f1\fs20\b \sbasedon0\snext30 helpNormal;}
{\s100\sb6\tqc\tx4536\tqr\tx9072 \f1\fs12 \sbasedon0\snext0 header;}{\s101\sb360\tqr\tx9077 \b\caps\f1\fs28 \sbasedon0\snext0 toc 1;}
{\s102\sb240\tqr\tx9077 \b\f1 \sbasedon0\snext0 toc 2;}{\s103\tqr\tx9077 \f1 \sbasedon0\snext0 toc 3;}
{\s104\li360\tqr\tx9077 \f1\fs20 \sbasedon0\snext0 toc 4;}{\s105\li480\tqr\tx9077 \f1\fs20 \sbasedon0\snext0 toc 5;}
{\s106\li600\tqr\tx9077 \f1\fs20 \sbasedon0\snext0 toc 6;}{\s107\li720\tqr\tx9077 \f1\fs20 \sbasedon0\snext0 toc 7;}
{\s108\li840\tqr\tx9077 \f1\fs20 \sbasedon0\snext0 toc 8;}{\s109\li960\tqr\tx9077 \f1\fs20 \sbasedon0\snext0 toc 9;}
{\s110\keepn\fi-120\li120\tqr\tldot\tx4178 \f1\fs20 \sbasedon0\snext0 index 1;}{\s111\fi-120\li240\tqr\tldot\tx4178 \f1\fs20 \sbasedon0\snext0 index 2;}
{\s112\fi-120\li360\tqr\tldot\tx4178 \f1\fs20 \sbasedon0\snext0 index 3;}{\s113\fi-120\li480\tqr\tldot\tx4178 \f1\fs20 \sbasedon0\snext0 index 4;}
{\s114\fi-120\li600\tqr\tldot\tx4178 \f1\fs20 \sbasedon0\snext0 index 5;}{\s115\fi-120\li720\tqr\tldot\tx4178 \f1\fs20 \sbasedon0\snext0 index 6;}
{\s116\fi-120\li840\tqr\tldot\tx4178 \f1\fs20 \sbasedon0\snext0 index 7;}{\s117\fi-120\li960\tqr\tldot\tx4178 \f1\fs20 \sbasedon0\snext0 index 8;}
{\s118\fi-120\li1080\tqr\tldot\tx4178 \f1\fs20 \sbasedon0\snext0 index 9;}{\s119\keepn\sb120\sa120\keepn \b\f1\fs28 \sbasedon0\snext0 index heading;}
}
\paperw11913\paperh16834\margl1418\margr1418\margt1418\margb1134\fet0
\ftntj
{\ {\super #}\footnote \pard\plain{\super #}contents}{\ {\super $}\footnote \pard\plain{\super 
$}contents}{\ {\super K}\footnote \pard\plain{\super K}contents}\pard\s28\plain\li0\sb120\sa120\keepn\f1\fs28\b 
Contents\par
\pard\s30\plain\li0\sb60\f1\fs20 {\strike\cf5 module Display}{\v Display}\par
{\strike\cf5 module File}{\v File}\par
{\strike\cf5 module Float}{\v Float}\par
{\strike\cf5 module In}{\v In}\par
{\strike\cf5 module OOBase}{\v OOBase}\par
{\strike\cf5 module Out}{\v Out}\par
{\strike\cf5 module Param}{\v Param}\par
{\strike\cf5 module Print}{\v Print}\par
{\strike\cf5 module Process}{\v Process}\par
{\strike\cf5 module Strings}{\v Strings}\par
{\strike\cf5 module Utils}{\v Utils}\par
{\strike\cf5 module Volume}{\v Volume}\par
{\strike\cf5 module XYplane}{\v XYplane}\par
{\strike\cf5 module ColorPlane}{\v ColorPlane}\par
\page
{\ {\super #}\footnote \pard\plain{\super #}Display}{\ {\super $}\footnote \pard\plain{\super 
$}module Display}{\ {\super K}\footnote \pard\plain{\super K}Display}\pard\s28\plain\li0\sb120\sa120\keepn\f1\fs28\b 
Module Display\par
\pard\s30\plain\li0\sb60\f1\fs20 This module provides a simple, text-oriented user interface. It is an easy
 to understand basis especially for programmers just starting to use Oberon-2. Its main purpose is to make it easy to display text from a Windows program.
 As far as its features are concerned it is adapted to the possibilities of usual devices operating in the text mode.
\par
In this implementation a window is used for displaying up to 80 characters and 25 lines with a non-proportional font. If the size of the window is
 reduced any desired section of the whole window can be viewed using scroll bars.
\par
All procedures for input and output access a virtual text screen with 80 characters and 25 lines. This text screen is called virtual because all
 functions are described in a way as if they controlled the complete screen operated in text mode. The actual implementation details are hidden from
 the programmer.\par
The character positions of the usable area can be directly referenced by their line and column position. The character in the left top corner has
 the position column one, line one by convention.\par
For positioning the input and output, a special mark called the cursor may be positioned anywhere by calling the appropriate procedures, and appears
 as a flashing mark on the screen. It may also be hidden; when invisible its position is still maintained on the virtual screen.
\par
There are two groups of output procedures. One group is characterized by procedure names ending with "XY" and can be used for output at any position.
 The second group of procedures serves for output at the current cursor position; after the output has taken place the cursor is moved on. When
 the program is started the cursor is always initialized at the left top corner.\par

Output that would go over the end of the line is continued on the next line. If this happens in the last line or if a line feed with WriteLn is executed
 in the last line, the whole screen contents is moved up one line. The new "last" line is now empty and may be used for further output, while the old
 "first" line is lost.\par
All input procedures expect input typed at the current cursor position. Input functions with a parameter resCode return a code which represents
 the character used to terminate the input (e.g., enter or escape key).\par
\pard\s29\plain\li0\sb180\f1\fs24\b Constants\par
\pard\s32\plain\f1\fs20\sb60\fi-2880\li2880 CURSUP\tab
\tab
\tab
\par
\pard\s32\plain\f1\fs20\sb60\fi-2880\li2880 CURSDOWN\tab
\tab
\par
\pard\s32\plain\f1\fs20\sb60\fi-2880\li2880 CURSLEFT\tab
\tab
\par
\pard\s32\plain\f1\fs20\sb60\fi-2880\li2880 CURSRIGHT\tab
\tab
\par
\pard\s32\plain\f1\fs20\sb60\fi-2880\li2880 INSERT\tab
\tab
\tab
\par
\pard\s32\plain\f1\fs20\sb60\fi-2880\li2880 DELETE\tab
\tab
\tab
\par
\pard\s32\plain\f1\fs20\sb60\fi-2880\li2880 HOME\tab
\tab
\tab
\par
\pard\s32\plain\f1\fs20\sb60\fi-2880\li2880 ENDKEY\tab
\tab
\tab
\par
\pard\s32\plain\f1\fs20\sb60\fi-2880\li2880 PAGEUP\tab
\tab
\tab
\par
\pard\s32\plain\f1\fs20\sb60\fi-2880\li2880 PAGEDOWN\tab
\tab
\par
\pard\s32\plain\f1\fs20\sb60\fi-2880\li2880 F1\tab
\tab
\tab
\tab
\par
\pard\s32\plain\f1\fs20\sb60\fi-2880\li2880 F2\tab
\tab
\tab
\tab
\par
\pard\s32\plain\f1\fs20\sb60\fi-2880\li2880 F3\tab
\tab
\tab
\tab
\par
\pard\s32\plain\f1\fs20\sb60\fi-2880\li2880 F4\tab
\tab
\tab
\tab
\par
\pard\s32\plain\f1\fs20\sb60\fi-2880\li2880 F5\tab
\tab
\tab
\tab
\par
\pard\s32\plain\f1\fs20\sb60\fi-2880\li2880 F6\tab
\tab
\tab
\tab
\par
\pard\s32\plain\f1\fs20\sb60\fi-2880\li2880 F7\tab
\tab
\tab
\tab
\par
\pard\s32\plain\f1\fs20\sb60\fi-2880\li2880 F8\tab
\tab
\tab
\tab
\par
\pard\s32\plain\f1\fs20\sb60\fi-2880\li2880 F9\tab
\tab
\tab
\tab
\par
\pard\s32\plain\f1\fs20\sb60\fi-2880\li2880 F10\tab
\tab
\tab
\tab
\par
\pard\s32\plain\f1\fs20\sb60\fi-2880\li2880 F11\tab
\tab
\tab
\tab
\par
\pard\s32\plain\f1\fs20\sb60\fi-2880\li2880 F12\tab
\tab
\tab
\tab
\par
\pard\s32\plain\f1\fs20\sb60\fi-2880\li2880 F13\tab
\tab
\tab
\tab
\par
\pard\s32\plain\f1\fs20\sb60\fi-2880\li2880 F14\tab
\tab
\tab
\tab
\par
\pard\s32\plain\f1\fs20\sb60\fi-2880\li2880 F15\tab
\tab
\tab
\tab
\par
\pard\s32\plain\f1\fs20\sb60\fi-2880\li2880 F16\tab
\tab
\tab
\tab
\par
\pard\s32\plain\f1\fs20\sb60\fi-2880\li2880 F17\tab
\tab
\tab
\tab
\par
\pard\s32\plain\f1\fs20\sb60\fi-2880\li2880 F18\tab
\tab
\tab
\tab
\par
\pard\s32\plain\f1\fs20\sb60\fi-2880\li2880 F19\tab
\tab
\tab
\tab
\par
\pard\s32\plain\f1\fs20\sb60\fi-2880\li2880 F20\tab
\tab
\tab
\tab
\par
\pard\s32\plain\f1\fs20\sb60\fi-2880\li2880 F21\tab
\tab
\tab
\tab
\par
\pard\s32\plain\f1\fs20\sb60\fi-2880\li2880 F22\tab
\tab
\tab
\tab
\par
\pard\s32\plain\f1\fs20\sb60\fi-2880\li2880 F23\tab
\tab
\tab
\tab
\par
\pard\s32\plain\f1\fs20\sb60\fi-2880\li2880 F24\tab
\tab
\tab
\tab
\par
\pard\s32\plain\f1\fs20\sb60\fi-2880\li2880 ENTER\tab
\tab
\tab
\par
\pard\s32\plain\f1\fs20\sb60\fi-2880\li2880 ESC\tab
\tab
\tab
\tab
\par
\pard\s32\plain\f1\fs20\sb60\fi-2880\li2880 TAB\tab
\tab
\tab
\tab
\par
\pard\s32\plain\f1\fs20\sb60\fi-2880\li2880 BACKSPACE\tab
\tab
\par
\pard\s32\plain\f1\fs20\sb60\fi-2880\li2880 INPUTINVALID\tab
\par
\pard\s29\plain\li0\sb180\f1\fs24\b Procedures\par
\pard\s30\plain\li0\sb60\f1\fs20 {\strike\cf5 SetWindowTitle}{\v Display_SetWindowTitle
}\par
{\strike\cf5 GotoXY}{\v Display_GotoXY}\par
{\strike\cf5 WhereX}{\v Display_WhereX}\par
{\strike\cf5 WhereY}{\v Display_WhereY}\par
{\strike\cf5 WriteCharXY}{\v Display_WriteCharXY}\par
{\strike\cf5 GetCharXY}{\v Display_GetCharXY}\par
{\strike\cf5 GetStrXY}{\v Display_GetStrXY}\par
{\strike\cf5 WriteLn}{\v Display_WriteLn}\par
{\strike\cf5 WriteChar}{\v Display_WriteChar}\par
{\strike\cf5 WriteStrXY}{\v Display_WriteStrXY}\par
{\strike\cf5 WriteStr}{\v Display_WriteStr}\par
{\strike\cf5 WriteSpacesXY}{\v Display_WriteSpacesXY}\par
{\strike\cf5 WriteSpaces}{\v Display_WriteSpaces}\par
{\strike\cf5 WriteIntXY}{\v Display_WriteIntXY}\par
{\strike\cf5 WriteInt}{\v Display_WriteInt}\par
{\strike\cf5 WriteRealXY}{\v Display_WriteRealXY}\par
{\strike\cf5 WriteReal}{\v Display_WriteReal}\par
{\strike\cf5 KeyPressed}{\v Display_KeyPressed}\par
{\strike\cf5 ReadKey}{\v Display_ReadKey}\par
{\strike\cf5 CursorOn}{\v Display_CursorOn}\par
{\strike\cf5 CursorOff}{\v Display_CursorOff}\par
{\strike\cf5 IsCursorOn}{\v Display_IsCursorOn}\par
{\strike\cf5 TerminalBell}{\v Display_TerminalBell}\par
{\strike\cf5 ReadChar}{\v Display_ReadChar}\par
{\strike\cf5 ReadLongInt}{\v Display_ReadLongInt}\par
{\strike\cf5 ReadReal}{\v Display_ReadReal}\par
{\strike\cf5 ReadLongReal}{\v Display_ReadLongReal}\par
{\strike\cf5 ReadInt}{\v Display_ReadInt}\par
{\strike\cf5 ReadStr}{\v Display_ReadStr}\par
{\strike\cf5 EditStr}{\v Display_EditStr}\par
{\strike\cf5 FlushKeyBuffer}{\v Display_FlushKeyBuffer}\par
{\strike\cf5 ClrScr}{\v Display_ClrScr}\par
{\strike\cf5 SetForeColor}{\v Display_SetForeColor}\par
{\strike\cf5 SetBackColor}{\v Display_SetBackColor}\par
{\strike\cf5 GetForeColor}{\v Display_GetForeColor}\par
{\strike\cf5 GetBackColor}{\v Display_GetBackColor}\par
{\strike\cf5 IsColorSupported}{\v Display_IsColorSupported}\par
\page
{\ {\super #}\footnote \pard\plain{\super #}Display_SetWindowTitle}{\ {\super $}\footnote \pard\plain{\super 
$}Display.SetWindowTitle}{\ {\super K}\footnote \pard\plain{\super K}SetWindowTitle
}\pard\s28\plain\li0\sb120\sa120\keepn\f1\fs28\b SetWindowTitle\par
\pard\s31\plain\li0\sb120\sa120\f1\fs20\b defined in module {\strike\cf5 Display}{\v 
Display}\par
\pard\s29\plain\li0\sb180\f1\fs24\b Syntax\par
\pard\s27\plain\li0\sb120\tx1702\f2\fs20 PROCEDURE SetWindowTitle(t:ARRAY OF CHAR
)\par
\pard\s29\plain\li0\sb180\f1\fs24\b Description\par
\pard\s30\plain\li0\sb60\f1\fs20 The title of the program window is set to the string passed in 
{\b t}. In implementations of OPAL on other systems, e.g., on text-oriented systems without any space for displaying a program title, this procedure
 may have no effect. \par
\page
{\ {\super #}\footnote \pard\plain{\super #}Display_GotoXY}{\ {\super $}\footnote \pard\plain{\super 
$}Display.GotoXY}{\ {\super K}\footnote \pard\plain{\super K}GotoXY}\pard\s28\plain\li0\sb120\sa120\keepn\f1\fs28\b 
GotoXY\par
\pard\s31\plain\li0\sb120\sa120\f1\fs20\b defined in module {\strike\cf5 Display}{\v 
Display}\par
\pard\s29\plain\li0\sb180\f1\fs24\b Syntax\par
\pard\s27\plain\li0\sb120\tx1702\f2\fs20 PROCEDURE GotoXY(s, z:INTEGER)\par
\pard\s29\plain\li0\sb180\f1\fs24\b Description\par
\pard\s30\plain\li0\sb60\f1\fs20 The cursor is moved to column s and line z. If the stated position is
 invalid the cursor is positioned at column one, line one. \par
\page
{\ {\super #}\footnote \pard\plain{\super #}Display_WhereX}{\ {\super $}\footnote \pard\plain{\super 
$}Display.WhereX}{\ {\super K}\footnote \pard\plain{\super K}WhereX}\pard\s28\plain\li0\sb120\sa120\keepn\f1\fs28\b 
WhereX\par
\pard\s31\plain\li0\sb120\sa120\f1\fs20\b defined in module {\strike\cf5 Display}{\v 
Display}\par
\pard\s29\plain\li0\sb180\f1\fs24\b Syntax\par
\pard\s27\plain\li0\sb120\tx1702\f2\fs20 PROCEDURE WhereX():INTEGER\par
\pard\s29\plain\li0\sb180\f1\fs24\b Description\par
\pard\s30\plain\li0\sb60\f1\fs20 The return value of this function is the column of the current cursor position. 
\par
\page
{\ {\super #}\footnote \pard\plain{\super #}Display_WhereY}{\ {\super $}\footnote \pard\plain{\super 
$}Display.WhereY}{\ {\super K}\footnote \pard\plain{\super K}WhereY}\pard\s28\plain\li0\sb120\sa120\keepn\f1\fs28\b 
WhereY\par
\pard\s31\plain\li0\sb120\sa120\f1\fs20\b defined in module {\strike\cf5 Display}{\v 
Display}\par
\pard\s29\plain\li0\sb180\f1\fs24\b Syntax\par
\pard\s27\plain\li0\sb120\tx1702\f2\fs20 PROCEDURE WhereY():INTEGER\par
\pard\s29\plain\li0\sb180\f1\fs24\b Description\par
\pard\s30\plain\li0\sb60\f1\fs20 The return value of this function is the line of the current cursor position. 
\par
\page
{\ {\super #}\footnote \pard\plain{\super #}Display_WriteCharXY}{\ {\super $}\footnote \pard\plain{\super 
$}Display.WriteCharXY}{\ {\super K}\footnote \pard\plain{\super K}WriteCharXY}\pard\s28
\plain\li0\sb120\sa120\keepn\f1\fs28\b WriteCharXY\par
\pard\s31\plain\li0\sb120\sa120\f1\fs20\b defined in module {\strike\cf5 Display}{\v 
Display}\par
\pard\s29\plain\li0\sb180\f1\fs24\b Syntax\par
\pard\s27\plain\li0\sb120\tx1702\f2\fs20 PROCEDURE WriteCharXY(s, z:INTEGER; \line

                      x:CHAR)\par
\pard\s29\plain\li0\sb180\f1\fs24\b Description\par
\pard\s30\plain\li0\sb60\f1\fs20 The character contained in {\b x} is printed at the position column 
{\b s}, line {\b z}. \par
\page
{\ {\super #}\footnote \pard\plain{\super #}Display_GetCharXY}{\ {\super $}\footnote \pard\plain{\super 
$}Display.GetCharXY}{\ {\super K}\footnote \pard\plain{\super K}GetCharXY}\pard\s28
\plain\li0\sb120\sa120\keepn\f1\fs28\b GetCharXY\par
\pard\s31\plain\li0\sb120\sa120\f1\fs20\b defined in module {\strike\cf5 Display}{\v 
Display}\par
\pard\s29\plain\li0\sb180\f1\fs24\b Syntax\par
\pard\s27\plain\li0\sb120\tx1702\f2\fs20 PROCEDURE GetCharXY(s, z:INTEGER):CHAR\par

\pard\s29\plain\li0\sb180\f1\fs24\b Description\par
\pard\s30\plain\li0\sb60\f1\fs20 This function returns the value of the character which is currently
 displayed at column {\b s}, line {\b z}. \par
\page
{\ {\super #}\footnote \pard\plain{\super #}Display_GetStrXY}{\ {\super $}\footnote \pard\plain{\super 
$}Display.GetStrXY}{\ {\super K}\footnote \pard\plain{\super K}GetStrXY}\pard\s28
\plain\li0\sb120\sa120\keepn\f1\fs28\b GetStrXY\par
\pard\s31\plain\li0\sb120\sa120\f1\fs20\b defined in module {\strike\cf5 Display}{\v 
Display}\par
\pard\s29\plain\li0\sb180\f1\fs24\b Syntax\par
\pard\s27\plain\li0\sb120\tx1702\f2\fs20 PROCEDURE GetStrXY(s, z, n:INTEGER; \line

                   VAR t:ARRAY OF CHAR)\par
\pard\s29\plain\li0\sb180\f1\fs24\b Description\par
\pard\s30\plain\li0\sb60\f1\fs20 Starting at column {\b s}, line {\b z}, the following 
{\b n} characters displayed on the screen are copied to the array {\b t}. After the last copied character
 a character with the code zero is written so that {\b t} can be used as a string.
\par
If {\b n} is sufficiently large several lines can be copied with a single call. If 
{\b t} is not big enough fewer characters are copied (max. LEN({\b t})-1 characters). 
\par
\page
{\ {\super #}\footnote \pard\plain{\super #}Display_WriteLn}{\ {\super $}\footnote \pard\plain{\super 
$}Display.WriteLn}{\ {\super K}\footnote \pard\plain{\super K}WriteLn}\pard\s28\plain\li0\sb120\sa120\keepn\f1\fs28\b 
WriteLn\par
\pard\s31\plain\li0\sb120\sa120\f1\fs20\b defined in module {\strike\cf5 Display}{\v 
Display}\par
\pard\s29\plain\li0\sb180\f1\fs24\b Syntax\par
\pard\s27\plain\li0\sb120\tx1702\f2\fs20 PROCEDURE WriteLn()\par
\pard\s29\plain\li0\sb180\f1\fs24\b Description\par
\pard\s30\plain\li0\sb60\f1\fs20 The cursor is moved to the beginning of the next line. If the cursor was
 already situated in the last available line, then the whole contents of the screen is moved one line up. So the last line is empty and may be
 used for further output. The former first line is lost. \par
\page
{\ {\super #}\footnote \pard\plain{\super #}Display_WriteChar}{\ {\super $}\footnote \pard\plain{\super 
$}Display.WriteChar}{\ {\super K}\footnote \pard\plain{\super K}WriteChar}\pard\s28
\plain\li0\sb120\sa120\keepn\f1\fs28\b WriteChar\par
\pard\s31\plain\li0\sb120\sa120\f1\fs20\b defined in module {\strike\cf5 Display}{\v 
Display}\par
\pard\s29\plain\li0\sb180\f1\fs24\b Syntax\par
\pard\s27\plain\li0\sb120\tx1702\f2\fs20 PROCEDURE WriteChar(x:CHAR)\par
\pard\s29\plain\li0\sb180\f1\fs24\b Description\par
\pard\s30\plain\li0\sb60\f1\fs20 The character contained in {\b x} is displayed at the current cursor position.
 Afterwards the cursor is moved on one character. \par
\page
{\ {\super #}\footnote \pard\plain{\super #}Display_WriteStrXY}{\ {\super $}\footnote \pard\plain{\super 
$}Display.WriteStrXY}{\ {\super K}\footnote \pard\plain{\super K}WriteStrXY}\pard\s28
\plain\li0\sb120\sa120\keepn\f1\fs28\b WriteStrXY\par
\pard\s31\plain\li0\sb120\sa120\f1\fs20\b defined in module {\strike\cf5 Display}{\v 
Display}\par
\pard\s29\plain\li0\sb180\f1\fs24\b Syntax\par
\pard\s27\plain\li0\sb120\tx1702\f2\fs20 PROCEDURE WriteStrXY(s, z:INTEGER; \line

                     t:ARRAY OF CHAR)\par
\pard\s29\plain\li0\sb180\f1\fs24\b Description\par
\pard\s30\plain\li0\sb60\f1\fs20 The string passed in {\b t} is displayed in column 
{\b s}, line {\b z}. \par
\page
{\ {\super #}\footnote \pard\plain{\super #}Display_WriteStr}{\ {\super $}\footnote \pard\plain{\super 
$}Display.WriteStr}{\ {\super K}\footnote \pard\plain{\super K}WriteStr}\pard\s28
\plain\li0\sb120\sa120\keepn\f1\fs28\b WriteStr\par
\pard\s31\plain\li0\sb120\sa120\f1\fs20\b defined in module {\strike\cf5 Display}{\v 
Display}\par
\pard\s29\plain\li0\sb180\f1\fs24\b Syntax\par
\pard\s27\plain\li0\sb120\tx1702\f2\fs20 PROCEDURE WriteStr(t:ARRAY OF CHAR)\par
\pard\s29\plain\li0\sb180\f1\fs24\b Description\par
\pard\s30\plain\li0\sb60\f1\fs20 The string contained in {\b t} is displayed at the current cursor position.
 Afterwards the cursor is moved to the end of the output. Each occurrence of the control characters CR, LF, or CR LF is not
 written out but interpreted as a new line command. \par
\page
{\ {\super #}\footnote \pard\plain{\super #}Display_WriteSpacesXY}{\ {\super $}\footnote \pard\plain{\super 
$}Display.WriteSpacesXY}{\ {\super K}\footnote \pard\plain{\super K}WriteSpacesXY
}\pard\s28\plain\li0\sb120\sa120\keepn\f1\fs28\b WriteSpacesXY\par
\pard\s31\plain\li0\sb120\sa120\f1\fs20\b defined in module {\strike\cf5 Display}{\v 
Display}\par
\pard\s29\plain\li0\sb180\f1\fs24\b Syntax\par
\pard\s27\plain\li0\sb120\tx1702\f2\fs20 PROCEDURE WriteSpacesXY(s, z:INTEGER; \line

                        n:INTEGER)\par
\pard\s29\plain\li0\sb180\f1\fs24\b Description\par
\pard\s30\plain\li0\sb60\f1\fs20 This procedure displays {\b n} blanks starting at column 
{\b s}, line {\b z}. \par
\page
{\ {\super #}\footnote \pard\plain{\super #}Display_WriteSpaces}{\ {\super $}\footnote \pard\plain{\super 
$}Display.WriteSpaces}{\ {\super K}\footnote \pard\plain{\super K}WriteSpaces}\pard\s28
\plain\li0\sb120\sa120\keepn\f1\fs28\b WriteSpaces\par
\pard\s31\plain\li0\sb120\sa120\f1\fs20\b defined in module {\strike\cf5 Display}{\v 
Display}\par
\pard\s29\plain\li0\sb180\f1\fs24\b Syntax\par
\pard\s27\plain\li0\sb120\tx1702\f2\fs20 PROCEDURE WriteSpaces(n:INTEGER)\par
\pard\s29\plain\li0\sb180\f1\fs24\b Description\par
\pard\s30\plain\li0\sb60\f1\fs20 {\b n} blanks are printed at the current cursor position. Then the cursor
 is moved to the end of the output. \par
\page
{\ {\super #}\footnote \pard\plain{\super #}Display_WriteIntXY}{\ {\super $}\footnote \pard\plain{\super 
$}Display.WriteIntXY}{\ {\super K}\footnote \pard\plain{\super K}WriteIntXY}\pard\s28
\plain\li0\sb120\sa120\keepn\f1\fs28\b WriteIntXY\par
\pard\s31\plain\li0\sb120\sa120\f1\fs20\b defined in module {\strike\cf5 Display}{\v 
Display}\par
\pard\s29\plain\li0\sb180\f1\fs24\b Syntax\par
\pard\s27\plain\li0\sb120\tx1702\f2\fs20 PROCEDURE WriteIntXY(s, z:INTEGER; \line

                     x:LONGINT; \line
                     len:INTEGER)\par
\pard\s29\plain\li0\sb180\f1\fs24\b Description\par
\pard\s30\plain\li0\sb60\f1\fs20 The value of {\b x} is displayed in column {\b s
}, line {\b z}. The width of the output is {\b len} characters. The number is displayed
 right aligned. If the number is too big to be represented with {\b len} characters, the output is widened appropriately. 
\par
\page
{\ {\super #}\footnote \pard\plain{\super #}Display_WriteInt}{\ {\super $}\footnote \pard\plain{\super 
$}Display.WriteInt}{\ {\super K}\footnote \pard\plain{\super K}WriteInt}\pard\s28
\plain\li0\sb120\sa120\keepn\f1\fs28\b WriteInt\par
\pard\s31\plain\li0\sb120\sa120\f1\fs20\b defined in module {\strike\cf5 Display}{\v 
Display}\par
\pard\s29\plain\li0\sb180\f1\fs24\b Syntax\par
\pard\s27\plain\li0\sb120\tx1702\f2\fs20 PROCEDURE WriteInt(x:LONGINT; \line
                   len:INTEGER)\par
\pard\s29\plain\li0\sb180\f1\fs24\b Description\par
\pard\s30\plain\li0\sb60\f1\fs20 The value contained in {\b x} is displayed at the current cursor position.
 The width of the output is {\b len} characters or more if this is necessary for the representation of the number. If a representation with 
{\b len} characters is possible the number is written right aligned. Then the cursor is moved to the end of the output. 
\par
\page
{\ {\super #}\footnote \pard\plain{\super #}Display_WriteRealXY}{\ {\super $}\footnote \pard\plain{\super 
$}Display.WriteRealXY}{\ {\super K}\footnote \pard\plain{\super K}WriteRealXY}\pard\s28
\plain\li0\sb120\sa120\keepn\f1\fs28\b WriteRealXY\par
\pard\s31\plain\li0\sb120\sa120\f1\fs20\b defined in module {\strike\cf5 Display}{\v 
Display}\par
\pard\s29\plain\li0\sb180\f1\fs24\b Syntax\par
\pard\s27\plain\li0\sb120\tx1702\f2\fs20 PROCEDURE WriteRealXY(s, z:INTEGER; \line

                      x:LONGREAL; \line
                      len:INTEGER)\par
\pard\s29\plain\li0\sb180\f1\fs24\b Description\par
\pard\s30\plain\li0\sb60\f1\fs20 The value of {\b x} is displayed in column {\b s
}, line {\b z}. The width of the output is {\b len} characters or more in case this is necessary for the
 representation of the number. If a representation is possible with {\b len} characters, the number is written right aligned. 
\par
\page
{\ {\super #}\footnote \pard\plain{\super #}Display_WriteReal}{\ {\super $}\footnote \pard\plain{\super 
$}Display.WriteReal}{\ {\super K}\footnote \pard\plain{\super K}WriteReal}\pard\s28
\plain\li0\sb120\sa120\keepn\f1\fs28\b WriteReal\par
\pard\s31\plain\li0\sb120\sa120\f1\fs20\b defined in module {\strike\cf5 Display}{\v 
Display}\par
\pard\s29\plain\li0\sb180\f1\fs24\b Syntax\par
\pard\s27\plain\li0\sb120\tx1702\f2\fs20 PROCEDURE WriteReal(x:LONGREAL; \line
                    len:INTEGER)\par
\pard\s29\plain\li0\sb180\f1\fs24\b Description\par
\pard\s30\plain\li0\sb60\f1\fs20 The value contained in {\b x} is written at the current cursor position.
 The width of the output is {\b len} characters or more if this necessary for the representation of the number. If a representation with 
{\b len} characters is possible then the number is written right aligned. Afterwards the cursor is moved to the end of the output. 
\par
\page
{\ {\super #}\footnote \pard\plain{\super #}Display_KeyPressed}{\ {\super $}\footnote \pard\plain{\super 
$}Display.KeyPressed}{\ {\super K}\footnote \pard\plain{\super K}KeyPressed}\pard\s28
\plain\li0\sb120\sa120\keepn\f1\fs28\b KeyPressed\par
\pard\s31\plain\li0\sb120\sa120\f1\fs20\b defined in module {\strike\cf5 Display}{\v 
Display}\par
\pard\s29\plain\li0\sb180\f1\fs24\b Syntax\par
\pard\s27\plain\li0\sb120\tx1702\f2\fs20 PROCEDURE KeyPressed():BOOLEAN\par
\pard\s29\plain\li0\sb180\f1\fs24\b Description\par
\pard\s30\plain\li0\sb60\f1\fs20 The return value of this function is TRUE if a key was pressed and
 the corresponding code in the keyboard buffer is waiting to be read by a call of ReadKey. 
\par
\page
{\ {\super #}\footnote \pard\plain{\super #}Display_ReadKey}{\ {\super $}\footnote \pard\plain{\super 
$}Display.ReadKey}{\ {\super K}\footnote \pard\plain{\super K}ReadKey}\pard\s28\plain\li0\sb120\sa120\keepn\f1\fs28\b 
ReadKey\par
\pard\s31\plain\li0\sb120\sa120\f1\fs20\b defined in module {\strike\cf5 Display}{\v 
Display}\par
\pard\s29\plain\li0\sb180\f1\fs24\b Syntax\par
\pard\s27\plain\li0\sb120\tx1702\f2\fs20 PROCEDURE ReadKey():CHAR\par
\pard\s29\plain\li0\sb180\f1\fs24\b Description\par
\pard\s30\plain\li0\sb60\f1\fs20 The next key is awaited. The return value of the function is the
 character entered next; no output on the screen is effected.\par
If the pressed key does not have an ASCII code the result of the function is initially returned as zero. The next call of this
 function returns a key code which serves to identify the special key (e.g., the function keys or the cursor keys). 
\par
\page
{\ {\super #}\footnote \pard\plain{\super #}Display_CursorOn}{\ {\super $}\footnote \pard\plain{\super 
$}Display.CursorOn}{\ {\super K}\footnote \pard\plain{\super K}CursorOn}\pard\s28
\plain\li0\sb120\sa120\keepn\f1\fs28\b CursorOn\par
\pard\s31\plain\li0\sb120\sa120\f1\fs20\b defined in module {\strike\cf5 Display}{\v 
Display}\par
\pard\s29\plain\li0\sb180\f1\fs24\b Syntax\par
\pard\s27\plain\li0\sb120\tx1702\f2\fs20 PROCEDURE CursorOn()\par
\pard\s29\plain\li0\sb180\f1\fs24\b Description\par
\pard\s30\plain\li0\sb60\f1\fs20 The cursor is displayed. \par
\page
{\ {\super #}\footnote \pard\plain{\super #}Display_CursorOff}{\ {\super $}\footnote \pard\plain{\super 
$}Display.CursorOff}{\ {\super K}\footnote \pard\plain{\super K}CursorOff}\pard\s28
\plain\li0\sb120\sa120\keepn\f1\fs28\b CursorOff\par
\pard\s31\plain\li0\sb120\sa120\f1\fs20\b defined in module {\strike\cf5 Display}{\v 
Display}\par
\pard\s29\plain\li0\sb180\f1\fs24\b Syntax\par
\pard\s27\plain\li0\sb120\tx1702\f2\fs20 PROCEDURE CursorOff()\par
\pard\s29\plain\li0\sb180\f1\fs24\b Description\par
\pard\s30\plain\li0\sb60\f1\fs20 The cursor becomes invisible. Its position and function remain unchanged. 
\par
\page
{\ {\super #}\footnote \pard\plain{\super #}Display_IsCursorOn}{\ {\super $}\footnote \pard\plain{\super 
$}Display.IsCursorOn}{\ {\super K}\footnote \pard\plain{\super K}IsCursorOn}\pard\s28
\plain\li0\sb120\sa120\keepn\f1\fs28\b IsCursorOn\par
\pard\s31\plain\li0\sb120\sa120\f1\fs20\b defined in module {\strike\cf5 Display}{\v 
Display}\par
\pard\s29\plain\li0\sb180\f1\fs24\b Syntax\par
\pard\s27\plain\li0\sb120\tx1702\f2\fs20 PROCEDURE IsCursorOn():BOOLEAN\par
\pard\s29\plain\li0\sb180\f1\fs24\b Description\par
\pard\s30\plain\li0\sb60\f1\fs20 The return value of this function is TRUE if the cursor is visible. 
\par
\page
{\ {\super #}\footnote \pard\plain{\super #}Display_TerminalBell}{\ {\super $}\footnote \pard\plain{\super 
$}Display.TerminalBell}{\ {\super K}\footnote \pard\plain{\super K}TerminalBell}\pard\s28
\plain\li0\sb120\sa120\keepn\f1\fs28\b TerminalBell\par
\pard\s31\plain\li0\sb120\sa120\f1\fs20\b defined in module {\strike\cf5 Display}{\v 
Display}\par
\pard\s29\plain\li0\sb180\f1\fs24\b Syntax\par
\pard\s27\plain\li0\sb120\tx1702\f2\fs20 PROCEDURE TerminalBell()\par
\pard\s29\plain\li0\sb180\f1\fs24\b Description\par
\pard\s30\plain\li0\sb60\f1\fs20 A short sound is emitted. \par
\page
{\ {\super #}\footnote \pard\plain{\super #}Display_ReadChar}{\ {\super $}\footnote \pard\plain{\super 
$}Display.ReadChar}{\ {\super K}\footnote \pard\plain{\super K}ReadChar}\pard\s28
\plain\li0\sb120\sa120\keepn\f1\fs28\b ReadChar\par
\pard\s31\plain\li0\sb120\sa120\f1\fs20\b defined in module {\strike\cf5 Display}{\v 
Display}\par
\pard\s29\plain\li0\sb180\f1\fs24\b Syntax\par
\pard\s27\plain\li0\sb120\tx1702\f2\fs20 PROCEDURE ReadChar(VAR x:CHAR)\par
\pard\s29\plain\li0\sb180\f1\fs24\b Description\par
\pard\s30\plain\li0\sb60\f1\fs20 The next key is awaited. The character entered next is returned in 
{\b x} and is displayed on the screen at the current cursor position. Keys that do not return an ASCII code are ignored, e.g., all cursor keys and the
 function keys. \par
\page
{\ {\super #}\footnote \pard\plain{\super #}Display_ReadLongInt}{\ {\super $}\footnote \pard\plain{\super 
$}Display.ReadLongInt}{\ {\super K}\footnote \pard\plain{\super K}ReadLongInt}\pard\s28
\plain\li0\sb120\sa120\keepn\f1\fs28\b ReadLongInt\par
\pard\s31\plain\li0\sb120\sa120\f1\fs20\b defined in module {\strike\cf5 Display}{\v 
Display}\par
\pard\s29\plain\li0\sb180\f1\fs24\b Syntax\par
\pard\s27\plain\li0\sb120\tx1702\f2\fs20 PROCEDURE ReadLongInt(VAR x:LONGINT; \line

                      maxLen:INTEGER; \line
                      VAR resCode:CHAR)\par
\pard\s29\plain\li0\sb180\f1\fs24\b Description\par
\pard\s30\plain\li0\sb60\f1\fs20 The cursor is displayed and an input from the keyboard is awaited.
 The only valid characters are "0" to "9" and the minus symbol.\par
The length of the input can be limited with {\b maxLen}.\par
The input may be terminated using either the enter or the escape key. If the enter key was used then the input is converted to a value of
 the type LONGINT and returned in {\b x}. In {\b resCode} the value ENTER is returned. In case the correct conversion of the input to a number is
 impossible resCode is set to INPUTINVALID.\par
If the input is interrupted by the escape key {\b x} is set to zero and {\b resCode
} returns the value ESC. \par
\page
{\ {\super #}\footnote \pard\plain{\super #}Display_ReadReal}{\ {\super $}\footnote \pard\plain{\super 
$}Display.ReadReal}{\ {\super K}\footnote \pard\plain{\super K}ReadReal}\pard\s28
\plain\li0\sb120\sa120\keepn\f1\fs28\b ReadReal\par
\pard\s31\plain\li0\sb120\sa120\f1\fs20\b defined in module {\strike\cf5 Display}{\v 
Display}\par
\pard\s29\plain\li0\sb180\f1\fs24\b Syntax\par
\pard\s27\plain\li0\sb120\tx1702\f2\fs20 PROCEDURE ReadReal(VAR x:REAL; \line
                   maxLen:INTEGER; \line
                   VAR resCode:CHAR)\par
\pard\s29\plain\li0\sb180\f1\fs24\b Description\par
\pard\s30\plain\li0\sb60\f1\fs20 The cursor is displayed and an input from the keyboard is awaited.
 The only characters accepted are "0" to "9", "." and "-".\par
The length of the input can be limited by maxLen. The input can be terminated with either the enter or escape key.
\par
If the enter key is used then the input is converted to a value of the type REAL and returned in 
{\b x}. In {\b resCode} the value ENTER is returned. In case the correct conversion of the input to a number
 is impossible {\b resCode} is set to INPUTINVALID.\par
If the input is interrupted by the escape key {\b x} is set to zero and {\b resCode
} returns the value ESC. \par
\page
{\ {\super #}\footnote \pard\plain{\super #}Display_ReadLongReal}{\ {\super $}\footnote \pard\plain{\super 
$}Display.ReadLongReal}{\ {\super K}\footnote \pard\plain{\super K}ReadLongReal}\pard\s28
\plain\li0\sb120\sa120\keepn\f1\fs28\b ReadLongReal\par
\pard\s31\plain\li0\sb120\sa120\f1\fs20\b defined in module {\strike\cf5 Display}{\v 
Display}\par
\pard\s29\plain\li0\sb180\f1\fs24\b Syntax\par
\pard\s27\plain\li0\sb120\tx1702\f2\fs20 PROCEDURE ReadLongReal(VAR x:LONGREAL; \line

                       maxLen:INTEGER; \line
                       VAR resCode:CHAR)\par
\pard\s29\plain\li0\sb180\f1\fs24\b Description\par
\pard\s30\plain\li0\sb60\f1\fs20 The cursor is displayed and an input from the keyboard is awaited.
 The only characters accepted are "0" to "9", "." and "-".\par
The length of the input can be limited by maxLen. The input can be terminated with either the enter or escape key.
\par
If the enter key is used then the input is converted to a value of the type LONGREAL and returned in 
{\b x}. In {\b resCode} the value ENTER is returned. In case the correct conversion of the input to a number
 is impossible {\b resCode} is set to INPUTINVALID.\par
If the input is interrupted by the escape key {\b x} is set to zero and {\b resCode
} returns the value ESC. \par
\page
{\ {\super #}\footnote \pard\plain{\super #}Display_ReadInt}{\ {\super $}\footnote \pard\plain{\super 
$}Display.ReadInt}{\ {\super K}\footnote \pard\plain{\super K}ReadInt}\pard\s28\plain\li0\sb120\sa120\keepn\f1\fs28\b 
ReadInt\par
\pard\s31\plain\li0\sb120\sa120\f1\fs20\b defined in module {\strike\cf5 Display}{\v 
Display}\par
\pard\s29\plain\li0\sb180\f1\fs24\b Syntax\par
\pard\s27\plain\li0\sb120\tx1702\f2\fs20 PROCEDURE ReadInt(VAR x:INTEGER; \line
                  maxLen:INTEGER; \line
                  VAR resCode:CHAR)\par
\pard\s29\plain\li0\sb180\f1\fs24\b Description\par
\pard\s30\plain\li0\sb60\f1\fs20 The cursor is displayed and an input from the keyboard is awaited.
 The only valid characters are "0" to "9" and the minus symbol.\par
The length of the input can be limited with {\b maxLen}.\par
The input may be terminated using either the enter or the escape key. If the enter key was used then the input is converted to a value of
 the type INTEGER and returned in {\b x}. In {\b resCode} the value ENTER is returned. In case the correct conversion of the input to a number is
 impossible resCode is set to INPUTINVALID.\par
If the input is interrupted by the escape key {\b x} is set to zero and {\b resCode
} returns the value ESC. \par
\page
{\ {\super #}\footnote \pard\plain{\super #}Display_ReadStr}{\ {\super $}\footnote \pard\plain{\super 
$}Display.ReadStr}{\ {\super K}\footnote \pard\plain{\super K}ReadStr}\pard\s28\plain\li0\sb120\sa120\keepn\f1\fs28\b 
ReadStr\par
\pard\s31\plain\li0\sb120\sa120\f1\fs20\b defined in module {\strike\cf5 Display}{\v 
Display}\par
\pard\s29\plain\li0\sb180\f1\fs24\b Syntax\par
\pard\s27\plain\li0\sb120\tx1702\f2\fs20 PROCEDURE ReadStr(VAR aString:ARRAY OF CHAR
; \line
                  maxLen:INTEGER; \line
                  VAR resCode:CHAR)\par
\pard\s29\plain\li0\sb180\f1\fs24\b Description\par
\pard\s30\plain\li0\sb60\f1\fs20 The cursor is displayed and an input from the keyboard is awaited. The input
 string is shown on the screen. The maximum length of the input is limited by the length of the array passed in 
{\b aString}. In addition, it may be further limited by {\b maxLen}.\par
The input can be terminated using either the enter or escape key. In the first case the value ENTER is returned in <resCode<, in the second case ESC. 
\par
\page
{\ {\super #}\footnote \pard\plain{\super #}Display_EditStr}{\ {\super $}\footnote \pard\plain{\super 
$}Display.EditStr}{\ {\super K}\footnote \pard\plain{\super K}EditStr}\pard\s28\plain\li0\sb120\sa120\keepn\f1\fs28\b 
EditStr\par
\pard\s31\plain\li0\sb120\sa120\f1\fs20\b defined in module {\strike\cf5 Display}{\v 
Display}\par
\pard\s29\plain\li0\sb180\f1\fs24\b Syntax\par
\pard\s27\plain\li0\sb120\tx1702\f2\fs20 PROCEDURE EditStr(VAR aString:ARRAY OF CHAR
; \line
                  maxLen:INTEGER; \line
                  VAR resCode:CHAR)\par
\pard\s29\plain\li0\sb180\f1\fs24\b Description\par
\pard\s30\plain\li0\sb60\f1\fs20 The text passed in {\b aString} is displayed. Then the cursor is displayed
 and an input from the keyboard is awaited. The input line may be edited using the delete, cursor left, and cursor right keys. The entered string
 is shown on the screen. The maximum length of the input is limited by the length of the array passed in aString. In addition, it may be limited by 
{\b maxLen}. The input may be finished with one of the following keys: enter, escape, cursor up,
 cursor down, page up, page down, tabulator and the function keys. The code of the terminating key used is returned in 
{\b resCode}. \par
\page
{\ {\super #}\footnote \pard\plain{\super #}Display_FlushKeyBuffer}{\ {\super $}\footnote \pard\plain{\super 
$}Display.FlushKeyBuffer}{\ {\super K}\footnote \pard\plain{\super K}FlushKeyBuffer
}\pard\s28\plain\li0\sb120\sa120\keepn\f1\fs28\b FlushKeyBuffer\par
\pard\s31\plain\li0\sb120\sa120\f1\fs20\b defined in module {\strike\cf5 Display}{\v 
Display}\par
\pard\s29\plain\li0\sb180\f1\fs24\b Syntax\par
\pard\s27\plain\li0\sb120\tx1702\f2\fs20 PROCEDURE FlushKeyBuffer()\par
\pard\s29\plain\li0\sb180\f1\fs24\b Description\par
\pard\s30\plain\li0\sb60\f1\fs20 The keyboard buffer is cleared. This ensures that the next call of ReadKey does not return keys that were
 pressed earlier but not processed. \par
\page
{\ {\super #}\footnote \pard\plain{\super #}Display_ClrScr}{\ {\super $}\footnote \pard\plain{\super 
$}Display.ClrScr}{\ {\super K}\footnote \pard\plain{\super K}ClrScr}\pard\s28\plain\li0\sb120\sa120\keepn\f1\fs28\b 
ClrScr\par
\pard\s31\plain\li0\sb120\sa120\f1\fs20\b defined in module {\strike\cf5 Display}{\v 
Display}\par
\pard\s29\plain\li0\sb180\f1\fs24\b Syntax\par
\pard\s27\plain\li0\sb120\tx1702\f2\fs20 PROCEDURE ClrScr()\par
\pard\s29\plain\li0\sb180\f1\fs24\b Description\par
\pard\s30\plain\li0\sb60\f1\fs20 The screen is cleared and set to the current background color
 (see SetBackColor). When the program is started the background color is white. \par

\page
{\ {\super #}\footnote \pard\plain{\super #}Display_SetForeColor}{\ {\super $}\footnote \pard\plain{\super 
$}Display.SetForeColor}{\ {\super K}\footnote \pard\plain{\super K}SetForeColor}\pard\s28
\plain\li0\sb120\sa120\keepn\f1\fs28\b SetForeColor\par
\pard\s31\plain\li0\sb120\sa120\f1\fs20\b defined in module {\strike\cf5 Display}{\v 
Display}\par
\pard\s29\plain\li0\sb180\f1\fs24\b Syntax\par
\pard\s27\plain\li0\sb120\tx1702\f2\fs20 PROCEDURE SetForeColor(red, green, blue:
INTEGER)\par
\pard\s29\plain\li0\sb180\f1\fs24\b Description\par
\pard\s30\plain\li0\sb60\f1\fs20 All following output to the screen is drawn in the color defined by the
 color values given in {\b red}, {\b green}, and {\b blue}. If the system cannot 
provide the required color exactly, the nearest available color is selected. The values of the parameters red, green, and blue must be in the range 0 to 255. 
\par
\page
{\ {\super #}\footnote \pard\plain{\super #}Display_SetBackColor}{\ {\super $}\footnote \pard\plain{\super 
$}Display.SetBackColor}{\ {\super K}\footnote \pard\plain{\super K}SetBackColor}\pard\s28
\plain\li0\sb120\sa120\keepn\f1\fs28\b SetBackColor\par
\pard\s31\plain\li0\sb120\sa120\f1\fs20\b defined in module {\strike\cf5 Display}{\v 
Display}\par
\pard\s29\plain\li0\sb180\f1\fs24\b Syntax\par
\pard\s27\plain\li0\sb120\tx1702\f2\fs20 PROCEDURE SetBackColor(red, green, blue:
INTEGER)\par
\pard\s29\plain\li0\sb180\f1\fs24\b Description\par
\pard\s30\plain\li0\sb60\f1\fs20 The background for all following output is set to the color defined
 by {\b red}, {\b green}, and {\b blue}. This defined color is also used for clearing
 the output region. If the system cannot provide the desired color exactly, the nearest available color is used.
 The values for the parameters {\b red}, <{\b green}, and {\b blue} must be in the
 range 0 to 255. \par
\page
{\ {\super #}\footnote \pard\plain{\super #}Display_GetForeColor}{\ {\super $}\footnote \pard\plain{\super 
$}Display.GetForeColor}{\ {\super K}\footnote \pard\plain{\super K}GetForeColor}\pard\s28
\plain\li0\sb120\sa120\keepn\f1\fs28\b GetForeColor\par
\pard\s31\plain\li0\sb120\sa120\f1\fs20\b defined in module {\strike\cf5 Display}{\v 
Display}\par
\pard\s29\plain\li0\sb180\f1\fs24\b Syntax\par
\pard\s27\plain\li0\sb120\tx1702\f2\fs20 PROCEDURE GetForeColor(VAR red, green, blue
:INTEGER)\par
\pard\s29\plain\li0\sb180\f1\fs24\b Description\par
\pard\s30\plain\li0\sb60\f1\fs20 The text color currently used is returned in {\b 
red}, {\b green}, and {\b blue} according to their proportions. \par
\page
{\ {\super #}\footnote \pard\plain{\super #}Display_GetBackColor}{\ {\super $}\footnote \pard\plain{\super 
$}Display.GetBackColor}{\ {\super K}\footnote \pard\plain{\super K}GetBackColor}\pard\s28
\plain\li0\sb120\sa120\keepn\f1\fs28\b GetBackColor\par
\pard\s31\plain\li0\sb120\sa120\f1\fs20\b defined in module {\strike\cf5 Display}{\v 
Display}\par
\pard\s29\plain\li0\sb180\f1\fs24\b Syntax\par
\pard\s27\plain\li0\sb120\tx1702\f2\fs20 PROCEDURE GetBackColor(VAR red, green, blue
:INTEGER)\par
\pard\s29\plain\li0\sb180\f1\fs24\b Description\par
\pard\s30\plain\li0\sb60\f1\fs20 The background color currently used is returned in 
{\b red}, {\b green}, and {\b blue} according to their proportions. \par
\page
{\ {\super #}\footnote \pard\plain{\super #}Display_IsColorSupported}{\ {\super $
}\footnote \pard\plain{\super $}Display.IsColorSupported}{\ {\super K}\footnote \pard\plain{\super 
K}IsColorSupported}\pard\s28\plain\li0\sb120\sa120\keepn\f1\fs28\b IsColorSupported
\par
\pard\s31\plain\li0\sb120\sa120\f1\fs20\b defined in module {\strike\cf5 Display}{\v 
Display}\par
\pard\s29\plain\li0\sb180\f1\fs24\b Syntax\par
\pard\s27\plain\li0\sb120\tx1702\f2\fs20 PROCEDURE IsColorSupported():BOOLEAN\par

\pard\s29\plain\li0\sb180\f1\fs24\b Description\par
\pard\s30\plain\li0\sb60\f1\fs20 The return value of this function is TRUE if the system provides colors.
 In the implementation based on Windows the result of this function is always TRUE.
 If the system does not support colors then the procedures described in this section have no effect and the return values of GetForeColor and GetBackColor
 are always zero. \par
\page
{\ {\super #}\footnote \pard\plain{\super #}File}{\ {\super $}\footnote \pard\plain{\super 
$}module File}{\ {\super K}\footnote \pard\plain{\super K}File}\pard\s28\plain\li0\sb120\sa120\keepn\f1\fs28\b 
Module File\par
\pard\s30\plain\li0\sb60\f1\fs20 This module provides the functionality needed for working with files and
 doing file management.\par
All functions for file processing need a so-called {\b Handle} which is a unique 
reference which identifies a particular file. To obtain a valid handle a file must be opened with the function 
{\b Open}. When all work on a file has been completed the file must be closed with the function 
{\b Close}.\par
Functions that refer to a file as a whole rather than its contents require its file name as an argument instead of a handle.
\par
Files are regarded as streams of characters without predefined type. Single characters or whole data blocks can be read one after another. In order to
 control the current reading position within a file the system provides an internal variable for every open file, the so-called "fle pointer", which
 is also used to define the writing position. Initially the value of the file pointer start with zero.
\par
After data has been read or written at the current position, the file pointer is moved on for each read or written character. Additionally, there are
 functions {\b Seek} and {\b SeekRel} which make it possible to set the file pointer
 to a particular position.\par
\pard\s29\plain\li0\sb180\f1\fs24\b Constants\par
\pard\s32\plain\f1\fs20\sb60\fi-2880\li2880 MAXPATH\tab
\tab
\pard\s32\plain\f1\fs20\sb60\fi-2880\li2880 maximum length of a full pathname including the filename 
\par
\pard\s32\plain\f1\fs20\sb60\fi-2880\li2880 MAXFILENAME\tab
\pard\s32\plain\f1\fs20\sb60\fi-2880\li2880 maximum length of a filename\par
\par
\pard\s34\plain\li0\sb90\f1\fs20\b File Attributes \par
\pard\s32\plain\f1\fs20\sb60\fi-2880\li2880 \pard\s32\plain\f1\fs20\sb60\fi-2880\li2880 
ATTRREADONLY\tab
\pard\s32\plain\f1\fs20\sb60\fi-2880\li2880 the file is read-only                     
\par
\pard\s32\plain\f1\fs20\sb60\fi-2880\li2880 ATTRHIDDEN\tab
\tab
\pard\s32\plain\f1\fs20\sb60\fi-2880\li2880 the file is hidden                        
\par
\pard\s32\plain\f1\fs20\sb60\fi-2880\li2880 ATTRSYSTEM\tab
\tab
\pard\s32\plain\f1\fs20\sb60\fi-2880\li2880 the file is part of the operating system  
\par
\pard\s32\plain\f1\fs20\sb60\fi-2880\li2880 ATTRVOLUME\tab
\tab
\pard\s32\plain\f1\fs20\sb60\fi-2880\li2880 maintained for compatibility only         
\par
\pard\s32\plain\f1\fs20\sb60\fi-2880\li2880 ATTRDIR\tab
\tab
\tab
\pard\s32\plain\f1\fs20\sb60\fi-2880\li2880 file entry is really a directory          
\par
\pard\s32\plain\f1\fs20\sb60\fi-2880\li2880 ATTRARCHIVE\tab
\pard\s32\plain\f1\fs20\sb60\fi-2880\li2880 file marked for backup                    
\par
\pard\s32\plain\f1\fs20\sb60\fi-2880\li2880 ATTRNORMAL\tab
\tab
\pard\s32\plain\f1\fs20\sb60\fi-2880\li2880 a plain file with no other attributes set 
\par
\pard\s32\plain\f1\fs20\sb60\fi-2880\li2880 ATTRTEMP\tab
\tab
\pard\s32\plain\f1\fs20\sb60\fi-2880\li2880 the file is used for temporary storage    
\par
\pard\s32\plain\f1\fs20\sb60\fi-2880\li2880 ATTRCOMPRESSED\tab
\pard\s32\plain\f1\fs20\sb60\fi-2880\li2880 the file or directory is compressed       
\par
\pard\s32\plain\f1\fs20\sb60\fi-2880\li2880 ATTROFFLINE\tab
\pard\s32\plain\f1\fs20\sb60\fi-2880\li2880 file currently physically unavailable
\par
\par
\pard\s34\plain\li0\sb90\f1\fs20\b Constants for <mode> parameter of open command          
\par
\pard\s32\plain\f1\fs20\sb60\fi-2880\li2880 \pard\s32\plain\f1\fs20\sb60\fi-2880\li2880 
READONLY\tab
\tab
\pard\s32\plain\f1\fs20\sb60\fi-2880\li2880 The file will be read only.               
\par
\pard\s32\plain\f1\fs20\sb60\fi-2880\li2880 WRITEONLY\tab
\tab
\pard\s32\plain\f1\fs20\sb60\fi-2880\li2880 The file will be written to only.         
\par
\pard\s32\plain\f1\fs20\sb60\fi-2880\li2880 READWRITE\tab
\tab
\pard\s32\plain\f1\fs20\sb60\fi-2880\li2880 The file will be read from and written to.
\par
\par
\pard\s34\plain\li0\sb90\f1\fs20\b Constants for <deny> parameter of open command          
\par
\pard\s32\plain\f1\fs20\sb60\fi-2880\li2880 \pard\s32\plain\f1\fs20\sb60\fi-2880\li2880 
DENYALL\tab
\tab
\pard\s32\plain\f1\fs20\sb60\fi-2880\li2880 No simultaneous access is allowed.         
\par
\pard\s32\plain\f1\fs20\sb60\fi-2880\li2880 DENYNONE\tab
\tab
\pard\s32\plain\f1\fs20\sb60\fi-2880\li2880 The file may be read and written by others at the same time. 
\par
\pard\s32\plain\f1\fs20\sb60\fi-2880\li2880 DENYREAD\tab
\tab
\pard\s32\plain\f1\fs20\sb60\fi-2880\li2880 The file may be written by others at the same time. 
\par
\pard\s32\plain\f1\fs20\sb60\fi-2880\li2880 DENYWRITE\tab
\tab
\pard\s32\plain\f1\fs20\sb60\fi-2880\li2880 The file may be read by others at the same time.
\par
\par
\pard\s34\plain\li0\sb90\f1\fs20\b Error Codes                                             
\par
\pard\s32\plain\f1\fs20\sb60\fi-2880\li2880 \pard\s32\plain\f1\fs20\sb60\fi-2880\li2880 
ACCESSDENIED\tab
\pard\s32\plain\f1\fs20\sb60\fi-2880\li2880 The access to the file was denied by the operating system. 
\par
\pard\s32\plain\f1\fs20\sb60\fi-2880\li2880 EOFREACHED\tab
\pard\s32\plain\f1\fs20\sb60\fi-2880\li2880 The end of the file was reached. \par

\pard\s32\plain\f1\fs20\sb60\fi-2880\li2880 FILENOTFOUND\tab
\pard\s32\plain\f1\fs20\sb60\fi-2880\li2880 The file could not be found. \par
\pard\s32\plain\f1\fs20\sb60\fi-2880\li2880 INVALIDHANDLE\tab
\pard\s32\plain\f1\fs20\sb60\fi-2880\li2880 The supplied file handle does not refer to a properly opened file 
\par
\pard\s32\plain\f1\fs20\sb60\fi-2880\li2880 NOERROR\tab
\tab
\pard\s32\plain\f1\fs20\sb60\fi-2880\li2880 The operation was carried out successfully. 
\par
\pard\s32\plain\f1\fs20\sb60\fi-2880\li2880 SHARINGVIOLATION\tab
\pard\s32\plain\f1\fs20\sb60\fi-2880\li2880 The file has already been opened and must not be opened a second time with the requested rights. 
\par
\pard\s32\plain\f1\fs20\sb60\fi-2880\li2880 SHORTBUFFER\tab
\pard\s32\plain\f1\fs20\sb60\fi-2880\li2880 The data buffer supplied is not big enough for the result. 
\par
\pard\s32\plain\f1\fs20\sb60\fi-2880\li2880 WRITEPROTECTED\tab
\pard\s32\plain\f1\fs20\sb60\fi-2880\li2880 An attempt was made to write to a write-protected drive. 
\par
\pard\s29\plain\li0\sb180\f1\fs24\b Types\par
\pard\s30\plain\li0\sb60\f1\fs20 {\ul\cf5 Handle}{\v File_Handle}\par
{\ul\cf5 RetCodeT}{\v File_RetCodeT}\par
\pard\s29\plain\li0\sb180\f1\fs24\b Procedures\par
\pard\s30\plain\li0\sb60\f1\fs20 {\strike\cf5 Open}{\v File_Open}\par
{\strike\cf5 Close}{\v File_Close}\par
{\strike\cf5 GetErrorMessage}{\v File_GetErrorMessage}\par
{\strike\cf5 Pos}{\v File_Pos}\par
{\strike\cf5 Seek}{\v File_Seek}\par
{\strike\cf5 SeekRel}{\v File_SeekRel}\par
{\strike\cf5 Size}{\v File_Size}\par
{\strike\cf5 ReadChar}{\v File_ReadChar}\par
{\strike\cf5 WriteChar}{\v File_WriteChar}\par
{\strike\cf5 Truncate}{\v File_Truncate}\par
{\strike\cf5 ReadLn}{\v File_ReadLn}\par
{\strike\cf5 WriteLn}{\v File_WriteLn}\par
{\strike\cf5 ReadBlock}{\v File_ReadBlock}\par
{\strike\cf5 WriteBlock}{\v File_WriteBlock}\par
{\strike\cf5 AtEnd}{\v File_AtEnd}\par
{\strike\cf5 GetModifyDate}{\v File_GetModifyDate}\par
{\strike\cf5 GetCreationDate}{\v File_GetCreationDate}\par
{\strike\cf5 GetAccessDate}{\v File_GetAccessDate}\par
{\strike\cf5 SetModifyDate}{\v File_SetModifyDate}\par
{\strike\cf5 Exist}{\v File_Exist}\par
{\strike\cf5 GetAttributes}{\v File_GetAttributes}\par
{\strike\cf5 SetAttributes}{\v File_SetAttributes}\par
{\strike\cf5 Rename}{\v File_Rename}\par
{\strike\cf5 Delete}{\v File_Delete}\par
\page
{\ {\super #}\footnote \pard\plain{\super #}File_Open}{\ {\super $}\footnote \pard\plain{\super 
$}File.Open}{\ {\super K}\footnote \pard\plain{\super K}Open}\pard\s28\plain\li0\sb120\sa120\keepn\f1\fs28\b 
Open\par
\pard\s31\plain\li0\sb120\sa120\f1\fs20\b defined in module {\strike\cf5 File}{\v 
File}\par
\pard\s29\plain\li0\sb180\f1\fs24\b Syntax\par
\pard\s27\plain\li0\sb120\tx1702\f2\fs20 PROCEDURE Open(name:ARRAY OF CHAR; \line

               create:BOOLEAN; \line
               deny:INTEGER; \line
               mode:INTEGER; \line
               VAR fHandle:{\ul\cf5 Handle}{\v File_Handle}; \line
               VAR resCode:{\ul\cf5 RetCodeT}{\v File_RetCodeT})\par
\pard\s29\plain\li0\sb180\f1\fs24\b Parameters\par
\pard\s32\plain\f1\fs20\sb60\fi-2880\li2880 name\tab
\tab
\tab
\pard\s32\plain\f1\fs20\sb60\fi-2880\li2880 name of the file which should be opened or created 
\par
\pard\s32\plain\f1\fs20\sb60\fi-2880\li2880 create\tab
\tab
\tab
\pard\s32\plain\f1\fs20\sb60\fi-2880\li2880 If set to TRUE then the file is created if it does not exist already. 
\par
\pard\s32\plain\f1\fs20\sb60\fi-2880\li2880 deny\tab
\tab
\tab
\pard\s32\plain\f1\fs20\sb60\fi-2880\li2880 defines whether the file may be used by other programs at the same time and how. See DENY* constants. 
\par
\pard\s32\plain\f1\fs20\sb60\fi-2880\li2880 mode\tab
\tab
\tab
\pard\s32\plain\f1\fs20\sb60\fi-2880\li2880 defines the required kind of access to the file. See READONLY, WRITEONLY, READWRITE 
\par
\pard\s32\plain\f1\fs20\sb60\fi-2880\li2880 fHandle\tab
\tab
\tab
\pard\s32\plain\f1\fs20\sb60\fi-2880\li2880 returns the file handle if successful 
\par
\pard\s32\plain\f1\fs20\sb60\fi-2880\li2880 resCode\tab
\tab
\tab
\pard\s32\plain\f1\fs20\sb60\fi-2880\li2880 returns an error code \par
\pard\s29\plain\li0\sb180\f1\fs24\b Description\par
\pard\s30\plain\li0\sb60\f1\fs20 Opens a file.\par
The file name is passed in {\b name} along with an optional path. The name must not contain any wildcards like "?" or "*".
 Otherwise the code FILENOTFOUND is returned and the operation is abandoned.\par
If the file was opened successfully a handle for the open file is returned in {\b 
fHandle} and the file pointer is set to the beginning of the file.\par
The parameter {\b resCode} returns an error code. \par
\page
{\ {\super #}\footnote \pard\plain{\super #}File_Close}{\ {\super $}\footnote \pard\plain{\super 
$}File.Close}{\ {\super K}\footnote \pard\plain{\super K}Close}\pard\s28\plain\li0\sb120\sa120\keepn\f1\fs28\b 
Close\par
\pard\s31\plain\li0\sb120\sa120\f1\fs20\b defined in module {\strike\cf5 File}{\v 
File}\par
\pard\s29\plain\li0\sb180\f1\fs24\b Syntax\par
\pard\s27\plain\li0\sb120\tx1702\f2\fs20 PROCEDURE Close(handle:{\ul\cf5 Handle}{\v 
File_Handle})\par
\pard\s29\plain\li0\sb180\f1\fs24\b Description\par
\pard\s30\plain\li0\sb60\f1\fs20 The file specified by {\b handle} is closed. \par

\page
{\ {\super #}\footnote \pard\plain{\super #}File_GetErrorMessage}{\ {\super $}\footnote \pard\plain{\super 
$}File.GetErrorMessage}{\ {\super K}\footnote \pard\plain{\super K}GetErrorMessage
}\pard\s28\plain\li0\sb120\sa120\keepn\f1\fs28\b GetErrorMessage\par
\pard\s31\plain\li0\sb120\sa120\f1\fs20\b defined in module {\strike\cf5 File}{\v 
File}\par
\pard\s29\plain\li0\sb180\f1\fs24\b Syntax\par
\pard\s27\plain\li0\sb120\tx1702\f2\fs20 PROCEDURE GetErrorMessage(error:{\ul\cf5 
RetCodeT}{\v File_RetCodeT}; \line
                          VAR message:ARRAY OF CHAR)\par
\pard\s29\plain\li0\sb180\f1\fs24\b Description\par
\pard\s30\plain\li0\sb60\f1\fs20 The text returned in message explains the error code error.
 If an invalid error code is passed as a parameter a suitable error message is also returned.
 Identical constants for error codes defined in the module Volume have the same numerical value as their counterparts of the module File. 
\par
\page
{\ {\super #}\footnote \pard\plain{\super #}File_Pos}{\ {\super $}\footnote \pard\plain{\super 
$}File.Pos}{\ {\super K}\footnote \pard\plain{\super K}Pos}\pard\s28\plain\li0\sb120\sa120\keepn\f1\fs28\b 
Pos\par
\pard\s31\plain\li0\sb120\sa120\f1\fs20\b defined in module {\strike\cf5 File}{\v 
File}\par
\pard\s29\plain\li0\sb180\f1\fs24\b Syntax\par
\pard\s27\plain\li0\sb120\tx1702\f2\fs20 PROCEDURE Pos(handle:{\ul\cf5 Handle}{\v 
File_Handle}; \line
              VAR pos:LONGINT; \line
              VAR resCode:{\ul\cf5 RetCodeT}{\v File_RetCodeT})\par
\pard\s29\plain\li0\sb180\f1\fs24\b Description\par
\pard\s30\plain\li0\sb60\f1\fs20 The position of the file pointer of the file specified by 
{\b handle} is returned in {\b pos}.\par
The parameter {\b resCode} returns an error code. \par
\page
{\ {\super #}\footnote \pard\plain{\super #}File_Seek}{\ {\super $}\footnote \pard\plain{\super 
$}File.Seek}{\ {\super K}\footnote \pard\plain{\super K}Seek}\pard\s28\plain\li0\sb120\sa120\keepn\f1\fs28\b 
Seek\par
\pard\s31\plain\li0\sb120\sa120\f1\fs20\b defined in module {\strike\cf5 File}{\v 
File}\par
\pard\s29\plain\li0\sb180\f1\fs24\b Syntax\par
\pard\s27\plain\li0\sb120\tx1702\f2\fs20 PROCEDURE Seek(handle:{\ul\cf5 Handle}{\v 
File_Handle}; \line
               pos:LONGINT; \line
               VAR resCode:{\ul\cf5 RetCodeT}{\v File_RetCodeT})\par
\pard\s29\plain\li0\sb180\f1\fs24\b Description\par
\pard\s30\plain\li0\sb60\f1\fs20 The file pointer of the file specified by {\b handle
} is set to {\b pos}. If this is not possible the file pointer is set to the end of the file.
\par
The parameter {\b resCode} returns an error code. \par
\page
{\ {\super #}\footnote \pard\plain{\super #}File_SeekRel}{\ {\super $}\footnote \pard\plain{\super 
$}File.SeekRel}{\ {\super K}\footnote \pard\plain{\super K}SeekRel}\pard\s28\plain\li0\sb120\sa120\keepn\f1\fs28\b 
SeekRel\par
\pard\s31\plain\li0\sb120\sa120\f1\fs20\b defined in module {\strike\cf5 File}{\v 
File}\par
\pard\s29\plain\li0\sb180\f1\fs24\b Syntax\par
\pard\s27\plain\li0\sb120\tx1702\f2\fs20 PROCEDURE SeekRel(handle:{\ul\cf5 Handle
}{\v File_Handle}; \line
                  pos:LONGINT; \line
                  VAR resCode:{\ul\cf5 RetCodeT}{\v File_RetCodeT})\par
\pard\s29\plain\li0\sb180\f1\fs24\b Description\par
\pard\s30\plain\li0\sb60\f1\fs20 The file pointer of the file specified by {\b handle
} is transposed by {\b pos} characters. For example, a value -1 in {\b pos} would move the file pointer one
 character back. If the operation is unsuccessful, the file pointer is set to the end of the file.
\par
The parameter {\b resCode} returns an error code. \par
\page
{\ {\super #}\footnote \pard\plain{\super #}File_Size}{\ {\super $}\footnote \pard\plain{\super 
$}File.Size}{\ {\super K}\footnote \pard\plain{\super K}Size}\pard\s28\plain\li0\sb120\sa120\keepn\f1\fs28\b 
Size\par
\pard\s31\plain\li0\sb120\sa120\f1\fs20\b defined in module {\strike\cf5 File}{\v 
File}\par
\pard\s29\plain\li0\sb180\f1\fs24\b Syntax\par
\pard\s27\plain\li0\sb120\tx1702\f2\fs20 PROCEDURE Size(handle:{\ul\cf5 Handle}{\v 
File_Handle}; \line
               VAR len:LONGINT; \line
               VAR resCode:{\ul\cf5 RetCodeT}{\v File_RetCodeT})\par
\pard\s29\plain\li0\sb180\f1\fs24\b Description\par
\pard\s30\plain\li0\sb60\f1\fs20 The length of the file specified by {\b handle} is returned in 
{\b len}.\par
The parameter {\b resCode} returns an error code. \par
\page
{\ {\super #}\footnote \pard\plain{\super #}File_ReadChar}{\ {\super $}\footnote \pard\plain{\super 
$}File.ReadChar}{\ {\super K}\footnote \pard\plain{\super K}ReadChar}\pard\s28\plain\li0\sb120\sa120\keepn\f1\fs28\b 
ReadChar\par
\pard\s31\plain\li0\sb120\sa120\f1\fs20\b defined in module {\strike\cf5 File}{\v 
File}\par
\pard\s29\plain\li0\sb180\f1\fs24\b Syntax\par
\pard\s27\plain\li0\sb120\tx1702\f2\fs20 PROCEDURE ReadChar(handle:{\ul\cf5 Handle
}{\v File_Handle}; \line
                   VAR x:CHAR; \line
                   VAR resCode:{\ul\cf5 RetCodeT}{\v File_RetCodeT})\par
\pard\s29\plain\li0\sb180\f1\fs24\b Description\par
\pard\s30\plain\li0\sb60\f1\fs20 A character is read from the file specified by {\b 
handle} and returned in {\b x}.\par
The parameter {\b resCode} returns an error code. \par
\page
{\ {\super #}\footnote \pard\plain{\super #}File_WriteChar}{\ {\super $}\footnote \pard\plain{\super 
$}File.WriteChar}{\ {\super K}\footnote \pard\plain{\super K}WriteChar}\pard\s28\plain\li0\sb120\sa120\keepn\f1\fs28\b 
WriteChar\par
\pard\s31\plain\li0\sb120\sa120\f1\fs20\b defined in module {\strike\cf5 File}{\v 
File}\par
\pard\s29\plain\li0\sb180\f1\fs24\b Syntax\par
\pard\s27\plain\li0\sb120\tx1702\f2\fs20 PROCEDURE WriteChar(handle:{\ul\cf5 Handle
}{\v File_Handle}; \line
                    x:CHAR; \line
                    VAR resCode:{\ul\cf5 RetCodeT}{\v File_RetCodeT})\par
\pard\s29\plain\li0\sb180\f1\fs24\b Description\par
\pard\s30\plain\li0\sb60\f1\fs20 The character {\b x} is written to the file specified by 
{\b handle}.\par
The parameter {\b resCode} returns an error code. \par
\page
{\ {\super #}\footnote \pard\plain{\super #}File_Truncate}{\ {\super $}\footnote \pard\plain{\super 
$}File.Truncate}{\ {\super K}\footnote \pard\plain{\super K}Truncate}\pard\s28\plain\li0\sb120\sa120\keepn\f1\fs28\b 
Truncate\par
\pard\s31\plain\li0\sb120\sa120\f1\fs20\b defined in module {\strike\cf5 File}{\v 
File}\par
\pard\s29\plain\li0\sb180\f1\fs24\b Syntax\par
\pard\s27\plain\li0\sb120\tx1702\f2\fs20 PROCEDURE Truncate(handle:{\ul\cf5 Handle
}{\v File_Handle}; \line
                   VAR resCode:{\ul\cf5 RetCodeT}{\v File_RetCodeT})\par
\pard\s29\plain\li0\sb180\f1\fs24\b Description\par
\pard\s30\plain\li0\sb60\f1\fs20 The file specified by {\b handle} is truncated at the current position of
 the file pointer. With this function the size of a file can be reduced.\par
The parameter {\b resCode} returns an error code. \par
\page
{\ {\super #}\footnote \pard\plain{\super #}File_ReadLn}{\ {\super $}\footnote \pard\plain{\super 
$}File.ReadLn}{\ {\super K}\footnote \pard\plain{\super K}ReadLn}\pard\s28\plain\li0\sb120\sa120\keepn\f1\fs28\b 
ReadLn\par
\pard\s31\plain\li0\sb120\sa120\f1\fs20\b defined in module {\strike\cf5 File}{\v 
File}\par
\pard\s29\plain\li0\sb180\f1\fs24\b Syntax\par
\pard\s27\plain\li0\sb120\tx1702\f2\fs20 PROCEDURE ReadLn(handle:{\ul\cf5 Handle}{\v 
File_Handle}; \line
                 VAR t:ARRAY OF CHAR; \line
                 VAR resCode:{\ul\cf5 RetCodeT}{\v File_RetCodeT})\par
\pard\s29\plain\li0\sb180\f1\fs24\b Description\par
\pard\s30\plain\li0\sb60\f1\fs20 The file specified by {\b handle} is regarded as a text file. Starting from
 the current position of the file pointer a line is read and returned in {\b t}. A line is terminated either by CR, LF, CR LF, or the end of the file.
\par
The parameter {\b resCode} returns an error code. If t is too short to hold the whole read line the error code SHORTBUFFER is returned.
\par
\page
{\ {\super #}\footnote \pard\plain{\super #}File_WriteLn}{\ {\super $}\footnote \pard\plain{\super 
$}File.WriteLn}{\ {\super K}\footnote \pard\plain{\super K}WriteLn}\pard\s28\plain\li0\sb120\sa120\keepn\f1\fs28\b 
WriteLn\par
\pard\s31\plain\li0\sb120\sa120\f1\fs20\b defined in module {\strike\cf5 File}{\v 
File}\par
\pard\s29\plain\li0\sb180\f1\fs24\b Syntax\par
\pard\s27\plain\li0\sb120\tx1702\f2\fs20 PROCEDURE WriteLn(handle:{\ul\cf5 Handle
}{\v File_Handle}; \line
                  VAR txt-:ARRAY OF CHAR; \line
                  VAR resCode:{\ul\cf5 RetCodeT}{\v File_RetCodeT})\par
\pard\s29\plain\li0\sb180\f1\fs24\b Description\par
\pard\s30\plain\li0\sb60\f1\fs20 The file specified by {\b handle} is regarded as a text file. The string passed
 in {\b txt} is written to the file and terminated according to the operating system conventions. OPAL for Windows uses the characters CR LF as the mark
 for the end of a line. The string terminator (0) is not written to the file. A file written with WriteLn can be edited directly with any ASCII editor.
 Every string written with WriteLn appears as a line in the editor.\par
The parameter {\b resCode} returns an error code. \par
\page
{\ {\super #}\footnote \pard\plain{\super #}File_ReadBlock}{\ {\super $}\footnote \pard\plain{\super 
$}File.ReadBlock}{\ {\super K}\footnote \pard\plain{\super K}ReadBlock}\pard\s28\plain\li0\sb120\sa120\keepn\f1\fs28\b 
ReadBlock\par
\pard\s31\plain\li0\sb120\sa120\f1\fs20\b defined in module {\strike\cf5 File}{\v 
File}\par
\pard\s29\plain\li0\sb180\f1\fs24\b Syntax\par
\pard\s27\plain\li0\sb120\tx1702\f2\fs20 PROCEDURE ReadBlock(handle:{\ul\cf5 Handle
}{\v File_Handle}; \line
                    VAR data:ARRAY OF SYSTEM.BYTE; \line
                    n:LONGINT; \line
                    VAR bytesRead:LONGINT; \line
                    VAR resCode:{\ul\cf5 RetCodeT}{\v File_RetCodeT})\par
\pard\s29\plain\li0\sb180\f1\fs24\b Description\par
\pard\s30\plain\li0\sb60\f1\fs20 An attempt is made to read a block of the length 
{\b n} from the file specified by {\b handle}. The number of bytes actually read is returned in 
{\b bytesRead}. The file data are written into the region determined by {\b data}
. As {\b data} is of the type SYSTEM.BYTE any types can be passed. Thus data can be
 directly written into a structure or an array. If {\b data} is not large enough 
to hold {\b n} bytes the maximum number of bytes possible is read and the return 
value of the function is set to SHORTBUFFER. If an error prevents the reading of data, 
{\b bytesRead} is set to zero and the error code is returned in the parameter {\b 
resCode}. \par
\page
{\ {\super #}\footnote \pard\plain{\super #}File_WriteBlock}{\ {\super $}\footnote \pard\plain{\super 
$}File.WriteBlock}{\ {\super K}\footnote \pard\plain{\super K}WriteBlock}\pard\s28
\plain\li0\sb120\sa120\keepn\f1\fs28\b WriteBlock\par
\pard\s31\plain\li0\sb120\sa120\f1\fs20\b defined in module {\strike\cf5 File}{\v 
File}\par
\pard\s29\plain\li0\sb180\f1\fs24\b Syntax\par
\pard\s27\plain\li0\sb120\tx1702\f2\fs20 PROCEDURE WriteBlock(handle:{\ul\cf5 Handle
}{\v File_Handle}; \line
                     VAR data-:ARRAY OF SYSTEM.BYTE; \line
                     n:LONGINT; \line
                     VAR resCode:{\ul\cf5 RetCodeT}{\v File_RetCodeT})\par
\pard\s29\plain\li0\sb180\f1\fs24\b Description\par
\pard\s30\plain\li0\sb60\f1\fs20 A block {\b n} bytes long is written to the file specified by 
{\b handle}. The data to be written are specified by {\b data}. The amount of data is
 limited by the actual size of {\b data}, even if {\b n} is larger.\par
The parameter {\b resCode} returns an error code \par
\page
{\ {\super #}\footnote \pard\plain{\super #}File_AtEnd}{\ {\super $}\footnote \pard\plain{\super 
$}File.AtEnd}{\ {\super K}\footnote \pard\plain{\super K}AtEnd}\pard\s28\plain\li0\sb120\sa120\keepn\f1\fs28\b 
AtEnd\par
\pard\s31\plain\li0\sb120\sa120\f1\fs20\b defined in module {\strike\cf5 File}{\v 
File}\par
\pard\s29\plain\li0\sb180\f1\fs24\b Syntax\par
\pard\s27\plain\li0\sb120\tx1702\f2\fs20 PROCEDURE AtEnd(handle:{\ul\cf5 Handle}{\v 
File_Handle}):BOOLEAN\par
\pard\s29\plain\li0\sb180\f1\fs24\b Description\par
\pard\s30\plain\li0\sb60\f1\fs20 The return value of this function is TRUE if the file pointer points
 to the end of the file specified by {\b handle}. If it is impossible to determine a correct result (e.g., 
{\b handle} does not contain a valid reference to an open file), the return value of the
 function is TRUE. \par
\page
{\ {\super #}\footnote \pard\plain{\super #}File_GetModifyDate}{\ {\super $}\footnote \pard\plain{\super 
$}File.GetModifyDate}{\ {\super K}\footnote \pard\plain{\super K}GetModifyDate}\pard\s28
\plain\li0\sb120\sa120\keepn\f1\fs28\b GetModifyDate\par
\pard\s31\plain\li0\sb120\sa120\f1\fs20\b defined in module {\strike\cf5 File}{\v 
File}\par
\pard\s29\plain\li0\sb180\f1\fs24\b Syntax\par
\pard\s27\plain\li0\sb120\tx1702\f2\fs20 PROCEDURE GetModifyDate(handle:{\ul\cf5 
Handle}{\v File_Handle}; \line
                        VAR date:ARRAY OF CHAR; \line
                        VAR resCode:{\ul\cf5 RetCodeT}{\v File_RetCodeT})\par
\pard\s29\plain\li0\sb180\f1\fs24\b Description\par
\pard\s30\plain\li0\sb60\f1\fs20 The date of the last modification of the file specified by 
{\b handle} is returned in {\b date}.\par
The format for the date is "DD.MM.YYYY  HH:MM:SS" and the total length of the string is 20 characters (two separating blanks between date and time).
\par
Example: "15. 4.1998  18:06:27"\par
The parameter {\b resCode} returns an error code. \par
\page
{\ {\super #}\footnote \pard\plain{\super #}File_GetCreationDate}{\ {\super $}\footnote \pard\plain{\super 
$}File.GetCreationDate}{\ {\super K}\footnote \pard\plain{\super K}GetCreationDate
}\pard\s28\plain\li0\sb120\sa120\keepn\f1\fs28\b GetCreationDate\par
\pard\s31\plain\li0\sb120\sa120\f1\fs20\b defined in module {\strike\cf5 File}{\v 
File}\par
\pard\s29\plain\li0\sb180\f1\fs24\b Syntax\par
\pard\s27\plain\li0\sb120\tx1702\f2\fs20 PROCEDURE GetCreationDate(handle:{\ul\cf5 
Handle}{\v File_Handle}; \line
                          VAR date:ARRAY OF CHAR; \line
                          VAR resCode:{\ul\cf5 RetCodeT}{\v File_RetCodeT})\par
\pard\s29\plain\li0\sb180\f1\fs24\b Description\par
\pard\s30\plain\li0\sb60\f1\fs20 The creation date of the file specified by {\b handle
} is returned in {\b date}. If the underlying file system does not support this feature, an empty
 string is returned in {\b date}.\par
The format for the date is "DD.MM.YYYY  HH:MM:SS" and the total length of the string is 20 characters (two separating blanks between date and time).
\par
Example: "15. 4.1998  18:06:27"\par
The parameter {\b resCode} returns an error code. \par
\page
{\ {\super #}\footnote \pard\plain{\super #}File_GetAccessDate}{\ {\super $}\footnote \pard\plain{\super 
$}File.GetAccessDate}{\ {\super K}\footnote \pard\plain{\super K}GetAccessDate}\pard\s28
\plain\li0\sb120\sa120\keepn\f1\fs28\b GetAccessDate\par
\pard\s31\plain\li0\sb120\sa120\f1\fs20\b defined in module {\strike\cf5 File}{\v 
File}\par
\pard\s29\plain\li0\sb180\f1\fs24\b Syntax\par
\pard\s27\plain\li0\sb120\tx1702\f2\fs20 PROCEDURE GetAccessDate(handle:{\ul\cf5 
Handle}{\v File_Handle}; \line
                        VAR date:ARRAY OF CHAR; \line
                        VAR resCode:{\ul\cf5 RetCodeT}{\v File_RetCodeT})\par
\pard\s29\plain\li0\sb180\f1\fs24\b Description\par
\pard\s30\plain\li0\sb60\f1\fs20 The time at which the file specified by {\b handle
} was accessed for the last time is returned in {\b date}. If the underlying file system does not support this feature, an empty
 string is returned in {\b date}.\par
The format for the date is "DD.MM.YYYY  HH:MM:SS" and the total length of the string is 20 characters (two separating blanks between date and time).
\par
Example: "15. 4.1998  18:06:27"\par
The parameter {\b resCode} returns an error code. \par
\page
{\ {\super #}\footnote \pard\plain{\super #}File_SetModifyDate}{\ {\super $}\footnote \pard\plain{\super 
$}File.SetModifyDate}{\ {\super K}\footnote \pard\plain{\super K}SetModifyDate}\pard\s28
\plain\li0\sb120\sa120\keepn\f1\fs28\b SetModifyDate\par
\pard\s31\plain\li0\sb120\sa120\f1\fs20\b defined in module {\strike\cf5 File}{\v 
File}\par
\pard\s29\plain\li0\sb180\f1\fs24\b Syntax\par
\pard\s27\plain\li0\sb120\tx1702\f2\fs20 PROCEDURE SetModifyDate(handle:{\ul\cf5 
Handle}{\v File_Handle}; \line
                        VAR date-:ARRAY OF CHAR; \line
                        VAR resCode:{\ul\cf5 RetCodeT}{\v File_RetCodeT})\par
\pard\s29\plain\li0\sb180\f1\fs24\b Description\par
\pard\s30\plain\li0\sb60\f1\fs20 The date of the last modification of the file specified by 
{\b handle} is set to {\b date}. The format for the date is "DD.MM.YYYY  HH:MM:SS" (two blanks are required
 between date and time) and the total length of the string is 20 characters.\par
The parameter {\b resCode} returns an error code. \par
\page
{\ {\super #}\footnote \pard\plain{\super #}File_Exist}{\ {\super $}\footnote \pard\plain{\super 
$}File.Exist}{\ {\super K}\footnote \pard\plain{\super K}Exist}\pard\s28\plain\li0\sb120\sa120\keepn\f1\fs28\b 
Exist\par
\pard\s31\plain\li0\sb120\sa120\f1\fs20\b defined in module {\strike\cf5 File}{\v 
File}\par
\pard\s29\plain\li0\sb180\f1\fs24\b Syntax\par
\pard\s27\plain\li0\sb120\tx1702\f2\fs20 PROCEDURE Exist(name:ARRAY OF CHAR):BOOLEAN
\par
\pard\s29\plain\li0\sb180\f1\fs24\b Description\par
\pard\s30\plain\li0\sb60\f1\fs20 This function checks whether a certain file exists. The name of the
 file together with an optional path must be passed in {\b name}. The return value of the function is TRUE if the file exists.
 {\b name} may also contain wildchards. \par
\page
{\ {\super #}\footnote \pard\plain{\super #}File_GetAttributes}{\ {\super $}\footnote \pard\plain{\super 
$}File.GetAttributes}{\ {\super K}\footnote \pard\plain{\super K}GetAttributes}\pard\s28
\plain\li0\sb120\sa120\keepn\f1\fs28\b GetAttributes\par
\pard\s31\plain\li0\sb120\sa120\f1\fs20\b defined in module {\strike\cf5 File}{\v 
File}\par
\pard\s29\plain\li0\sb180\f1\fs24\b Syntax\par
\pard\s27\plain\li0\sb120\tx1702\f2\fs20 PROCEDURE GetAttributes(name:ARRAY OF CHAR
; \line
                        VAR attr:SET; \line
                        VAR resCode:{\ul\cf5 RetCodeT}{\v File_RetCodeT})\par
\pard\s29\plain\li0\sb180\f1\fs24\b Description\par
\pard\s30\plain\li0\sb60\f1\fs20 The attributes of the directory entry with the name specified by 
{\b name} are accessed and returned in {\b attr}. It is therefore possible to find out if
 a directory entry is a file or a further directory. For a list of the constants which can be used in connection with 
{\b attr} see the description of the ATTR* constants.\par
The parameter {\b resCode} returns an error code. \par
\page
{\ {\super #}\footnote \pard\plain{\super #}File_SetAttributes}{\ {\super $}\footnote \pard\plain{\super 
$}File.SetAttributes}{\ {\super K}\footnote \pard\plain{\super K}SetAttributes}\pard\s28
\plain\li0\sb120\sa120\keepn\f1\fs28\b SetAttributes\par
\pard\s31\plain\li0\sb120\sa120\f1\fs20\b defined in module {\strike\cf5 File}{\v 
File}\par
\pard\s29\plain\li0\sb180\f1\fs24\b Syntax\par
\pard\s27\plain\li0\sb120\tx1702\f2\fs20 PROCEDURE SetAttributes(name:ARRAY OF CHAR
; \line
                        attr:SET; \line
                        VAR resCode:{\ul\cf5 RetCodeT}{\v File_RetCodeT})\par
\pard\s29\plain\li0\sb180\f1\fs24\b Description\par
\pard\s30\plain\li0\sb60\f1\fs20 The attributes of the file with the name specified by 
{\b name} are set to {\b attr}. For a list of the constants which can be used in connection with 
{\b attr} see the description of the ATTR* constants.\par
The parameter {\b resCode} returns an error code. \par
\page
{\ {\super #}\footnote \pard\plain{\super #}File_Rename}{\ {\super $}\footnote \pard\plain{\super 
$}File.Rename}{\ {\super K}\footnote \pard\plain{\super K}Rename}\pard\s28\plain\li0\sb120\sa120\keepn\f1\fs28\b 
Rename\par
\pard\s31\plain\li0\sb120\sa120\f1\fs20\b defined in module {\strike\cf5 File}{\v 
File}\par
\pard\s29\plain\li0\sb180\f1\fs24\b Syntax\par
\pard\s27\plain\li0\sb120\tx1702\f2\fs20 PROCEDURE Rename(oldName, newName:ARRAY 
OF CHAR; \line
                 VAR resCode:{\ul\cf5 RetCodeT}{\v File_RetCodeT})\par
\pard\s29\plain\li0\sb180\f1\fs24\b Description\par
\pard\s30\plain\li0\sb60\f1\fs20 The file with the name specified in {\b oldName}
 is renamed to {\b newName}. The name may also contain a path. Wildcards such as "*" or "?" are not allowed.
\par
The parameter {\b resCode} returns an error code. \par
\page
{\ {\super #}\footnote \pard\plain{\super #}File_Delete}{\ {\super $}\footnote \pard\plain{\super 
$}File.Delete}{\ {\super K}\footnote \pard\plain{\super K}Delete}\pard\s28\plain\li0\sb120\sa120\keepn\f1\fs28\b 
Delete\par
\pard\s31\plain\li0\sb120\sa120\f1\fs20\b defined in module {\strike\cf5 File}{\v 
File}\par
\pard\s29\plain\li0\sb180\f1\fs24\b Syntax\par
\pard\s27\plain\li0\sb120\tx1702\f2\fs20 PROCEDURE Delete(name:ARRAY OF CHAR; \line

                 VAR resCode:{\ul\cf5 RetCodeT}{\v File_RetCodeT})\par
\pard\s29\plain\li0\sb180\f1\fs24\b Description\par
\pard\s30\plain\li0\sb60\f1\fs20 The file with the name specified in {\b name} is deleted. The name may also
 contain a path. Wildcards such as "*" or "?" are not permitted.\par
The parameter {\b resCode} returns an error code. \par
\page
{\ {\super #}\footnote \pard\plain{\super #}File_Handle}{\ {\super $}\footnote \pard\plain{\super 
$}File.Handle}{\ {\super K}\footnote \pard\plain{\super K}Handle}\pard\s30\plain\li0\sb60\f1\fs20 
{\b Handle}\par
\pard\s27\plain\li0\sb120\tx1702\f2\fs20 Handle*=WD.HANDLE;\par
\pard\s30\plain\li0\sb60\f1\fs20 The type handle serves for storing file handles. 
\par
\page
{\ {\super #}\footnote \pard\plain{\super #}File_RetCodeT}{\ {\super $}\footnote \pard\plain{\super 
$}File.RetCodeT}{\ {\super K}\footnote \pard\plain{\super K}RetCodeT}\pard\s30\plain\li0\sb60\f1\fs20 
{\b RetCodeT}\par
\pard\s27\plain\li0\sb120\tx1702\f2\fs20 RetCodeT*=INTEGER;\par
\page
{\ {\super #}\footnote \pard\plain{\super #}Float}{\ {\super $}\footnote \pard\plain{\super 
$}module Float}{\ {\super K}\footnote \pard\plain{\super K}Float}\pard\s28\plain\li0\sb120\sa120\keepn\f1\fs28\b 
Module Float\par
\pard\s29\plain\li0\sb180\f1\fs24\b Constants\par
\pard\s32\plain\f1\fs20\sb60\fi-2880\li2880 Pi\tab
\tab
\tab
\tab
\par
\pard\s32\plain\f1\fs20\sb60\fi-2880\li2880 e\tab
\tab
\tab
\tab
\pard\s32\plain\f1\fs20\sb60\fi-2880\li2880 \par
\pard\s34\plain\li0\sb90\f1\fs20\b Constants for the result of ValResult \par
\pard\s32\plain\f1\fs20\sb60\fi-2880\li2880 \pard\s32\plain\f1\fs20\sb60\fi-2880\li2880 
ISREAL\tab
\tab
\tab
\par
\pard\s32\plain\f1\fs20\sb60\fi-2880\li2880 ISLONGREAL\tab
\tab
\par
\pard\s32\plain\f1\fs20\sb60\fi-2880\li2880 ISOUTOFRANGE\tab
\par
\pard\s32\plain\f1\fs20\sb60\fi-2880\li2880 STRINGEMPTY\tab
\par
\pard\s32\plain\f1\fs20\sb60\fi-2880\li2880 STRINGILLEGAL\tab
\pard\s32\plain\f1\fs20\sb60\fi-2880\li2880 \par
\pard\s34\plain\li0\sb90\f1\fs20\b Constants for the result of KindOfNumber \par
\pard\s32\plain\f1\fs20\sb60\fi-2880\li2880 \pard\s32\plain\f1\fs20\sb60\fi-2880\li2880 
UNSUPPORTED\tab
\par
\pard\s32\plain\f1\fs20\sb60\fi-2880\li2880 NAN\tab
\tab
\tab
\tab
\pard\s32\plain\f1\fs20\sb60\fi-2880\li2880 invalid real number (NAN = Not A Number) 
\par
\pard\s32\plain\f1\fs20\sb60\fi-2880\li2880 NORMAL\tab
\tab
\tab
\pard\s32\plain\f1\fs20\sb60\fi-2880\li2880 a normal number \par
\pard\s32\plain\f1\fs20\sb60\fi-2880\li2880 POSINF\tab
\tab
\tab
\pard\s32\plain\f1\fs20\sb60\fi-2880\li2880 + infinity \par
\pard\s32\plain\f1\fs20\sb60\fi-2880\li2880 ZERO\tab
\tab
\tab
\par
\pard\s32\plain\f1\fs20\sb60\fi-2880\li2880 DENORMAL\tab
\tab
\pard\s32\plain\f1\fs20\sb60\fi-2880\li2880 a number whose representation is not as precise as the data type used (REAL or LONGREAL) would suggest; this is due to restrictions of the internal representation of floating point numbers. 
\par
\pard\s32\plain\f1\fs20\sb60\fi-2880\li2880 IMPOSSIBLE\tab
\tab
\par
\pard\s32\plain\f1\fs20\sb60\fi-2880\li2880 NEGINF\tab
\tab
\tab
\pard\s32\plain\f1\fs20\sb60\fi-2880\li2880 - infinity \par
\pard\s29\plain\li0\sb180\f1\fs24\b Procedures\par
\pard\s30\plain\li0\sb60\f1\fs20 {\strike\cf5 Log2}{\v Float_Log2}\par
{\strike\cf5 Log2L}{\v Float_Log2L}\par
{\strike\cf5 Ln}{\v Float_Ln}\par
{\strike\cf5 LnL}{\v Float_LnL}\par
{\strike\cf5 Log10}{\v Float_Log10}\par
{\strike\cf5 Log10L}{\v Float_Log10L}\par
{\strike\cf5 Exp}{\v Float_Exp}\par
{\strike\cf5 ExpL}{\v Float_ExpL}\par
{\strike\cf5 Sqrt}{\v Float_Sqrt}\par
{\strike\cf5 SqrtL}{\v Float_SqrtL}\par
{\strike\cf5 Cos}{\v Float_Cos}\par
{\strike\cf5 CosL}{\v Float_CosL}\par
{\strike\cf5 Sin}{\v Float_Sin}\par
{\strike\cf5 SinL}{\v Float_SinL}\par
{\strike\cf5 Tan}{\v Float_Tan}\par
{\strike\cf5 TanL}{\v Float_TanL}\par
{\strike\cf5 ArcTan}{\v Float_ArcTan}\par
{\strike\cf5 ArcTanL}{\v Float_ArcTanL}\par
{\strike\cf5 ArcSin}{\v Float_ArcSin}\par
{\strike\cf5 ArcSinL}{\v Float_ArcSinL}\par
{\strike\cf5 KindOfNumber}{\v Float_KindOfNumber}\par
{\strike\cf5 KindOfNumberL}{\v Float_KindOfNumberL}\par
{\strike\cf5 ValResult}{\v Float_ValResult}\par
{\strike\cf5 Val}{\v Float_Val}\par
{\strike\cf5 StrF}{\v Float_StrF}\par
{\strike\cf5 Str}{\v Float_Str}\par
{\strike\cf5 StrL}{\v Float_StrL}\par
\page
{\ {\super #}\footnote \pard\plain{\super #}Float_Log2}{\ {\super $}\footnote \pard\plain{\super 
$}Float.Log2}{\ {\super K}\footnote \pard\plain{\super K}Log2}\pard\s28\plain\li0\sb120\sa120\keepn\f1\fs28\b 
Log2\par
\pard\s31\plain\li0\sb120\sa120\f1\fs20\b defined in module {\strike\cf5 Float}{\v 
Float}\par
\pard\s29\plain\li0\sb180\f1\fs24\b Syntax\par
\pard\s27\plain\li0\sb120\tx1702\f2\fs20 PROCEDURE Log2(x:REAL):REAL\par
\pard\s29\plain\li0\sb180\f1\fs24\b Description\par
\pard\s30\plain\li0\sb60\f1\fs20 The return value is the logarithm base 2 of {\b 
x}. \par
\page
{\ {\super #}\footnote \pard\plain{\super #}Float_Log2L}{\ {\super $}\footnote \pard\plain{\super 
$}Float.Log2L}{\ {\super K}\footnote \pard\plain{\super K}Log2L}\pard\s28\plain\li0\sb120\sa120\keepn\f1\fs28\b 
Log2L\par
\pard\s31\plain\li0\sb120\sa120\f1\fs20\b defined in module {\strike\cf5 Float}{\v 
Float}\par
\pard\s29\plain\li0\sb180\f1\fs24\b Syntax\par
\pard\s27\plain\li0\sb120\tx1702\f2\fs20 PROCEDURE Log2L(x:LONGREAL):LONGREAL\par

\pard\s29\plain\li0\sb180\f1\fs24\b Description\par
\pard\s30\plain\li0\sb60\f1\fs20 The return value is the logarithm base 2 of {\b 
x}. \par
\page
{\ {\super #}\footnote \pard\plain{\super #}Float_Ln}{\ {\super $}\footnote \pard\plain{\super 
$}Float.Ln}{\ {\super K}\footnote \pard\plain{\super K}Ln}\pard\s28\plain\li0\sb120\sa120\keepn\f1\fs28\b 
Ln\par
\pard\s31\plain\li0\sb120\sa120\f1\fs20\b defined in module {\strike\cf5 Float}{\v 
Float}\par
\pard\s29\plain\li0\sb180\f1\fs24\b Syntax\par
\pard\s27\plain\li0\sb120\tx1702\f2\fs20 PROCEDURE Ln(x:REAL):REAL\par
\pard\s29\plain\li0\sb180\f1\fs24\b Description\par
\pard\s30\plain\li0\sb60\f1\fs20 The return value is the natural logarithm (base e) of 
{\b x}. \par
\page
{\ {\super #}\footnote \pard\plain{\super #}Float_LnL}{\ {\super $}\footnote \pard\plain{\super 
$}Float.LnL}{\ {\super K}\footnote \pard\plain{\super K}LnL}\pard\s28\plain\li0\sb120\sa120\keepn\f1\fs28\b 
LnL\par
\pard\s31\plain\li0\sb120\sa120\f1\fs20\b defined in module {\strike\cf5 Float}{\v 
Float}\par
\pard\s29\plain\li0\sb180\f1\fs24\b Syntax\par
\pard\s27\plain\li0\sb120\tx1702\f2\fs20 PROCEDURE LnL(x:LONGREAL):LONGREAL\par
\pard\s29\plain\li0\sb180\f1\fs24\b Description\par
\pard\s30\plain\li0\sb60\f1\fs20 The return value is the natural logarithm (base e) of 
{\b x}. \par
\page
{\ {\super #}\footnote \pard\plain{\super #}Float_Log10}{\ {\super $}\footnote \pard\plain{\super 
$}Float.Log10}{\ {\super K}\footnote \pard\plain{\super K}Log10}\pard\s28\plain\li0\sb120\sa120\keepn\f1\fs28\b 
Log10\par
\pard\s31\plain\li0\sb120\sa120\f1\fs20\b defined in module {\strike\cf5 Float}{\v 
Float}\par
\pard\s29\plain\li0\sb180\f1\fs24\b Syntax\par
\pard\s27\plain\li0\sb120\tx1702\f2\fs20 PROCEDURE Log10(x:REAL):REAL\par
\pard\s29\plain\li0\sb180\f1\fs24\b Description\par
\pard\s30\plain\li0\sb60\f1\fs20 The return value is the logarithm base 10 of {\b 
x}. \par
\page
{\ {\super #}\footnote \pard\plain{\super #}Float_Log10L}{\ {\super $}\footnote \pard\plain{\super 
$}Float.Log10L}{\ {\super K}\footnote \pard\plain{\super K}Log10L}\pard\s28\plain\li0\sb120\sa120\keepn\f1\fs28\b 
Log10L\par
\pard\s31\plain\li0\sb120\sa120\f1\fs20\b defined in module {\strike\cf5 Float}{\v 
Float}\par
\pard\s29\plain\li0\sb180\f1\fs24\b Syntax\par
\pard\s27\plain\li0\sb120\tx1702\f2\fs20 PROCEDURE Log10L(x:LONGREAL):LONGREAL\par

\pard\s29\plain\li0\sb180\f1\fs24\b Description\par
\pard\s30\plain\li0\sb60\f1\fs20 The return value is the logarithm base 10 of {\b 
x}. \par
\page
{\ {\super #}\footnote \pard\plain{\super #}Float_Exp}{\ {\super $}\footnote \pard\plain{\super 
$}Float.Exp}{\ {\super K}\footnote \pard\plain{\super K}Exp}\pard\s28\plain\li0\sb120\sa120\keepn\f1\fs28\b 
Exp\par
\pard\s31\plain\li0\sb120\sa120\f1\fs20\b defined in module {\strike\cf5 Float}{\v 
Float}\par
\pard\s29\plain\li0\sb180\f1\fs24\b Syntax\par
\pard\s27\plain\li0\sb120\tx1702\f2\fs20 PROCEDURE Exp(x, y:REAL):REAL\par
\pard\s29\plain\li0\sb180\f1\fs24\b Description\par
\pard\s30\plain\li0\sb60\f1\fs20 The return value is {\b x} to the power of {\b y
}.\par
If the value is too big for the exact representation in the floating point format a special code for the result infinity is returned.
\par
The valid range for {\b x} comprises only positive numbers. If {\b x} is negative
 a special code is returned indicating that the result is an invalid number. \par

\page
{\ {\super #}\footnote \pard\plain{\super #}Float_ExpL}{\ {\super $}\footnote \pard\plain{\super 
$}Float.ExpL}{\ {\super K}\footnote \pard\plain{\super K}ExpL}\pard\s28\plain\li0\sb120\sa120\keepn\f1\fs28\b 
ExpL\par
\pard\s31\plain\li0\sb120\sa120\f1\fs20\b defined in module {\strike\cf5 Float}{\v 
Float}\par
\pard\s29\plain\li0\sb180\f1\fs24\b Syntax\par
\pard\s27\plain\li0\sb120\tx1702\f2\fs20 PROCEDURE ExpL(x, y:LONGREAL):LONGREAL\par

\pard\s29\plain\li0\sb180\f1\fs24\b Description\par
\pard\s30\plain\li0\sb60\f1\fs20 The return value is {\b x} to the power of {\b y
}.\par
If the value is too big for the exact representation in the floating point format a special code for the result infinity is returned.
\par
The valid range for {\b x} comprises only positive numbers. If {\b x} is negative
 a special code is returned indicating that the result is an invalid number. \par

\page
{\ {\super #}\footnote \pard\plain{\super #}Float_Sqrt}{\ {\super $}\footnote \pard\plain{\super 
$}Float.Sqrt}{\ {\super K}\footnote \pard\plain{\super K}Sqrt}\pard\s28\plain\li0\sb120\sa120\keepn\f1\fs28\b 
Sqrt\par
\pard\s31\plain\li0\sb120\sa120\f1\fs20\b defined in module {\strike\cf5 Float}{\v 
Float}\par
\pard\s29\plain\li0\sb180\f1\fs24\b Syntax\par
\pard\s27\plain\li0\sb120\tx1702\f2\fs20 PROCEDURE Sqrt(x:REAL):REAL\par
\pard\s29\plain\li0\sb180\f1\fs24\b Description\par
\pard\s30\plain\li0\sb60\f1\fs20 The return value is the square root of {\b x}.\par

If {\b x} is smaller than zero a special code is returned indicating that the result is an invalid number.
\par
\page
{\ {\super #}\footnote \pard\plain{\super #}Float_SqrtL}{\ {\super $}\footnote \pard\plain{\super 
$}Float.SqrtL}{\ {\super K}\footnote \pard\plain{\super K}SqrtL}\pard\s28\plain\li0\sb120\sa120\keepn\f1\fs28\b 
SqrtL\par
\pard\s31\plain\li0\sb120\sa120\f1\fs20\b defined in module {\strike\cf5 Float}{\v 
Float}\par
\pard\s29\plain\li0\sb180\f1\fs24\b Syntax\par
\pard\s27\plain\li0\sb120\tx1702\f2\fs20 PROCEDURE SqrtL(x:LONGREAL):LONGREAL\par

\pard\s29\plain\li0\sb180\f1\fs24\b Description\par
\pard\s30\plain\li0\sb60\f1\fs20 The return value is the square root of {\b x}.\par

If {\b x} is smaller than zero a special code is returned indicating that the result is an invalid number.
\par
\page
{\ {\super #}\footnote \pard\plain{\super #}Float_Cos}{\ {\super $}\footnote \pard\plain{\super 
$}Float.Cos}{\ {\super K}\footnote \pard\plain{\super K}Cos}\pard\s28\plain\li0\sb120\sa120\keepn\f1\fs28\b 
Cos\par
\pard\s31\plain\li0\sb120\sa120\f1\fs20\b defined in module {\strike\cf5 Float}{\v 
Float}\par
\pard\s29\plain\li0\sb180\f1\fs24\b Syntax\par
\pard\s27\plain\li0\sb120\tx1702\f2\fs20 PROCEDURE Cos(x:REAL):REAL\par
\pard\s29\plain\li0\sb180\f1\fs24\b Description\par
\pard\s30\plain\li0\sb60\f1\fs20 The return value is the cosine of {\b x} in radians. 
\par
\page
{\ {\super #}\footnote \pard\plain{\super #}Float_CosL}{\ {\super $}\footnote \pard\plain{\super 
$}Float.CosL}{\ {\super K}\footnote \pard\plain{\super K}CosL}\pard\s28\plain\li0\sb120\sa120\keepn\f1\fs28\b 
CosL\par
\pard\s31\plain\li0\sb120\sa120\f1\fs20\b defined in module {\strike\cf5 Float}{\v 
Float}\par
\pard\s29\plain\li0\sb180\f1\fs24\b Syntax\par
\pard\s27\plain\li0\sb120\tx1702\f2\fs20 PROCEDURE CosL(x:LONGREAL):LONGREAL\par
\pard\s29\plain\li0\sb180\f1\fs24\b Description\par
\pard\s30\plain\li0\sb60\f1\fs20 The return value is the cosine of {\b x} in radians. 
\par
\page
{\ {\super #}\footnote \pard\plain{\super #}Float_Sin}{\ {\super $}\footnote \pard\plain{\super 
$}Float.Sin}{\ {\super K}\footnote \pard\plain{\super K}Sin}\pard\s28\plain\li0\sb120\sa120\keepn\f1\fs28\b 
Sin\par
\pard\s31\plain\li0\sb120\sa120\f1\fs20\b defined in module {\strike\cf5 Float}{\v 
Float}\par
\pard\s29\plain\li0\sb180\f1\fs24\b Syntax\par
\pard\s27\plain\li0\sb120\tx1702\f2\fs20 PROCEDURE Sin(x:REAL):REAL\par
\pard\s29\plain\li0\sb180\f1\fs24\b Description\par
\pard\s30\plain\li0\sb60\f1\fs20 The return value is the sine of {\b x} in radians. 
\par
\page
{\ {\super #}\footnote \pard\plain{\super #}Float_SinL}{\ {\super $}\footnote \pard\plain{\super 
$}Float.SinL}{\ {\super K}\footnote \pard\plain{\super K}SinL}\pard\s28\plain\li0\sb120\sa120\keepn\f1\fs28\b 
SinL\par
\pard\s31\plain\li0\sb120\sa120\f1\fs20\b defined in module {\strike\cf5 Float}{\v 
Float}\par
\pard\s29\plain\li0\sb180\f1\fs24\b Syntax\par
\pard\s27\plain\li0\sb120\tx1702\f2\fs20 PROCEDURE SinL(x:LONGREAL):LONGREAL\par
\pard\s29\plain\li0\sb180\f1\fs24\b Description\par
\pard\s30\plain\li0\sb60\f1\fs20 The return value is the sine of {\b x} in radians. 
\par
\page
{\ {\super #}\footnote \pard\plain{\super #}Float_Tan}{\ {\super $}\footnote \pard\plain{\super 
$}Float.Tan}{\ {\super K}\footnote \pard\plain{\super K}Tan}\pard\s28\plain\li0\sb120\sa120\keepn\f1\fs28\b 
Tan\par
\pard\s31\plain\li0\sb120\sa120\f1\fs20\b defined in module {\strike\cf5 Float}{\v 
Float}\par
\pard\s29\plain\li0\sb180\f1\fs24\b Syntax\par
\pard\s27\plain\li0\sb120\tx1702\f2\fs20 PROCEDURE Tan(x:REAL):REAL\par
\pard\s29\plain\li0\sb180\f1\fs24\b Description\par
\pard\s30\plain\li0\sb60\f1\fs20 The return value is the tangent of {\b x} in radians. 
\par
\page
{\ {\super #}\footnote \pard\plain{\super #}Float_TanL}{\ {\super $}\footnote \pard\plain{\super 
$}Float.TanL}{\ {\super K}\footnote \pard\plain{\super K}TanL}\pard\s28\plain\li0\sb120\sa120\keepn\f1\fs28\b 
TanL\par
\pard\s31\plain\li0\sb120\sa120\f1\fs20\b defined in module {\strike\cf5 Float}{\v 
Float}\par
\pard\s29\plain\li0\sb180\f1\fs24\b Syntax\par
\pard\s27\plain\li0\sb120\tx1702\f2\fs20 PROCEDURE TanL(x:LONGREAL):LONGREAL\par
\pard\s29\plain\li0\sb180\f1\fs24\b Description\par
\pard\s30\plain\li0\sb60\f1\fs20 The return value is the tangent of {\b x} in radians. 
\par
\page
{\ {\super #}\footnote \pard\plain{\super #}Float_ArcTan}{\ {\super $}\footnote \pard\plain{\super 
$}Float.ArcTan}{\ {\super K}\footnote \pard\plain{\super K}ArcTan}\pard\s28\plain\li0\sb120\sa120\keepn\f1\fs28\b 
ArcTan\par
\pard\s31\plain\li0\sb120\sa120\f1\fs20\b defined in module {\strike\cf5 Float}{\v 
Float}\par
\pard\s29\plain\li0\sb180\f1\fs24\b Syntax\par
\pard\s27\plain\li0\sb120\tx1702\f2\fs20 PROCEDURE ArcTan(x:REAL):REAL\par
\pard\s29\plain\li0\sb180\f1\fs24\b Description\par
\pard\s30\plain\li0\sb60\f1\fs20 The return value is the arc tangent of {\b x} in radians. 
\par
\page
{\ {\super #}\footnote \pard\plain{\super #}Float_ArcTanL}{\ {\super $}\footnote \pard\plain{\super 
$}Float.ArcTanL}{\ {\super K}\footnote \pard\plain{\super K}ArcTanL}\pard\s28\plain\li0\sb120\sa120\keepn\f1\fs28\b 
ArcTanL\par
\pard\s31\plain\li0\sb120\sa120\f1\fs20\b defined in module {\strike\cf5 Float}{\v 
Float}\par
\pard\s29\plain\li0\sb180\f1\fs24\b Syntax\par
\pard\s27\plain\li0\sb120\tx1702\f2\fs20 PROCEDURE ArcTanL(x:LONGREAL):LONGREAL\par

\pard\s29\plain\li0\sb180\f1\fs24\b Description\par
\pard\s30\plain\li0\sb60\f1\fs20 The return value is the arc tangent of {\b x} in radians. 
\par
\page
{\ {\super #}\footnote \pard\plain{\super #}Float_ArcSin}{\ {\super $}\footnote \pard\plain{\super 
$}Float.ArcSin}{\ {\super K}\footnote \pard\plain{\super K}ArcSin}\pard\s28\plain\li0\sb120\sa120\keepn\f1\fs28\b 
ArcSin\par
\pard\s31\plain\li0\sb120\sa120\f1\fs20\b defined in module {\strike\cf5 Float}{\v 
Float}\par
\pard\s29\plain\li0\sb180\f1\fs24\b Syntax\par
\pard\s27\plain\li0\sb120\tx1702\f2\fs20 PROCEDURE ArcSin(x:REAL):REAL\par
\pard\s29\plain\li0\sb180\f1\fs24\b Description\par
\pard\s30\plain\li0\sb60\f1\fs20 The return value is the arc sine of {\b x} in radians.
\par
The arc cosine is not implemented as a separate function as it can be easily calculated using Pi/2 - ArcSin(x). 
\par
\page
{\ {\super #}\footnote \pard\plain{\super #}Float_ArcSinL}{\ {\super $}\footnote \pard\plain{\super 
$}Float.ArcSinL}{\ {\super K}\footnote \pard\plain{\super K}ArcSinL}\pard\s28\plain\li0\sb120\sa120\keepn\f1\fs28\b 
ArcSinL\par
\pard\s31\plain\li0\sb120\sa120\f1\fs20\b defined in module {\strike\cf5 Float}{\v 
Float}\par
\pard\s29\plain\li0\sb180\f1\fs24\b Syntax\par
\pard\s27\plain\li0\sb120\tx1702\f2\fs20 PROCEDURE ArcSinL(x:LONGREAL):LONGREAL\par

\pard\s29\plain\li0\sb180\f1\fs24\b Description\par
\pard\s30\plain\li0\sb60\f1\fs20 The return value is the arc sine of {\b x} in radians.
\par
The arc cosine is not implemented as a separate function as it can be easily calculated using Pi/2 - ArcSin(x). 
\par
\page
{\ {\super #}\footnote \pard\plain{\super #}Float_KindOfNumber}{\ {\super $}\footnote \pard\plain{\super 
$}Float.KindOfNumber}{\ {\super K}\footnote \pard\plain{\super K}KindOfNumber}\pard\s28
\plain\li0\sb120\sa120\keepn\f1\fs28\b KindOfNumber\par
\pard\s31\plain\li0\sb120\sa120\f1\fs20\b defined in module {\strike\cf5 Float}{\v 
Float}\par
\pard\s29\plain\li0\sb180\f1\fs24\b Syntax\par
\pard\s27\plain\li0\sb120\tx1702\f2\fs20 PROCEDURE KindOfNumber(x:REAL):INTEGER\par

\pard\s29\plain\li0\sb180\f1\fs24\b Description\par
\pard\s30\plain\li0\sb60\f1\fs20 This function checks if {\b x} is a normal number or if it contains a
 special value. The following constants are intended to be compared with the return
 values of the function:\par
NAN          not a number\par
NORMAL       ordinary number\par
POSINF       positive infinity\par
ZERO         zero\par
DENORMAL     number stored with reduced precision\par
NEGINF       negative infinity\par
Note that the return value of the function may also be a value different from the defined constants. In this case a numerical error has occurred
 which was not expected in that form. The parameter {\b x} does not contain a valid numerical value in this case. 
\par
\page
{\ {\super #}\footnote \pard\plain{\super #}Float_KindOfNumberL}{\ {\super $}\footnote \pard\plain{\super 
$}Float.KindOfNumberL}{\ {\super K}\footnote \pard\plain{\super K}KindOfNumberL}\pard\s28
\plain\li0\sb120\sa120\keepn\f1\fs28\b KindOfNumberL\par
\pard\s31\plain\li0\sb120\sa120\f1\fs20\b defined in module {\strike\cf5 Float}{\v 
Float}\par
\pard\s29\plain\li0\sb180\f1\fs24\b Syntax\par
\pard\s27\plain\li0\sb120\tx1702\f2\fs20 PROCEDURE KindOfNumberL(x:LONGREAL):INTEGER
\par
\pard\s29\plain\li0\sb180\f1\fs24\b Description\par
\pard\s30\plain\li0\sb60\f1\fs20 Returns one of the following values which characterizes the contents of 
{\b x}:\par
UNSUPPORTED NAN          not a number NORMAL       ordinary number POSINF       positive infinity
 ZERO         zero DENORMAL     number stored with reduced precision NEGINF       negative infinity
\par
\page
{\ {\super #}\footnote \pard\plain{\super #}Float_ValResult}{\ {\super $}\footnote \pard\plain{\super 
$}Float.ValResult}{\ {\super K}\footnote \pard\plain{\super K}ValResult}\pard\s28
\plain\li0\sb120\sa120\keepn\f1\fs28\b ValResult\par
\pard\s31\plain\li0\sb120\sa120\f1\fs20\b defined in module {\strike\cf5 Float}{\v 
Float}\par
\pard\s29\plain\li0\sb180\f1\fs24\b Syntax\par
\pard\s27\plain\li0\sb120\tx1702\f2\fs20 PROCEDURE ValResult(t:ARRAY OF CHAR):INTEGER
\par
\pard\s29\plain\li0\sb180\f1\fs24\b Description\par
\pard\s30\plain\li0\sb60\f1\fs20 This function checks if the string {\b t} can be converted to a number and
 what kind of floating point type is at least required for storing it.\par
The following constants are possible return values of the function:\par
ISREAL: {\b t} contains a number which can be stored in a REAL variable.\par
ISLONGREAL: {\b t} contains a number which can be stored in a LONGREAL variable.\par

ISOUTOFRANGE: {\b t} contains a number which is too small or too big to be stored in a LONGREAL variable.
\par
STRINGEMPTY: {\b t} is empty or contains nothing but blanks.\par
STRINGILLEGAL: {\b t} contains characters that must not occur in a number.\par
The constants have a numerical order defined relatively to each other: ISREAL < ISLONGREAL < ISOUTOFRANGE < (STRINGEMPTY, STRINGILLEGAL)
\par
This definition makes it easier to find out if, for example, a number can be stored in a LONGREAL variable. 
\par
\page
{\ {\super #}\footnote \pard\plain{\super #}Float_Val}{\ {\super $}\footnote \pard\plain{\super 
$}Float.Val}{\ {\super K}\footnote \pard\plain{\super K}Val}\pard\s28\plain\li0\sb120\sa120\keepn\f1\fs28\b 
Val\par
\pard\s31\plain\li0\sb120\sa120\f1\fs20\b defined in module {\strike\cf5 Float}{\v 
Float}\par
\pard\s29\plain\li0\sb180\f1\fs24\b Syntax\par
\pard\s27\plain\li0\sb120\tx1702\f2\fs20 PROCEDURE Val(t:ARRAY OF CHAR):LONGREAL\par

\pard\s29\plain\li0\sb180\f1\fs24\b Description\par
\pard\s30\plain\li0\sb60\f1\fs20 The string {\b t} is converted to a number and returned as the result.
\par
If the character sequence in {\b t} does not represent a real number and the conversion fails the smallest negative number (MIN(LONGREAL)) is
 returned.\par
Blanks at the beginning and the end of {\b t} are ignored. The number must not contain blanks within itself. 
\par
\page
{\ {\super #}\footnote \pard\plain{\super #}Float_StrF}{\ {\super $}\footnote \pard\plain{\super 
$}Float.StrF}{\ {\super K}\footnote \pard\plain{\super K}StrF}\pard\s28\plain\li0\sb120\sa120\keepn\f1\fs28\b 
StrF\par
\pard\s31\plain\li0\sb120\sa120\f1\fs20\b defined in module {\strike\cf5 Float}{\v 
Float}\par
\pard\s29\plain\li0\sb180\f1\fs24\b Syntax\par
\pard\s27\plain\li0\sb120\tx1702\f2\fs20 PROCEDURE StrF(x:LONGREAL; \line
               n1, n2:INTEGER; \line
               VAR t:ARRAY OF CHAR)\par
\pard\s29\plain\li0\sb180\f1\fs24\b Description\par
\pard\s30\plain\li0\sb60\f1\fs20 The number {\b x} is converted to a string and the result is returned in 
{\b t}. The representation is effected with a fixed number of digits before ({\b 
n1}) and after ({\b n2}) the decimal point.\par
If {\b t} is not large enough to hold the selected output format or if the number cannot be represented with 
{\b n1} digits before the comma, {\b t} is filled with "$" characters.\par
The length of the result totals {\b n1} + {\b n2} + 2 characters: digits for the integral part + digits for the fractional part + decimal point + sign.
\par
Examples for StrF(x,4,2,t):\par
x=1 -> t="    1.00"\par
x=-125 -> t=" -125.00"\par
x=3300790 -> t="$$$$$$$$"\par
x=0.1 -> t="    0.10"\par
x=33007 -> t="$$$$$$$$"\par
x=5887.009 -> t=" 5887.01" \par
\page
{\ {\super #}\footnote \pard\plain{\super #}Float_Str}{\ {\super $}\footnote \pard\plain{\super 
$}Float.Str}{\ {\super K}\footnote \pard\plain{\super K}Str}\pard\s28\plain\li0\sb120\sa120\keepn\f1\fs28\b 
Str\par
\pard\s31\plain\li0\sb120\sa120\f1\fs20\b defined in module {\strike\cf5 Float}{\v 
Float}\par
\pard\s29\plain\li0\sb180\f1\fs24\b Syntax\par
\pard\s27\plain\li0\sb120\tx1702\f2\fs20 PROCEDURE Str(x:LONGREAL; \line
              VAR t:ARRAY OF CHAR)\par
\pard\s29\plain\li0\sb180\f1\fs24\b Description\par
\pard\s30\plain\li0\sb60\f1\fs20 The number {\b x} is converted to a string and the result is returned in 
{\b t}.\par
If {\b t} is not large enough to hold all characters of the number, {\b t} is filled with "$" characters.
\par
Examples for Str(x,t):\par
x=4 -> t="1e0"\par
x=-125 -> t="-1.25e2"\par
x=3300790 -> t="3.30079e6"\par
x=0.1 -> t="1e-1"\par
x=33007000 -> t="3.3007e7"\par
x=Log2(0) -> t="-infinity"\par
KindOfNumber(x)=NAN -> t="error" \par
\page
{\ {\super #}\footnote \pard\plain{\super #}Float_StrL}{\ {\super $}\footnote \pard\plain{\super 
$}Float.StrL}{\ {\super K}\footnote \pard\plain{\super K}StrL}\pard\s28\plain\li0\sb120\sa120\keepn\f1\fs28\b 
StrL\par
\pard\s31\plain\li0\sb120\sa120\f1\fs20\b defined in module {\strike\cf5 Float}{\v 
Float}\par
\pard\s29\plain\li0\sb180\f1\fs24\b Syntax\par
\pard\s27\plain\li0\sb120\tx1702\f2\fs20 PROCEDURE StrL(x:LONGREAL; \line
               n:INTEGER; \line
               VAR t:ARRAY OF CHAR)\par
\pard\s29\plain\li0\sb180\f1\fs24\b Description\par
\pard\s30\plain\li0\sb60\f1\fs20 The number {\b x} is converted to a string of length 
{\b n} and the result is stored right aligned in {\b t}. If necessary the number of digits is reduced
 and the number is rounded.\par
The minimum value for {\b n} is five characters. Smaller values are ignored.\par
If {\b t} is not large enough to hold all characters of the number, it is filled with "$" characters. Even though the result is reduced to 
{\b n} characters {\b t} must be of a sufficient size to contain the full number.
\par
Examples for StrL(x,8,t):\par
x=1 -> t="     1e0"\par
x=-125 -> t=" -1.25e2"\par
x=3300790 -> t="3.3008e6"\par
x=0.1 -> t="    1e-1"\par
x=33007000 -> t="3.3007e7" \par
\page
{\ {\super #}\footnote \pard\plain{\super #}In}{\ {\super $}\footnote \pard\plain{\super 
$}module In}{\ {\super K}\footnote \pard\plain{\super K}In}\pard\s28\plain\li0\sb120\sa120\keepn\f1\fs28\b 
Module In\par
\pard\s30\plain\li0\sb60\f1\fs20 This module provides simple, data-stream-oriented input. The source of input
 can be from the keyboard or from a file. The input from a file is especially useful for the program development as input test data can be prepared and
 saved in a file. This file is then selected as input source after each program start to run a complete test.
\par
The interface of this module is call-compatible with the standard stated in the Oakwood Guidelines [OAK93] for a data-stream-oriented input module.
 If the input is made from a file the latter can be selected in a pop-up dialog. 
This file is then read character by character, according to the input functions that are called. As this must be a text file an input file can be created with
 any text editor. In case of input functions like LongInt the procedure reads from the file until a character is detected that does not conform to the rules
 defined in the EBNF syntax. Leading blanks, tabulators, and CR and LF characters are neglected, with the sole exception of Char.
\par
When the program is started the keyboard is the default input medium. With the menu "Pane" it is possible to switch to a file as input source at any
 time.\par
The end of a keyboard input stream is indicated by pressing the "End" key. When using a file as input source the end of the input stream is signalled
 by the end of file.\par
\pard\s29\plain\li0\sb180\f1\fs24\b Variables\par
\pard\s30\plain\li0\sb60\f1\fs20 {\ul\cf5 Done}{\v In_Done}\par
\pard\s30\plain\li0\sb60\f1\fs20 {\ul\cf5 echo}{\v In_echo}\par
\pard\s29\plain\li0\sb180\f1\fs24\b Procedures\par
\pard\s30\plain\li0\sb60\f1\fs20 {\strike\cf5 Char}{\v In_Char}\par
{\strike\cf5 Echo}{\v In_Echo}\par
{\strike\cf5 Int}{\v In_Int}\par
{\strike\cf5 LongInt}{\v In_LongInt}\par
{\strike\cf5 LongReal}{\v In_LongReal}\par
{\strike\cf5 Name}{\v In_Name}\par
{\strike\cf5 Open}{\v In_Open}\par
{\strike\cf5 Prompt}{\v In_Prompt}\par
{\strike\cf5 Real}{\v In_Real}\par
{\strike\cf5 String}{\v In_String}\par
\page
{\ {\super #}\footnote \pard\plain{\super #}In_Char}{\ {\super $}\footnote \pard\plain{\super 
$}In.Char}{\ {\super K}\footnote \pard\plain{\super K}Char}\pard\s28\plain\li0\sb120\sa120\keepn\f1\fs28\b 
Char\par
\pard\s31\plain\li0\sb120\sa120\f1\fs20\b defined in module {\strike\cf5 In}{\v In
}\par
\pard\s29\plain\li0\sb180\f1\fs24\b Syntax\par
\pard\s27\plain\li0\sb120\tx1702\f2\fs20 PROCEDURE Char(VAR ch:CHAR)\par
\pard\s29\plain\li0\sb180\f1\fs24\b Description\par
\pard\s30\plain\li0\sb60\f1\fs20 The next character from the data stream is returned in 
{\b ch}. \par
\page
{\ {\super #}\footnote \pard\plain{\super #}In_Echo}{\ {\super $}\footnote \pard\plain{\super 
$}In.Echo}{\ {\super K}\footnote \pard\plain{\super K}Echo}\pard\s28\plain\li0\sb120\sa120\keepn\f1\fs28\b 
Echo\par
\pard\s31\plain\li0\sb120\sa120\f1\fs20\b defined in module {\strike\cf5 In}{\v In
}\par
\pard\s29\plain\li0\sb180\f1\fs24\b Syntax\par
\pard\s27\plain\li0\sb120\tx1702\f2\fs20 PROCEDURE Echo(x:BOOLEAN)\par
\pard\s29\plain\li0\sb180\f1\fs24\b Description\par
\pard\s30\plain\li0\sb60\f1\fs20 With {\b x}=TRUE an automatic output of all input can be obtained using
 the module Out. When the program is started this option is not active. The setting can be "changed" during the program execution at any time.
\par
This procedure is not included in the Oakwood Guidelines. \par
\page
{\ {\super #}\footnote \pard\plain{\super #}In_Int}{\ {\super $}\footnote \pard\plain{\super 
$}In.Int}{\ {\super K}\footnote \pard\plain{\super K}Int}\pard\s28\plain\li0\sb120\sa120\keepn\f1\fs28\b 
Int\par
\pard\s31\plain\li0\sb120\sa120\f1\fs20\b defined in module {\strike\cf5 In}{\v In
}\par
\pard\s29\plain\li0\sb180\f1\fs24\b Syntax\par
\pard\s27\plain\li0\sb120\tx1702\f2\fs20 PROCEDURE Int(VAR i:INTEGER)\par
\pard\s29\plain\li0\sb180\f1\fs24\b Description\par
\pard\s30\plain\li0\sb60\f1\fs20 Reads from the input data stream according to the EBNF syntax rule
 IntConst = ["-"] (digit \{digit\} / digit \{hexDigit\} "H").\par
The result is converted to a number and returned in {\b i}. \par
\page
{\ {\super #}\footnote \pard\plain{\super #}In_LongInt}{\ {\super $}\footnote \pard\plain{\super 
$}In.LongInt}{\ {\super K}\footnote \pard\plain{\super K}LongInt}\pard\s28\plain\li0\sb120\sa120\keepn\f1\fs28\b 
LongInt\par
\pard\s31\plain\li0\sb120\sa120\f1\fs20\b defined in module {\strike\cf5 In}{\v In
}\par
\pard\s29\plain\li0\sb180\f1\fs24\b Syntax\par
\pard\s27\plain\li0\sb120\tx1702\f2\fs20 PROCEDURE LongInt(VAR l:LONGINT)\par
\pard\s29\plain\li0\sb180\f1\fs24\b Description\par
\pard\s30\plain\li0\sb60\f1\fs20 Reads from the input data stream according to the EBNF syntax rule
 IntConst = ["-"] (digit \{digit\} / digit \{hexDigit\} "H").\par
The result is converted to a number and returned in {\b l}. \par
\page
{\ {\super #}\footnote \pard\plain{\super #}In_LongReal}{\ {\super $}\footnote \pard\plain{\super 
$}In.LongReal}{\ {\super K}\footnote \pard\plain{\super K}LongReal}\pard\s28\plain\li0\sb120\sa120\keepn\f1\fs28\b 
LongReal\par
\pard\s31\plain\li0\sb120\sa120\f1\fs20\b defined in module {\strike\cf5 In}{\v In
}\par
\pard\s29\plain\li0\sb180\f1\fs24\b Syntax\par
\pard\s27\plain\li0\sb120\tx1702\f2\fs20 PROCEDURE LongReal(VAR x:LONGREAL)\par
\pard\s29\plain\li0\sb180\f1\fs24\b Description\par
\pard\s30\plain\li0\sb60\f1\fs20 Reads from the input data stream according to the EBNF syntax rule
 RealConst = ["-"] digit \{digit\} [ "." \{digit\}] ["E" ("+" / "-") digit \{digit\}].\par

The result is converted to a number and returned in {\b x}. \par
\page
{\ {\super #}\footnote \pard\plain{\super #}In_Name}{\ {\super $}\footnote \pard\plain{\super 
$}In.Name}{\ {\super K}\footnote \pard\plain{\super K}Name}\pard\s28\plain\li0\sb120\sa120\keepn\f1\fs28\b 
Name\par
\pard\s31\plain\li0\sb120\sa120\f1\fs20\b defined in module {\strike\cf5 In}{\v In
}\par
\pard\s29\plain\li0\sb180\f1\fs24\b Syntax\par
\pard\s27\plain\li0\sb120\tx1702\f2\fs20 PROCEDURE Name(VAR name:ARRAY OF CHAR)\par

\pard\s29\plain\li0\sb180\f1\fs24\b Description\par
\pard\s30\plain\li0\sb60\f1\fs20 Reads from the input data stream according to the EBNF syntax rule
 NameConst = nameChar \{nameChar\}. where nameChar denotes any character apart from the blank,
 the quotation mark, CR, or LF. \par
\page
{\ {\super #}\footnote \pard\plain{\super #}In_Open}{\ {\super $}\footnote \pard\plain{\super 
$}In.Open}{\ {\super K}\footnote \pard\plain{\super K}Open}\pard\s28\plain\li0\sb120\sa120\keepn\f1\fs28\b 
Open\par
\pard\s31\plain\li0\sb120\sa120\f1\fs20\b defined in module {\strike\cf5 In}{\v In
}\par
\pard\s29\plain\li0\sb180\f1\fs24\b Syntax\par
\pard\s27\plain\li0\sb120\tx1702\f2\fs20 PROCEDURE Open()\par
\pard\s29\plain\li0\sb180\f1\fs24\b Description\par
\pard\s30\plain\li0\sb60\f1\fs20 The input position is reset to the beginning of the data stream. The
 variable Done is initialized with TRUE. As input from the keyboard is also buffered internally, previous input can also be recalled. 
\par
\page
{\ {\super #}\footnote \pard\plain{\super #}In_Prompt}{\ {\super $}\footnote \pard\plain{\super 
$}In.Prompt}{\ {\super K}\footnote \pard\plain{\super K}Prompt}\pard\s28\plain\li0\sb120\sa120\keepn\f1\fs28\b 
Prompt\par
\pard\s31\plain\li0\sb120\sa120\f1\fs20\b defined in module {\strike\cf5 In}{\v In
}\par
\pard\s29\plain\li0\sb180\f1\fs24\b Syntax\par
\pard\s27\plain\li0\sb120\tx1702\f2\fs20 PROCEDURE Prompt(txt:ARRAY OF CHAR)\par
\pard\s29\plain\li0\sb180\f1\fs24\b Description\par
\pard\s30\plain\li0\sb60\f1\fs20 On executing the next input the string {\b txt} is displayed as a prompt instead of
 the default text (e.g., "In.Name"). If the input echo was switched on with Echo(TRUE), 
{\b txt} is also displayed in the output via the module Out.\par
This procedure is not included in the Oakwood Guidelines. \par
\page
{\ {\super #}\footnote \pard\plain{\super #}In_Real}{\ {\super $}\footnote \pard\plain{\super 
$}In.Real}{\ {\super K}\footnote \pard\plain{\super K}Real}\pard\s28\plain\li0\sb120\sa120\keepn\f1\fs28\b 
Real\par
\pard\s31\plain\li0\sb120\sa120\f1\fs20\b defined in module {\strike\cf5 In}{\v In
}\par
\pard\s29\plain\li0\sb180\f1\fs24\b Syntax\par
\pard\s27\plain\li0\sb120\tx1702\f2\fs20 PROCEDURE Real(VAR x:REAL)\par
\pard\s29\plain\li0\sb180\f1\fs24\b Description\par
\pard\s30\plain\li0\sb60\f1\fs20 Reads from the input data stream according to the EBNF syntax rule
 RealConst = ["-"] digit \{digit\} ["." \{digit\}] ["E" ("+" / "-") digit \{digit\}].\par

The result is converted to a number and returned in {\b x}. \par
\page
{\ {\super #}\footnote \pard\plain{\super #}In_String}{\ {\super $}\footnote \pard\plain{\super 
$}In.String}{\ {\super K}\footnote \pard\plain{\super K}String}\pard\s28\plain\li0\sb120\sa120\keepn\f1\fs28\b 
String\par
\pard\s31\plain\li0\sb120\sa120\f1\fs20\b defined in module {\strike\cf5 In}{\v In
}\par
\pard\s29\plain\li0\sb180\f1\fs24\b Syntax\par
\pard\s27\plain\li0\sb120\tx1702\f2\fs20 PROCEDURE String(VAR str:ARRAY OF CHAR)\par

\pard\s29\plain\li0\sb180\f1\fs24\b Description\par
\pard\s30\plain\li0\sb60\f1\fs20 Reads from the input data stream according to the EBNF syntax rule
 StringConst = '"' \{char\} '"'.\par
If the input medium is the keyboard and no leading quotation mark is detected, the procedure inserts one at the beginning and one at the
 end automatically. \par
\page
{\ {\super #}\footnote \pard\plain{\super #}In_Done}{\ {\super $}\footnote \pard\plain{\super 
$}In.Done}{\ {\super K}\footnote \pard\plain{\super K}Done}\pard\s30\plain\li0\sb60\f1\fs20 
{\b Done}\par
\pard\s27\plain\li0\sb120\tx1702\f2\fs20 Done*:BOOLEAN;\par
\page
{\ {\super #}\footnote \pard\plain{\super #}In_echo}{\ {\super $}\footnote \pard\plain{\super 
$}In.echo}{\ {\super K}\footnote \pard\plain{\super K}echo}\pard\s30\plain\li0\sb60\f1\fs20 
{\b echo}\par
\pard\s27\plain\li0\sb120\tx1702\f2\fs20 echo-:BOOLEAN;\par
\page
{\ {\super #}\footnote \pard\plain{\super #}OOBase}{\ {\super $}\footnote \pard\plain{\super 
$}module OOBase}{\ {\super K}\footnote \pard\plain{\super K}OOBase}\pard\s28\plain\li0\sb120\sa120\keepn\f1\fs28\b 
Module OOBase\par
\pard\s29\plain\li0\sb180\f1\fs24\b Constants\par
\pard\s32\plain\f1\fs20\sb60\fi-2880\li2880 TYP_ARRAY\tab
\tab
\pard\s32\plain\f1\fs20\sb60\fi-2880\li2880 \par
\pard\s32\plain\f1\fs20\sb60\fi-2880\li2880 TYP_DYNARRAY\tab
\pard\s32\plain\f1\fs20\sb60\fi-2880\li2880 \par
\pard\s32\plain\f1\fs20\sb60\fi-2880\li2880 TYP_RECORD\tab
\pard\s32\plain\f1\fs20\sb60\fi-2880\li2880 \par
\pard\s32\plain\f1\fs20\sb60\fi-2880\li2880 TYP_ENDRECORD\tab
\pard\s32\plain\f1\fs20\sb60\fi-2880\li2880 \par
\pard\s32\plain\f1\fs20\sb60\fi-2880\li2880 TYP_UNDEF\tab
\tab
\pard\s32\plain\f1\fs20\sb60\fi-2880\li2880 \par
\pard\s32\plain\f1\fs20\sb60\fi-2880\li2880 TYP_BYTE\tab
\tab
\pard\s32\plain\f1\fs20\sb60\fi-2880\li2880 \par
\pard\s32\plain\f1\fs20\sb60\fi-2880\li2880 TYP_BOOL\tab
\tab
\pard\s32\plain\f1\fs20\sb60\fi-2880\li2880 \par
\pard\s32\plain\f1\fs20\sb60\fi-2880\li2880 TYP_CHAR\tab
\tab
\pard\s32\plain\f1\fs20\sb60\fi-2880\li2880 \par
\pard\s32\plain\f1\fs20\sb60\fi-2880\li2880 TYP_SHORTINT\tab
\pard\s32\plain\f1\fs20\sb60\fi-2880\li2880 \par
\pard\s32\plain\f1\fs20\sb60\fi-2880\li2880 TYP_INT\tab
\tab
\tab
\pard\s32\plain\f1\fs20\sb60\fi-2880\li2880 \par
\pard\s32\plain\f1\fs20\sb60\fi-2880\li2880 TYP_LONGINT\tab
\pard\s32\plain\f1\fs20\sb60\fi-2880\li2880 \par
\pard\s32\plain\f1\fs20\sb60\fi-2880\li2880 TYP_REAL\tab
\tab
\pard\s32\plain\f1\fs20\sb60\fi-2880\li2880 \par
\pard\s32\plain\f1\fs20\sb60\fi-2880\li2880 TYP_LONGREAL\tab
\pard\s32\plain\f1\fs20\sb60\fi-2880\li2880 \par
\pard\s32\plain\f1\fs20\sb60\fi-2880\li2880 TYP_SET\tab
\tab
\tab
\pard\s32\plain\f1\fs20\sb60\fi-2880\li2880 \par
\pard\s32\plain\f1\fs20\sb60\fi-2880\li2880 TYP_STRING\tab
\tab
\pard\s32\plain\f1\fs20\sb60\fi-2880\li2880 \par
\pard\s32\plain\f1\fs20\sb60\fi-2880\li2880 TYP_NIL\tab
\tab
\tab
\pard\s32\plain\f1\fs20\sb60\fi-2880\li2880 \par
\pard\s32\plain\f1\fs20\sb60\fi-2880\li2880 TYP_NOTYP\tab
\tab
\pard\s32\plain\f1\fs20\sb60\fi-2880\li2880 \par
\pard\s32\plain\f1\fs20\sb60\fi-2880\li2880 TYP_POINTER\tab
\pard\s32\plain\f1\fs20\sb60\fi-2880\li2880 \par
\pard\s32\plain\f1\fs20\sb60\fi-2880\li2880 TYP_HDPOINTER\tab
\pard\s32\plain\f1\fs20\sb60\fi-2880\li2880 \par
\pard\s32\plain\f1\fs20\sb60\fi-2880\li2880 TYP_PROCTYP\tab
\pard\s32\plain\f1\fs20\sb60\fi-2880\li2880 \par
\pard\s29\plain\li0\sb180\f1\fs24\b Types\par
\pard\s30\plain\li0\sb60\f1\fs20 {\ul\cf5 Object}{\v OOBase_Object}\par
\pard\s29\plain\li0\sb180\f1\fs24\b Classes / Record Types\par
\pard\s30\plain\li0\sb60\f1\fs20 {\strike\cf5 ObjectT}{\v OOBase_ObjectT}\par
\pard\s29\plain\li0\sb180\f1\fs24\b Procedures\par
\pard\s30\plain\li0\sb60\f1\fs20 {\strike\cf5 Clone}{\v OOBase_Clone}\par
{\strike\cf5 ObjToName}{\v OOBase_ObjToName}\par
{\strike\cf5 NameToObj}{\v OOBase_NameToObj}\par
{\strike\cf5 TypeHasOffset}{\v OOBase_TypeHasOffset}\par
{\strike\cf5 TypeToName}{\v OOBase_TypeToName}\par
\page
{\ {\super #}\footnote \pard\plain{\super #}OOBase_Clone}{\ {\super $}\footnote \pard\plain{\super 
$}OOBase.Clone}{\ {\super K}\footnote \pard\plain{\super K}Clone}\pard\s28\plain\li0\sb120\sa120\keepn\f1\fs28\b 
Clone\par
\pard\s31\plain\li0\sb120\sa120\f1\fs20\b defined in module {\strike\cf5 OOBase}{\v 
OOBase}\par
\pard\s29\plain\li0\sb180\f1\fs24\b Syntax\par
\pard\s27\plain\li0\sb120\tx1702\f2\fs20 PROCEDURE Clone(obj:{\ul\cf5 Object}{\v 
OOBase_Object}):{\ul\cf5 Object}{\v OOBase_Object}\par
\pard\s29\plain\li0\sb180\f1\fs24\b Description\par
\pard\s30\plain\li0\sb60\f1\fs20 The object passed in obj is cloned. This means that a new object of
 the same class is created, which has the same state as the original object.\par
The same state has to be taken literal: if the original object contains any pointers to other objects, which should by design be private,
 the new object will contain pointers to the same objects and not possess new private copies of those.
\par
The return value is either a pointer to the cloned object or NIL if the function failed. 
\par
\page
{\ {\super #}\footnote \pard\plain{\super #}OOBase_ObjToName}{\ {\super $}\footnote \pard\plain{\super 
$}OOBase.ObjToName}{\ {\super K}\footnote \pard\plain{\super K}ObjToName}\pard\s28
\plain\li0\sb120\sa120\keepn\f1\fs28\b ObjToName\par
\pard\s31\plain\li0\sb120\sa120\f1\fs20\b defined in module {\strike\cf5 OOBase}{\v 
OOBase}\par
\pard\s29\plain\li0\sb180\f1\fs24\b Syntax\par
\pard\s27\plain\li0\sb120\tx1702\f2\fs20 PROCEDURE ObjToName(p:{\ul\cf5 Object}{\v 
OOBase_Object}; \line
                    VAR codeName, name:ARRAY OF CHAR)\par
\pard\s29\plain\li0\sb180\f1\fs24\b Parameters\par
\pard\s32\plain\f1\fs20\sb60\fi-2880\li2880 p\tab
\tab
\tab
\tab
\pard\s32\plain\f1\fs20\sb60\fi-2880\li2880 pointer to the object whose symbolic name should be determined 
\par
\pard\s32\plain\f1\fs20\sb60\fi-2880\li2880 codeName\tab
\tab
\pard\s32\plain\f1\fs20\sb60\fi-2880\li2880 returns the full pathname of the .EXE or .DLL file containing the code of the class implementation 
\par
\pard\s32\plain\f1\fs20\sb60\fi-2880\li2880 name\tab
\tab
\tab
\pard\s32\plain\f1\fs20\sb60\fi-2880\li2880 returns the qualified class name of the object in the form moduleName.typeName 
\par
\pard\s29\plain\li0\sb180\f1\fs24\b Description\par
\pard\s30\plain\li0\sb60\f1\fs20 The symbolic name of an objects qualified class name and the name of its
 code module are returned. \par
\page
{\ {\super #}\footnote \pard\plain{\super #}OOBase_NameToObj}{\ {\super $}\footnote \pard\plain{\super 
$}OOBase.NameToObj}{\ {\super K}\footnote \pard\plain{\super K}NameToObj}\pard\s28
\plain\li0\sb120\sa120\keepn\f1\fs28\b NameToObj\par
\pard\s31\plain\li0\sb120\sa120\f1\fs20\b defined in module {\strike\cf5 OOBase}{\v 
OOBase}\par
\pard\s29\plain\li0\sb180\f1\fs24\b Syntax\par
\pard\s27\plain\li0\sb120\tx1702\f2\fs20 PROCEDURE NameToObj(VAR codeName-, name-
:ARRAY OF CHAR; \line
                    VAR p:{\ul\cf5 Object}{\v OOBase_Object})\par
\pard\s29\plain\li0\sb180\f1\fs24\b Parameters\par
\pard\s32\plain\f1\fs20\sb60\fi-2880\li2880 codeName\tab
\tab
\pard\s32\plain\f1\fs20\sb60\fi-2880\li2880 the full pathname of the .EXE or .DLL file containig the implementation of the desired class 
\par
\pard\s32\plain\f1\fs20\sb60\fi-2880\li2880 name\tab
\tab
\tab
\pard\s32\plain\f1\fs20\sb60\fi-2880\li2880 the qualified class name in the form moduleName.className 
\par
\pard\s32\plain\f1\fs20\sb60\fi-2880\li2880 p\tab
\tab
\tab
\tab
\pard\s32\plain\f1\fs20\sb60\fi-2880\li2880 returns a pointer to the object created or NIL if the call failed 
\par
\pard\s29\plain\li0\sb180\f1\fs24\b Description\par
\pard\s30\plain\li0\sb60\f1\fs20 A new object is created according to a given class and code module name.
\par
The code module name has to be given because the class might be implemented in a DLL which has not yet been loaded and whose name
 can not be derived from the Oberon class name.\par
In this case the top level module in the module hierarchy of the DLL must contain the DllEntryPoint procedure.
\par
It is possible to implement different modules with the same name in different DLLs. In this case it is not adviseable to use both
 DLLs in the same program. \par
\page
{\ {\super #}\footnote \pard\plain{\super #}OOBase_TypeHasOffset}{\ {\super $}\footnote \pard\plain{\super 
$}OOBase.TypeHasOffset}{\ {\super K}\footnote \pard\plain{\super K}TypeHasOffset}
\pard\s28\plain\li0\sb120\sa120\keepn\f1\fs28\b TypeHasOffset\par
\pard\s31\plain\li0\sb120\sa120\f1\fs20\b defined in module {\strike\cf5 OOBase}{\v 
OOBase}\par
\pard\s29\plain\li0\sb180\f1\fs24\b Syntax\par
\pard\s27\plain\li0\sb120\tx1702\f2\fs20 PROCEDURE TypeHasOffset(typeCode:INTEGER
):BOOLEAN\par
\pard\s29\plain\li0\sb180\f1\fs24\b Description\par
\pard\s30\plain\li0\sb60\f1\fs20 \par
return TRUE if the given type is accompanied by an offset in the RTTI \par
\page
{\ {\super #}\footnote \pard\plain{\super #}OOBase_TypeToName}{\ {\super $}\footnote \pard\plain{\super 
$}OOBase.TypeToName}{\ {\super K}\footnote \pard\plain{\super K}TypeToName}\pard\s28
\plain\li0\sb120\sa120\keepn\f1\fs28\b TypeToName\par
\pard\s31\plain\li0\sb120\sa120\f1\fs20\b defined in module {\strike\cf5 OOBase}{\v 
OOBase}\par
\pard\s29\plain\li0\sb180\f1\fs24\b Syntax\par
\pard\s27\plain\li0\sb120\tx1702\f2\fs20 PROCEDURE TypeToName(typeCode:INTEGER; \line

                     VAR txt:ARRAY OF CHAR)\par
\pard\s29\plain\li0\sb180\f1\fs24\b Description\par
\pard\s30\plain\li0\sb60\f1\fs20 \par
returns the symbolic name of the type given in typeCode \par
\page
{\ {\super #}\footnote \pard\plain{\super #}OOBase_Object}{\ {\super $}\footnote \pard\plain{\super 
$}OOBase.Object}{\ {\super K}\footnote \pard\plain{\super K}Object}\pard\s30\plain\li0\sb60\f1\fs20 
{\b Object}\par
\pard\s27\plain\li0\sb120\tx1702\f2\fs20 Object*=POINTER TO {\strike\cf5 ObjectT}{\v 
OOBase_ObjectT};\par
\page
{\ {\super #}\footnote \pard\plain{\super #}OOBase_ObjectT}{\ {\super $}\footnote \pard\plain{\super 
$}OOBase.ObjectT}{\ {\super K}\footnote \pard\plain{\super K}ObjectT}\pard\s28\plain\li0\sb120\sa120\keepn\f1\fs28\b 
ObjectT\par
\pard\s31\plain\li0\sb120\sa120\f1\fs20\b defined in module {\strike\cf5 OOBase}{\v 
OOBase}\par
\pard\s29\plain\li0\sb180\f1\fs24\b Description\par
\pard\s30\plain\li0\sb60\f1\fs20 This class should be the base of any class hierarchy.
 This class only contains the empty method Init.\par
\pard\s29\plain\li0\sb180\f1\fs24\b Syntax\par
\pard\s27\plain\li0\sb120\tx1702\f2\fs20 ObjectT=RECORD \line
END;\par
\pard\s29\plain\li0\sb180\f1\fs24\b Methods\par
\pard\s30\plain\li0\sb60\f1\fs20 {\strike\cf5 Init}{\v OOBase_ObjectT_Init}\par
\page
{\ {\super #}\footnote \pard\plain{\super #}OOBase_ObjectT_Init}{\ {\super $}\footnote \pard\plain{\super 
$}OOBase.ObjectT.Init}{\ {\super K}\footnote \pard\plain{\super K}Init}\pard\s28\plain\li0\sb120\sa120\keepn\f1\fs28\b 
Init\par
\pard\s31\plain\li0\sb120\sa120\f1\fs20\b defined in module {\strike\cf5 OOBase}{\v 
OOBase}, bound to type {\strike\cf5 ObjectT}{\v OOBase_ObjectT}\par
\pard\s29\plain\li0\sb180\f1\fs24\b Syntax\par
\pard\s27\plain\li0\sb120\tx1702\f2\fs20 PROCEDURE (VAR) Init()\par
\pard\s29\plain\li0\sb180\f1\fs24\b Description\par
\pard\s30\plain\li0\sb60\f1\fs20 This is an abstract method. The initialization methods of all
 classes should be called Init. This makes it possible to have a general convention for object
 creation: after allocating an object with NEW the method Init can be called regardless of the objects class. 
\par
\page
{\ {\super #}\footnote \pard\plain{\super #}Out}{\ {\super $}\footnote \pard\plain{\super 
$}module Out}{\ {\super K}\footnote \pard\plain{\super K}Out}\pard\s28\plain\li0\sb120\sa120\keepn\f1\fs28\b 
Module Out\par
\pard\s30\plain\li0\sb60\f1\fs20 This module offers a simple sequential output to the screen. A particular
 advantage is that the whole output is always accessible, even if it is far longer than one screen page.
\par
The interface of this module is call-compatible with the standard output module in the Oakwood Guidelines.
\par
All output is sequential and the output area is only limited by the available size of the main memory. The visible section can be selected with the help of
 scroll bars. All new output automatically shifts the visible area to the end of the output.
\par
\pard\s29\plain\li0\sb180\f1\fs24\b Procedures\par
\pard\s30\plain\li0\sb60\f1\fs20 {\strike\cf5 Char}{\v Out_Char}\par
{\strike\cf5 Close}{\v Out_Close}\par
{\strike\cf5 F}{\v Out_F}\par
{\strike\cf5 F2}{\v Out_F2}\par
{\strike\cf5 F3}{\v Out_F3}\par
{\strike\cf5 F4}{\v Out_F4}\par
{\strike\cf5 Int}{\v Out_Int}\par
{\strike\cf5 Ln}{\v Out_Ln}\par
{\strike\cf5 LongReal}{\v Out_LongReal}\par
{\strike\cf5 Open}{\v Out_Open}\par
{\strike\cf5 Real}{\v Out_Real}\par
{\strike\cf5 SetScreenUpdate}{\v Out_SetScreenUpdate}\par
{\strike\cf5 String}{\v Out_String}\par
\page
{\ {\super #}\footnote \pard\plain{\super #}Out_Char}{\ {\super $}\footnote \pard\plain{\super 
$}Out.Char}{\ {\super K}\footnote \pard\plain{\super K}Char}\pard\s28\plain\li0\sb120\sa120\keepn\f1\fs28\b 
Char\par
\pard\s31\plain\li0\sb120\sa120\f1\fs20\b defined in module {\strike\cf5 Out}{\v 
Out}\par
\pard\s29\plain\li0\sb180\f1\fs24\b Syntax\par
\pard\s27\plain\li0\sb120\tx1702\f2\fs20 PROCEDURE Char(ch:CHAR)\par
\pard\s29\plain\li0\sb180\f1\fs24\b Description\par
\pard\s30\plain\li0\sb60\f1\fs20 The character {\b ch} is printed on the screen. 
\par
\page
{\ {\super #}\footnote \pard\plain{\super #}Out_Close}{\ {\super $}\footnote \pard\plain{\super 
$}Out.Close}{\ {\super K}\footnote \pard\plain{\super K}Close}\pard\s28\plain\li0\sb120\sa120\keepn\f1\fs28\b 
Close\par
\pard\s31\plain\li0\sb120\sa120\f1\fs20\b defined in module {\strike\cf5 Out}{\v 
Out}\par
\pard\s29\plain\li0\sb180\f1\fs24\b Syntax\par
\pard\s27\plain\li0\sb120\tx1702\f2\fs20 PROCEDURE Close()\par
\pard\s29\plain\li0\sb180\f1\fs24\b Description\par
\pard\s30\plain\li0\sb60\f1\fs20 This procedure has no effect and exists only for reasons of compatibility.  
\par
\page
{\ {\super #}\footnote \pard\plain{\super #}Out_F}{\ {\super $}\footnote \pard\plain{\super 
$}Out.F}{\ {\super K}\footnote \pard\plain{\super K}F}\pard\s28\plain\li0\sb120\sa120\keepn\f1\fs28\b 
F\par
\pard\s31\plain\li0\sb120\sa120\f1\fs20\b defined in module {\strike\cf5 Out}{\v 
Out}\par
\pard\s29\plain\li0\sb180\f1\fs24\b Syntax\par
\pard\s27\plain\li0\sb120\tx1702\f2\fs20 PROCEDURE F(t:ARRAY OF CHAR; \line
            x1:LONGINT)\par
\pard\s29\plain\li0\sb180\f1\fs24\b Description\par
\pard\s30\plain\li0\sb60\f1\fs20 This allows to easily generate formatted output of one integer value.
\par
A string is passed in {\b t} for the output of which two replacement rules are valid:
\par
1. Each occurrence of the character "#" is replaced from left to right by the numbers passed in x1.
\par
2. Each occurrence of the character "$" is replaced by CR and LF.\par
Example:\par
F2("The co-ordinates for the$center: (#,#)",45,-6);\par
causes the output\par
<\par
The co-ordinates for the\par
center: (45,-6)\par
>\par
\page
{\ {\super #}\footnote \pard\plain{\super #}Out_F2}{\ {\super $}\footnote \pard\plain{\super 
$}Out.F2}{\ {\super K}\footnote \pard\plain{\super K}F2}\pard\s28\plain\li0\sb120\sa120\keepn\f1\fs28\b 
F2\par
\pard\s31\plain\li0\sb120\sa120\f1\fs20\b defined in module {\strike\cf5 Out}{\v 
Out}\par
\pard\s29\plain\li0\sb180\f1\fs24\b Syntax\par
\pard\s27\plain\li0\sb120\tx1702\f2\fs20 PROCEDURE F2(t:ARRAY OF CHAR; \line
             x1, x2:LONGINT)\par
\pard\s29\plain\li0\sb180\f1\fs24\b Description\par
\pard\s30\plain\li0\sb60\f1\fs20 This allows to easily generate formatted output of two integer values.
\par
A string is passed in {\b t} for the output of which two replacement rules are valid:
\par
1. Each occurrence of the character "#" is replaced from left to right by the numbers passed in x1 and x2.
\par
2. Each occurrence of the character "$" is replaced by CR and LF.\par
Example:\par
F2("The co-ordinates for the$center: (#,#)",45,-6);\par
causes the output\par
<\par
The co-ordinates for the\par
center: (45,-6)\par
>\par
\page
{\ {\super #}\footnote \pard\plain{\super #}Out_F3}{\ {\super $}\footnote \pard\plain{\super 
$}Out.F3}{\ {\super K}\footnote \pard\plain{\super K}F3}\pard\s28\plain\li0\sb120\sa120\keepn\f1\fs28\b 
F3\par
\pard\s31\plain\li0\sb120\sa120\f1\fs20\b defined in module {\strike\cf5 Out}{\v 
Out}\par
\pard\s29\plain\li0\sb180\f1\fs24\b Syntax\par
\pard\s27\plain\li0\sb120\tx1702\f2\fs20 PROCEDURE F3(t:ARRAY OF CHAR; \line
             x1, x2, x3:LONGINT)\par
\pard\s29\plain\li0\sb180\f1\fs24\b Description\par
\pard\s30\plain\li0\sb60\f1\fs20 This allows to easily generate formatted output of three integer values.
\par
A string is passed in {\b t} for the output of which two replacement rules are valid:
\par
1. Each occurrence of the character "#" is replaced from left to right by the numbers passed in x1, x2 and x3.
\par
2. Each occurrence of the character "$" is replaced by CR and LF.\par
Example:\par
F2("The co-ordinates for the$center: (#,#)",45,-6);\par
causes the output\par
<\par
The co-ordinates for the\par
center: (45,-6)\par
>\par
\page
{\ {\super #}\footnote \pard\plain{\super #}Out_F4}{\ {\super $}\footnote \pard\plain{\super 
$}Out.F4}{\ {\super K}\footnote \pard\plain{\super K}F4}\pard\s28\plain\li0\sb120\sa120\keepn\f1\fs28\b 
F4\par
\pard\s31\plain\li0\sb120\sa120\f1\fs20\b defined in module {\strike\cf5 Out}{\v 
Out}\par
\pard\s29\plain\li0\sb180\f1\fs24\b Syntax\par
\pard\s27\plain\li0\sb120\tx1702\f2\fs20 PROCEDURE F4(t:ARRAY OF CHAR; \line
             x1, x2, x3, x4:LONGINT)\par
\pard\s29\plain\li0\sb180\f1\fs24\b Description\par
\pard\s30\plain\li0\sb60\f1\fs20 This allows to easily generate formatted output of four integer values.
\par
A string is passed in {\b t} for the output of which two replacement rules are valid:
\par
1. Each occurrence of the character "#" is replaced from left to right by the numbers passed in x1, x2, x3 and x4.
\par
2. Each occurrence of the character "$" is replaced by CR and LF.\par
Example:\par
F2("The co-ordinates for the$center: (#,#)",45,-6);\par
causes the output\par
<\par
The co-ordinates for the\par
center: (45,-6)\par
>\par
\page
{\ {\super #}\footnote \pard\plain{\super #}Out_Int}{\ {\super $}\footnote \pard\plain{\super 
$}Out.Int}{\ {\super K}\footnote \pard\plain{\super K}Int}\pard\s28\plain\li0\sb120\sa120\keepn\f1\fs28\b 
Int\par
\pard\s31\plain\li0\sb120\sa120\f1\fs20\b defined in module {\strike\cf5 Out}{\v 
Out}\par
\pard\s29\plain\li0\sb180\f1\fs24\b Syntax\par
\pard\s27\plain\li0\sb120\tx1702\f2\fs20 PROCEDURE Int(i, n:LONGINT)\par
\pard\s29\plain\li0\sb180\f1\fs24\b Description\par
\pard\s30\plain\li0\sb60\f1\fs20 The number contained in {\b i} is displayed right aligned at least 
{\b n} characters wide. \par
\page
{\ {\super #}\footnote \pard\plain{\super #}Out_Ln}{\ {\super $}\footnote \pard\plain{\super 
$}Out.Ln}{\ {\super K}\footnote \pard\plain{\super K}Ln}\pard\s28\plain\li0\sb120\sa120\keepn\f1\fs28\b 
Ln\par
\pard\s31\plain\li0\sb120\sa120\f1\fs20\b defined in module {\strike\cf5 Out}{\v 
Out}\par
\pard\s29\plain\li0\sb180\f1\fs24\b Syntax\par
\pard\s27\plain\li0\sb120\tx1702\f2\fs20 PROCEDURE Ln()\par
\pard\s29\plain\li0\sb180\f1\fs24\b Description\par
\pard\s30\plain\li0\sb60\f1\fs20 The output is continued at the beginning of the next line. 
\par
\page
{\ {\super #}\footnote \pard\plain{\super #}Out_LongReal}{\ {\super $}\footnote \pard\plain{\super 
$}Out.LongReal}{\ {\super K}\footnote \pard\plain{\super K}LongReal}\pard\s28\plain\li0\sb120\sa120\keepn\f1\fs28\b 
LongReal\par
\pard\s31\plain\li0\sb120\sa120\f1\fs20\b defined in module {\strike\cf5 Out}{\v 
Out}\par
\pard\s29\plain\li0\sb180\f1\fs24\b Syntax\par
\pard\s27\plain\li0\sb120\tx1702\f2\fs20 PROCEDURE LongReal(x:LONGREAL; \line
                   n:INTEGER)\par
\pard\s29\plain\li0\sb180\f1\fs24\b Description\par
\pard\s30\plain\li0\sb60\f1\fs20 The number contained in {\b x} is displayed right aligned at least 
{\b n} characters wide. \par
\page
{\ {\super #}\footnote \pard\plain{\super #}Out_Open}{\ {\super $}\footnote \pard\plain{\super 
$}Out.Open}{\ {\super K}\footnote \pard\plain{\super K}Open}\pard\s28\plain\li0\sb120\sa120\keepn\f1\fs28\b 
Open\par
\pard\s31\plain\li0\sb120\sa120\f1\fs20\b defined in module {\strike\cf5 Out}{\v 
Out}\par
\pard\s29\plain\li0\sb180\f1\fs24\b Syntax\par
\pard\s27\plain\li0\sb120\tx1702\f2\fs20 PROCEDURE Open()\par
\pard\s29\plain\li0\sb180\f1\fs24\b Description\par
\pard\s30\plain\li0\sb60\f1\fs20 This procedure has no effect and exists only for reasons of compatibility.
 The output area is automatically initialized when importing the module Out. \par

\page
{\ {\super #}\footnote \pard\plain{\super #}Out_Real}{\ {\super $}\footnote \pard\plain{\super 
$}Out.Real}{\ {\super K}\footnote \pard\plain{\super K}Real}\pard\s28\plain\li0\sb120\sa120\keepn\f1\fs28\b 
Real\par
\pard\s31\plain\li0\sb120\sa120\f1\fs20\b defined in module {\strike\cf5 Out}{\v 
Out}\par
\pard\s29\plain\li0\sb180\f1\fs24\b Syntax\par
\pard\s27\plain\li0\sb120\tx1702\f2\fs20 PROCEDURE Real(x:LONGREAL; \line
               n:INTEGER)\par
\pard\s29\plain\li0\sb180\f1\fs24\b Description\par
\pard\s30\plain\li0\sb60\f1\fs20 The number contained in {\b x} is displayed right aligned at least 
{\b n} characters wide. To increase consistency with respect to the modules Display and Print,
 numbers of the type LONGREAL may also be passed. \par
\page
{\ {\super #}\footnote \pard\plain{\super #}Out_SetScreenUpdate}{\ {\super $}\footnote \pard\plain{\super 
$}Out.SetScreenUpdate}{\ {\super K}\footnote \pard\plain{\super K}SetScreenUpdate
}\pard\s28\plain\li0\sb120\sa120\keepn\f1\fs28\b SetScreenUpdate\par
\pard\s31\plain\li0\sb120\sa120\f1\fs20\b defined in module {\strike\cf5 Out}{\v 
Out}\par
\pard\s29\plain\li0\sb180\f1\fs24\b Syntax\par
\pard\s27\plain\li0\sb120\tx1702\f2\fs20 PROCEDURE SetScreenUpdate(x:BOOLEAN)\par

\pard\s29\plain\li0\sb180\f1\fs24\b Description\par
\pard\s30\plain\li0\sb60\f1\fs20 This procedure enables or disables screen updates. When screen updates
 are disabled, all output from procedures like Char or String is accumulated in the background. All pending output is written to the screen at once when
 screen update is enabled again. This allows to speed up program execution when many individual calls to output functions are being used.
\par
This procedure is not included in the Oakwood Guidelines. \par
\page
{\ {\super #}\footnote \pard\plain{\super #}Out_String}{\ {\super $}\footnote \pard\plain{\super 
$}Out.String}{\ {\super K}\footnote \pard\plain{\super K}String}\pard\s28\plain\li0\sb120\sa120\keepn\f1\fs28\b 
String\par
\pard\s31\plain\li0\sb120\sa120\f1\fs20\b defined in module {\strike\cf5 Out}{\v 
Out}\par
\pard\s29\plain\li0\sb180\f1\fs24\b Syntax\par
\pard\s27\plain\li0\sb120\tx1702\f2\fs20 PROCEDURE String(VAR str-:ARRAY OF CHAR)
\par
\pard\s29\plain\li0\sb180\f1\fs24\b Description\par
\pard\s30\plain\li0\sb60\f1\fs20 The string {\b str} is displayed. \par
\page
{\ {\super #}\footnote \pard\plain{\super #}Param}{\ {\super $}\footnote \pard\plain{\super 
$}module Param}{\ {\super K}\footnote \pard\plain{\super K}Param}\pard\s28\plain\li0\sb120\sa120\keepn\f1\fs28\b 
Module Param\par
\pard\s30\plain\li0\sb60\f1\fs20 This module offers access to the command line which was used to start the
 program. It is possible to access the command line as a whole or only single parameters. It is assumed that the single parameters of the command
 line are separated either by blanks, commas or both.\par
\pard\s29\plain\li0\sb180\f1\fs24\b Constants\par
\pard\s32\plain\f1\fs20\sb60\fi-2880\li2880 MAXPARAMLEN\tab
\pard\s32\plain\f1\fs20\sb60\fi-2880\li2880 maximum length of the entire parameter string 
\par
\pard\s32\plain\f1\fs20\sb60\fi-2880\li2880 MAXSTR\tab
\tab
\tab
\pard\s32\plain\f1\fs20\sb60\fi-2880\li2880 maximum number of different parts of the parameter string 
\par
\pard\s29\plain\li0\sb180\f1\fs24\b Procedures\par
\pard\s30\plain\li0\sb60\f1\fs20 {\strike\cf5 CompleteStr}{\v Param_CompleteStr}\par

{\strike\cf5 Count}{\v Param_Count}\par
{\strike\cf5 Parse}{\v Param_Parse}\par
{\strike\cf5 Str}{\v Param_Str}\par
\page
{\ {\super #}\footnote \pard\plain{\super #}Param_CompleteStr}{\ {\super $}\footnote \pard\plain{\super 
$}Param.CompleteStr}{\ {\super K}\footnote \pard\plain{\super K}CompleteStr}\pard\s28
\plain\li0\sb120\sa120\keepn\f1\fs28\b CompleteStr\par
\pard\s31\plain\li0\sb120\sa120\f1\fs20\b defined in module {\strike\cf5 Param}{\v 
Param}\par
\pard\s29\plain\li0\sb180\f1\fs24\b Syntax\par
\pard\s27\plain\li0\sb120\tx1702\f2\fs20 PROCEDURE CompleteStr(VAR cmdLine:ARRAY 
OF CHAR)\par
\pard\s29\plain\li0\sb180\f1\fs24\b Description\par
\pard\s30\plain\li0\sb60\f1\fs20 The complete command line is copied to the parameter 
{\b cmdLine}. \par
\page
{\ {\super #}\footnote \pard\plain{\super #}Param_Count}{\ {\super $}\footnote \pard\plain{\super 
$}Param.Count}{\ {\super K}\footnote \pard\plain{\super K}Count}\pard\s28\plain\li0\sb120\sa120\keepn\f1\fs28\b 
Count\par
\pard\s31\plain\li0\sb120\sa120\f1\fs20\b defined in module {\strike\cf5 Param}{\v 
Param}\par
\pard\s29\plain\li0\sb180\f1\fs24\b Syntax\par
\pard\s27\plain\li0\sb120\tx1702\f2\fs20 PROCEDURE Count():INTEGER\par
\pard\s29\plain\li0\sb180\f1\fs24\b Description\par
\pard\s30\plain\li0\sb60\f1\fs20 The return value of the function is the number of parameters in the command
 line that are separated by blanks or commas. \par
\page
{\ {\super #}\footnote \pard\plain{\super #}Param_Parse}{\ {\super $}\footnote \pard\plain{\super 
$}Param.Parse}{\ {\super K}\footnote \pard\plain{\super K}Parse}\pard\s28\plain\li0\sb120\sa120\keepn\f1\fs28\b 
Parse\par
\pard\s31\plain\li0\sb120\sa120\f1\fs20\b defined in module {\strike\cf5 Param}{\v 
Param}\par
\pard\s29\plain\li0\sb180\f1\fs24\b Syntax\par
\pard\s27\plain\li0\sb120\tx1702\f2\fs20 PROCEDURE Parse(VAR line-:ARRAY OF CHAR)
\par
\pard\s29\plain\li0\sb180\f1\fs24\b Description\par
\pard\s30\plain\li0\sb60\f1\fs20 The string passed in {\b line} is broken up into individual arguments and replaces
 the original command line. Following calls to the function Str return the the individual elements found in 
{\b line}. \par
\page
{\ {\super #}\footnote \pard\plain{\super #}Param_Str}{\ {\super $}\footnote \pard\plain{\super 
$}Param.Str}{\ {\super K}\footnote \pard\plain{\super K}Str}\pard\s28\plain\li0\sb120\sa120\keepn\f1\fs28\b 
Str\par
\pard\s31\plain\li0\sb120\sa120\f1\fs20\b defined in module {\strike\cf5 Param}{\v 
Param}\par
\pard\s29\plain\li0\sb180\f1\fs24\b Syntax\par
\pard\s27\plain\li0\sb120\tx1702\f2\fs20 PROCEDURE Str(paramNr:INTEGER; \line
              VAR paramTxt:ARRAY OF CHAR)\par
\pard\s29\plain\li0\sb180\f1\fs24\b Description\par
\pard\s30\plain\li0\sb60\f1\fs20 A single parameter of the command line is copied to 
{\b paramTxt}. The parameter is selected by {\b paramNr}, starting with one. If a non-existent parameter is
 selected an empty string is returned.\par
Parameters containing commas, or even blanks, can be stated between quotation marks. The quotation marks are removed automatically. 
\par
\page
{\ {\super #}\footnote \pard\plain{\super #}Print}{\ {\super $}\footnote \pard\plain{\super 
$}module Print}{\ {\super K}\footnote \pard\plain{\super K}Print}\pard\s28\plain\li0\sb120\sa120\keepn\f1\fs28\b 
Module Print\par
\pard\s30\plain\li0\sb60\f1\fs20 This module provides character based access to printers.
\par
The printer is regarded as a sequential line-oriented output medium. At the beginning of a printout a virtual output cursor is set to the top
 left corner of the first page. After data has been output this position is moved right by the width of the output; if necessary a CR LF is included.
 It is also possible to force an immediate change of line or page.\par
Before starting a printout the module must be initialized by calling Start. After the last output on the printout the procedure Finished must be called.
 In a multi-user environment the procedures Start and Finished ensure that all output in between is managed as a single print job.
\par
\pard\s29\plain\li0\sb180\f1\fs24\b Procedures\par
\pard\s30\plain\li0\sb60\f1\fs20 {\strike\cf5 StartWithDialog}{\v Print_StartWithDialog
}\par
{\strike\cf5 Start}{\v Print_Start}\par
{\strike\cf5 Page}{\v Print_Page}\par
{\strike\cf5 Ln}{\v Print_Ln}\par
{\strike\cf5 GetInfo}{\v Print_GetInfo}\par
{\strike\cf5 Char}{\v Print_Char}\par
{\strike\cf5 Str}{\v Print_Str}\par
{\strike\cf5 Real}{\v Print_Real}\par
{\strike\cf5 Int}{\v Print_Int}\par
{\strike\cf5 Finished}{\v Print_Finished}\par
{\strike\cf5 SetLeftMargin}{\v Print_SetLeftMargin}\par
{\strike\cf5 SetTopMargin}{\v Print_SetTopMargin}\par
{\strike\cf5 RemainingLines}{\v Print_RemainingLines}\par
\page
{\ {\super #}\footnote \pard\plain{\super #}Print_StartWithDialog}{\ {\super $}\footnote \pard\plain{\super 
$}Print.StartWithDialog}{\ {\super K}\footnote \pard\plain{\super K}StartWithDialog
}\pard\s28\plain\li0\sb120\sa120\keepn\f1\fs28\b StartWithDialog\par
\pard\s31\plain\li0\sb120\sa120\f1\fs20\b defined in module {\strike\cf5 Print}{\v 
Print}\par
\pard\s29\plain\li0\sb180\f1\fs24\b Syntax\par
\pard\s27\plain\li0\sb120\tx1702\f2\fs20 PROCEDURE StartWithDialog():BOOLEAN\par
\pard\s29\plain\li0\sb180\f1\fs24\b Description\par
\pard\s30\plain\li0\sb60\f1\fs20 The module is initialized for the start of a new printout. This procedure
 or Start must be called before any of the other modules procedures are called.\par

This call displays a dialog box which offers an opportunity to select a specific 
printer for the new print job. The function returns TRUE if a printer was selected
 and FALSE if the dialog was aborted by the user.\par
In a network environment the system is indicated the start of a new printer job. 
\par
\page
{\ {\super #}\footnote \pard\plain{\super #}Print_Start}{\ {\super $}\footnote \pard\plain{\super 
$}Print.Start}{\ {\super K}\footnote \pard\plain{\super K}Start}\pard\s28\plain\li0\sb120\sa120\keepn\f1\fs28\b 
Start\par
\pard\s31\plain\li0\sb120\sa120\f1\fs20\b defined in module {\strike\cf5 Print}{\v 
Print}\par
\pard\s29\plain\li0\sb180\f1\fs24\b Syntax\par
\pard\s27\plain\li0\sb120\tx1702\f2\fs20 PROCEDURE Start()\par
\pard\s29\plain\li0\sb180\f1\fs24\b Description\par
\pard\s30\plain\li0\sb60\f1\fs20 The module is initialized for the start of a new printout. This procedure
 or StartWithDialog must be called before any of the other modules procedures are called.
\par
In a network environment the system is indicated the start of a new printer job. 
\par
\page
{\ {\super #}\footnote \pard\plain{\super #}Print_Page}{\ {\super $}\footnote \pard\plain{\super 
$}Print.Page}{\ {\super K}\footnote \pard\plain{\super K}Page}\pard\s28\plain\li0\sb120\sa120\keepn\f1\fs28\b 
Page\par
\pard\s31\plain\li0\sb120\sa120\f1\fs20\b defined in module {\strike\cf5 Print}{\v 
Print}\par
\pard\s29\plain\li0\sb180\f1\fs24\b Syntax\par
\pard\s27\plain\li0\sb120\tx1702\f2\fs20 PROCEDURE Page()\par
\pard\s29\plain\li0\sb180\f1\fs24\b Description\par
\pard\s30\plain\li0\sb60\f1\fs20 The output cursor is set to the beginning of the next page. 
\par
\page
{\ {\super #}\footnote \pard\plain{\super #}Print_Ln}{\ {\super $}\footnote \pard\plain{\super 
$}Print.Ln}{\ {\super K}\footnote \pard\plain{\super K}Ln}\pard\s28\plain\li0\sb120\sa120\keepn\f1\fs28\b 
Ln\par
\pard\s31\plain\li0\sb120\sa120\f1\fs20\b defined in module {\strike\cf5 Print}{\v 
Print}\par
\pard\s29\plain\li0\sb180\f1\fs24\b Syntax\par
\pard\s27\plain\li0\sb120\tx1702\f2\fs20 PROCEDURE Ln()\par
\pard\s29\plain\li0\sb180\f1\fs24\b Description\par
\pard\s30\plain\li0\sb60\f1\fs20 The output cursor is set to the beginning of the next line. 
\par
\page
{\ {\super #}\footnote \pard\plain{\super #}Print_GetInfo}{\ {\super $}\footnote \pard\plain{\super 
$}Print.GetInfo}{\ {\super K}\footnote \pard\plain{\super K}GetInfo}\pard\s28\plain\li0\sb120\sa120\keepn\f1\fs28\b 
GetInfo\par
\pard\s31\plain\li0\sb120\sa120\f1\fs20\b defined in module {\strike\cf5 Print}{\v 
Print}\par
\pard\s29\plain\li0\sb180\f1\fs24\b Syntax\par
\pard\s27\plain\li0\sb120\tx1702\f2\fs20 PROCEDURE GetInfo(VAR x, y:LONGINT; \line

                  VAR hdc:WD.HDC)\par
\pard\s29\plain\li0\sb180\f1\fs24\b Description\par
\pard\s30\plain\li0\sb60\f1\fs20 This function is very Windows specific. It should be avoided if possible.
 This function returns the current output location in device co-ordinates and a handle to the Windows printer device context which is used for printing for
 the current print job. \par
\page
{\ {\super #}\footnote \pard\plain{\super #}Print_Char}{\ {\super $}\footnote \pard\plain{\super 
$}Print.Char}{\ {\super K}\footnote \pard\plain{\super K}Char}\pard\s28\plain\li0\sb120\sa120\keepn\f1\fs28\b 
Char\par
\pard\s31\plain\li0\sb120\sa120\f1\fs20\b defined in module {\strike\cf5 Print}{\v 
Print}\par
\pard\s29\plain\li0\sb180\f1\fs24\b Syntax\par
\pard\s27\plain\li0\sb120\tx1702\f2\fs20 PROCEDURE Char(x:CHAR)\par
\pard\s29\plain\li0\sb180\f1\fs24\b Description\par
\pard\s30\plain\li0\sb60\f1\fs20 The character {\b x} is printed. \par
\page
{\ {\super #}\footnote \pard\plain{\super #}Print_Str}{\ {\super $}\footnote \pard\plain{\super 
$}Print.Str}{\ {\super K}\footnote \pard\plain{\super K}Str}\pard\s28\plain\li0\sb120\sa120\keepn\f1\fs28\b 
Str\par
\pard\s31\plain\li0\sb120\sa120\f1\fs20\b defined in module {\strike\cf5 Print}{\v 
Print}\par
\pard\s29\plain\li0\sb180\f1\fs24\b Syntax\par
\pard\s27\plain\li0\sb120\tx1702\f2\fs20 PROCEDURE Str(t:ARRAY OF CHAR)\par
\pard\s29\plain\li0\sb180\f1\fs24\b Description\par
\pard\s30\plain\li0\sb60\f1\fs20 The string contained in {\b t} is printed. \par
\page
{\ {\super #}\footnote \pard\plain{\super #}Print_Real}{\ {\super $}\footnote \pard\plain{\super 
$}Print.Real}{\ {\super K}\footnote \pard\plain{\super K}Real}\pard\s28\plain\li0\sb120\sa120\keepn\f1\fs28\b 
Real\par
\pard\s31\plain\li0\sb120\sa120\f1\fs20\b defined in module {\strike\cf5 Print}{\v 
Print}\par
\pard\s29\plain\li0\sb180\f1\fs24\b Syntax\par
\pard\s27\plain\li0\sb120\tx1702\f2\fs20 PROCEDURE Real(x:LONGREAL; \line
               n:INTEGER)\par
\pard\s29\plain\li0\sb180\f1\fs24\b Description\par
\pard\s30\plain\li0\sb60\f1\fs20 The number passed in {\b x} is printed right aligned 
{\b n} characters wide. If the number cannot be represented in the desired width the stated width is
 extended. \par
\page
{\ {\super #}\footnote \pard\plain{\super #}Print_Int}{\ {\super $}\footnote \pard\plain{\super 
$}Print.Int}{\ {\super K}\footnote \pard\plain{\super K}Int}\pard\s28\plain\li0\sb120\sa120\keepn\f1\fs28\b 
Int\par
\pard\s31\plain\li0\sb120\sa120\f1\fs20\b defined in module {\strike\cf5 Print}{\v 
Print}\par
\pard\s29\plain\li0\sb180\f1\fs24\b Syntax\par
\pard\s27\plain\li0\sb120\tx1702\f2\fs20 PROCEDURE Int(i, n:LONGINT)\par
\pard\s29\plain\li0\sb180\f1\fs24\b Description\par
\pard\s30\plain\li0\sb60\f1\fs20 The number passed in {\b i} is printed right aligned 
{\b n} characters wide. If the number cannot be represented in the desired width the stated width
 is extended. \par
\page
{\ {\super #}\footnote \pard\plain{\super #}Print_Finished}{\ {\super $}\footnote \pard\plain{\super 
$}Print.Finished}{\ {\super K}\footnote \pard\plain{\super K}Finished}\pard\s28\plain\li0\sb120\sa120\keepn\f1\fs28\b 
Finished\par
\pard\s31\plain\li0\sb120\sa120\f1\fs20\b defined in module {\strike\cf5 Print}{\v 
Print}\par
\pard\s29\plain\li0\sb180\f1\fs24\b Syntax\par
\pard\s27\plain\li0\sb120\tx1702\f2\fs20 PROCEDURE Finished()\par
\pard\s29\plain\li0\sb180\f1\fs24\b Description\par
\pard\s30\plain\li0\sb60\f1\fs20 This procedure is called at the end of the current printout. In a network
 environment the document is released for printing in the printer queue.  \par
\page
{\ {\super #}\footnote \pard\plain{\super #}Print_SetLeftMargin}{\ {\super $}\footnote \pard\plain{\super 
$}Print.SetLeftMargin}{\ {\super K}\footnote \pard\plain{\super K}SetLeftMargin}\pard\s28
\plain\li0\sb120\sa120\keepn\f1\fs28\b SetLeftMargin\par
\pard\s31\plain\li0\sb120\sa120\f1\fs20\b defined in module {\strike\cf5 Print}{\v 
Print}\par
\pard\s29\plain\li0\sb180\f1\fs24\b Syntax\par
\pard\s27\plain\li0\sb120\tx1702\f2\fs20 PROCEDURE SetLeftMargin(marg:LONGINT)\par

\pard\s29\plain\li0\sb180\f1\fs24\b Description\par
\pard\s30\plain\li0\sb60\f1\fs20 The left page margin is set to {\b marg} millimeters. If the current output cursor
 is situated to the left of the new margin it is automatically adjusted to the new margin.
\par
Bear in mind that paper feeder tolerances and printer driver inaccuracies may give rise to irregularities. 
\par
\page
{\ {\super #}\footnote \pard\plain{\super #}Print_SetTopMargin}{\ {\super $}\footnote \pard\plain{\super 
$}Print.SetTopMargin}{\ {\super K}\footnote \pard\plain{\super K}SetTopMargin}\pard\s28
\plain\li0\sb120\sa120\keepn\f1\fs28\b SetTopMargin\par
\pard\s31\plain\li0\sb120\sa120\f1\fs20\b defined in module {\strike\cf5 Print}{\v 
Print}\par
\pard\s29\plain\li0\sb180\f1\fs24\b Syntax\par
\pard\s27\plain\li0\sb120\tx1702\f2\fs20 PROCEDURE SetTopMargin(marg:LONGINT)\par

\pard\s29\plain\li0\sb180\f1\fs24\b Description\par
\pard\s30\plain\li0\sb60\f1\fs20 The top page margin is set to {\b marg} millimeters. If the current output position
 is situated above the new margin it is automatically adjusted to the new margin.
\par
Bear in mind that paper feeder tolerances and printer driver inaccuracies may give rise to irregularities. 
\par
\page
{\ {\super #}\footnote \pard\plain{\super #}Print_RemainingLines}{\ {\super $}\footnote \pard\plain{\super 
$}Print.RemainingLines}{\ {\super K}\footnote \pard\plain{\super K}RemainingLines
}\pard\s28\plain\li0\sb120\sa120\keepn\f1\fs28\b RemainingLines\par
\pard\s31\plain\li0\sb120\sa120\f1\fs20\b defined in module {\strike\cf5 Print}{\v 
Print}\par
\pard\s29\plain\li0\sb180\f1\fs24\b Syntax\par
\pard\s27\plain\li0\sb120\tx1702\f2\fs20 PROCEDURE RemainingLines():INTEGER\par
\pard\s29\plain\li0\sb180\f1\fs24\b Description\par
\pard\s30\plain\li0\sb60\f1\fs20 The return value of the function is the number of lines that may still be
 printed on the current page using the current font. \par
\page
{\ {\super #}\footnote \pard\plain{\super #}Process}{\ {\super $}\footnote \pard\plain{\super 
$}module Process}{\ {\super K}\footnote \pard\plain{\super K}Process}\pard\s28\plain\li0\sb120\sa120\keepn\f1\fs28\b 
Module Process\par
\pard\s30\plain\li0\sb60\f1\fs20 This module helps to control the execution of a program.
\par
\pard\s29\plain\li0\sb180\f1\fs24\b Types\par
\pard\s30\plain\li0\sb60\f1\fs20 {\ul\cf5 ExitProc}{\v Process_ExitProc}\par
\pard\s29\plain\li0\sb180\f1\fs24\b Variables\par
\pard\s30\plain\li0\sb60\f1\fs20 {\ul\cf5 theExitProc}{\v Process_theExitProc}\par

\pard\s30\plain\li0\sb60\f1\fs20 {\ul\cf5 importantExitProc}{\v Process_importantExitProc
}\par
\pard\s30\plain\li0\sb60\f1\fs20 {\ul\cf5 terminateMsgLoops}{\v Process_terminateMsgLoops
}\par
\pard\s30\plain\li0\sb60\f1\fs20 {\ul\cf5 breakEnabled}{\v Process_breakEnabled}\par

\pard\s29\plain\li0\sb180\f1\fs24\b Procedures\par
\pard\s30\plain\li0\sb60\f1\fs20 {\strike\cf5 Yield}{\v Process_Yield}\par
{\strike\cf5 SetBreak}{\v Process_SetBreak}\par
{\strike\cf5 SetExitProc}{\v Process_SetExitProc}\par
{\strike\cf5 GetExitProc}{\v Process_GetExitProc}\par
{\strike\cf5 TerminateMsgLoops}{\v Process_TerminateMsgLoops}\par
\page
{\ {\super #}\footnote \pard\plain{\super #}Process_Yield}{\ {\super $}\footnote \pard\plain{\super 
$}Process.Yield}{\ {\super K}\footnote \pard\plain{\super K}Yield}\pard\s28\plain\li0\sb120\sa120\keepn\f1\fs28\b 
Yield\par
\pard\s31\plain\li0\sb120\sa120\f1\fs20\b defined in module {\strike\cf5 Process}{\v 
Process}\par
\pard\s29\plain\li0\sb180\f1\fs24\b Syntax\par
\pard\s27\plain\li0\sb120\tx1702\f2\fs20 PROCEDURE Yield()\par
\pard\s29\plain\li0\sb180\f1\fs24\b Description\par
\pard\s30\plain\li0\sb60\f1\fs20 In the 16 bit Pow! version based on co-operative multi-tasking systems
 like Windows 3.x this procedure can be used for processor sharing. During time-consuming calculations other programs may be granted processor time
 to ensure that the remaining system can still operate promptly.\par
In the 32 bit Pow! version based on an operating system with pre-emptive multi-tasking this procedure has no effect on other applications.
 It can be used during time-consuming calculations to ensure that Windows messages in the applications own message queue are being processed at
 regular intervals to avoid that the application becomes temporarily unresponsive and can not draw its screen area any more. 
\par
\page
{\ {\super #}\footnote \pard\plain{\super #}Process_SetBreak}{\ {\super $}\footnote \pard\plain{\super 
$}Process.SetBreak}{\ {\super K}\footnote \pard\plain{\super K}SetBreak}\pard\s28
\plain\li0\sb120\sa120\keepn\f1\fs28\b SetBreak\par
\pard\s31\plain\li0\sb120\sa120\f1\fs20\b defined in module {\strike\cf5 Process}{\v 
Process}\par
\pard\s29\plain\li0\sb180\f1\fs24\b Syntax\par
\pard\s27\plain\li0\sb120\tx1702\f2\fs20 PROCEDURE SetBreak(x:BOOLEAN)\par
\pard\s29\plain\li0\sb180\f1\fs24\b Description\par
\pard\s30\plain\li0\sb60\f1\fs20 The user can terminate the program execution by pressing ALT-F4 or by using
 the menu command. If {\b x} is TRUE the user can exit the program at any time. If FALSE the key combination ALT-F4 has no effect and the menu item "Exit"
 is inactive and therefore appears gray. \par
\page
{\ {\super #}\footnote \pard\plain{\super #}Process_SetExitProc}{\ {\super $}\footnote \pard\plain{\super 
$}Process.SetExitProc}{\ {\super K}\footnote \pard\plain{\super K}SetExitProc}\pard\s28
\plain\li0\sb120\sa120\keepn\f1\fs28\b SetExitProc\par
\pard\s31\plain\li0\sb120\sa120\f1\fs20\b defined in module {\strike\cf5 Process}{\v 
Process}\par
\pard\s29\plain\li0\sb180\f1\fs24\b Syntax\par
\pard\s27\plain\li0\sb120\tx1702\f2\fs20 PROCEDURE SetExitProc(proc:{\ul\cf5 ExitProc
}{\v Process_ExitProc})\par
\pard\s29\plain\li0\sb180\f1\fs24\b Description\par
\pard\s30\plain\li0\sb60\f1\fs20 The procedure specified by proc is called before the program is terminated.
 The procedure is not called if the program is terminated due to a system error, a HALT, or an ASSERT which is not valid.
\par
If SetExitProc is called the exit procedure previously selected is overwritten. When used with the function GetExitProc the previous setting can be saved
 and a concatenation of procedures can be implemented. \par
\page
{\ {\super #}\footnote \pard\plain{\super #}Process_GetExitProc}{\ {\super $}\footnote \pard\plain{\super 
$}Process.GetExitProc}{\ {\super K}\footnote \pard\plain{\super K}GetExitProc}\pard\s28
\plain\li0\sb120\sa120\keepn\f1\fs28\b GetExitProc\par
\pard\s31\plain\li0\sb120\sa120\f1\fs20\b defined in module {\strike\cf5 Process}{\v 
Process}\par
\pard\s29\plain\li0\sb180\f1\fs24\b Syntax\par
\pard\s27\plain\li0\sb120\tx1702\f2\fs20 PROCEDURE GetExitProc(VAR proc:{\ul\cf5 
ExitProc}{\v Process_ExitProc})\par
\pard\s29\plain\li0\sb180\f1\fs24\b Description\par
\pard\s30\plain\li0\sb60\f1\fs20 The currently set exit procedure is returned in 
{\b proc}. A combined use of GetExitProc and SetExitProc supports a concatenation of
 several exit procedures. Each exit procedure should call the exit procedure it replaced.
 If GetExitProc is called before SetExitProc the system returns an internal empty exit procedure, which does not need to be called explicitly. 
\par
\page
{\ {\super #}\footnote \pard\plain{\super #}Process_TerminateMsgLoops}{\ {\super 
$}\footnote \pard\plain{\super $}Process.TerminateMsgLoops}{\ {\super K}\footnote \pard\plain{\super 
K}TerminateMsgLoops}\pard\s28\plain\li0\sb120\sa120\keepn\f1\fs28\b TerminateMsgLoops
\par
\pard\s31\plain\li0\sb120\sa120\f1\fs20\b defined in module {\strike\cf5 Process}{\v 
Process}\par
\pard\s29\plain\li0\sb180\f1\fs24\b Syntax\par
\pard\s27\plain\li0\sb120\tx1702\f2\fs20 PROCEDURE TerminateMsgLoops()\par
\pard\s29\plain\li0\sb180\f1\fs24\b Description\par
\pard\s30\plain\li0\sb60\f1\fs20 This is an internal function and should not be called. 
\par
\page
{\ {\super #}\footnote \pard\plain{\super #}Process_theExitProc}{\ {\super $}\footnote \pard\plain{\super 
$}Process.theExitProc}{\ {\super K}\footnote \pard\plain{\super K}theExitProc}\pard\s30
\plain\li0\sb60\f1\fs20 {\b theExitProc}\par
\pard\s27\plain\li0\sb120\tx1702\f2\fs20 theExitProc-:{\ul\cf5 ExitProc}{\v Process_ExitProc
};\par
\pard\s30\plain\li0\sb60\f1\fs20 \par
\page
{\ {\super #}\footnote \pard\plain{\super #}Process_importantExitProc}{\ {\super 
$}\footnote \pard\plain{\super $}Process.importantExitProc}{\ {\super K}\footnote \pard\plain{\super 
K}importantExitProc}\pard\s30\plain\li0\sb60\f1\fs20 {\b importantExitProc}\par
\pard\s27\plain\li0\sb120\tx1702\f2\fs20 importantExitProc*:;\par
\pard\s30\plain\li0\sb60\f1\fs20 \par
\page
{\ {\super #}\footnote \pard\plain{\super #}Process_terminateMsgLoops}{\ {\super 
$}\footnote \pard\plain{\super $}Process.terminateMsgLoops}{\ {\super K}\footnote \pard\plain{\super 
K}terminateMsgLoops}\pard\s30\plain\li0\sb60\f1\fs20 {\b terminateMsgLoops}\par
\pard\s27\plain\li0\sb120\tx1702\f2\fs20 terminateMsgLoops-:BOOLEAN;\par
\pard\s30\plain\li0\sb60\f1\fs20 \par
\page
{\ {\super #}\footnote \pard\plain{\super #}Process_breakEnabled}{\ {\super $}\footnote \pard\plain{\super 
$}Process.breakEnabled}{\ {\super K}\footnote \pard\plain{\super K}breakEnabled}\pard\s30
\plain\li0\sb60\f1\fs20 {\b breakEnabled}\par
\pard\s27\plain\li0\sb120\tx1702\f2\fs20 breakEnabled-:BOOLEAN;\par
\pard\s30\plain\li0\sb60\f1\fs20 \par
\page
{\ {\super #}\footnote \pard\plain{\super #}Process_ExitProc}{\ {\super $}\footnote \pard\plain{\super 
$}Process.ExitProc}{\ {\super K}\footnote \pard\plain{\super K}ExitProc}\pard\s30
\plain\li0\sb60\f1\fs20 {\b ExitProc}\par
\pard\s27\plain\li0\sb120\tx1702\f2\fs20 ExitProc*=PROCEDURE ();\par
\page
{\ {\super #}\footnote \pard\plain{\super #}Strings}{\ {\super $}\footnote \pard\plain{\super 
$}module Strings}{\ {\super K}\footnote \pard\plain{\super K}Strings}\pard\s28\plain\li0\sb120\sa120\keepn\f1\fs28\b 
Module Strings\par
\pard\s30\plain\li0\sb60\f1\fs20 This module provides functions for string processing. This includes combining
 strings, copying parts of a string, the conversion of a string to a number or vice-versa etc.
\par
All functions of this module start to count the character positions with one i.e. the first character of a string is at position one.
\par
All procedures applying to characters instead of strings have a trailing "Char" in their names.
\par
All procedures should be save. If character arrays are being used which are to short for a result, the result will be truncated accordingly.
 All functions tolerate errors in character position. However, strings must always be terminated by a character with the code zero in order
 to be processed correctly, otherwise runtime errors may occur.\par
\pard\s29\plain\li0\sb180\f1\fs24\b Constants\par
\pard\s32\plain\f1\fs20\sb60\fi-2880\li2880 ISSHORTINT\tab
\tab
\par
\pard\s32\plain\f1\fs20\sb60\fi-2880\li2880 ISINTEGER\tab
\tab
\par
\pard\s32\plain\f1\fs20\sb60\fi-2880\li2880 ISLONGINT\tab
\tab
\par
\pard\s32\plain\f1\fs20\sb60\fi-2880\li2880 ISOUTOFRANGE\tab
\par
\pard\s32\plain\f1\fs20\sb60\fi-2880\li2880 STRINGEMPTY\tab
\par
\pard\s32\plain\f1\fs20\sb60\fi-2880\li2880 STRINGILLEGAL\tab
\par
\pard\s29\plain\li0\sb180\f1\fs24\b Types\par
\pard\s30\plain\li0\sb60\f1\fs20 {\ul\cf5 StringT}{\v Strings_StringT}\par
{\ul\cf5 String}{\v Strings_String}\par
\pard\s29\plain\li0\sb180\f1\fs24\b Procedures\par
\pard\s30\plain\li0\sb60\f1\fs20 {\strike\cf5 Length}{\v Strings_Length}\par
{\strike\cf5 PosChar}{\v Strings_PosChar}\par
{\strike\cf5 Pos}{\v Strings_Pos}\par
{\strike\cf5 Copy}{\v Strings_Copy}\par
{\strike\cf5 Append}{\v Strings_Append}\par
{\strike\cf5 AppendChar}{\v Strings_AppendChar}\par
{\strike\cf5 UpCaseChar}{\v Strings_UpCaseChar}\par
{\strike\cf5 UpCase}{\v Strings_UpCase}\par
{\strike\cf5 Delete}{\v Strings_Delete}\par
{\strike\cf5 RemoveTrailingSpaces}{\v Strings_RemoveTrailingSpaces}\par
{\strike\cf5 RemoveLeadingSpaces}{\v Strings_RemoveLeadingSpaces}\par
{\strike\cf5 Val}{\v Strings_Val}\par
{\strike\cf5 ValResult}{\v Strings_ValResult}\par
{\strike\cf5 Str}{\v Strings_Str}\par
{\strike\cf5 HexStr}{\v Strings_HexStr}\par
{\strike\cf5 InsertChar}{\v Strings_InsertChar}\par
{\strike\cf5 Insert}{\v Strings_Insert}\par
{\strike\cf5 LeftAlign}{\v Strings_LeftAlign}\par
{\strike\cf5 RightAlign}{\v Strings_RightAlign}\par
\page
{\ {\super #}\footnote \pard\plain{\super #}Strings_Length}{\ {\super $}\footnote \pard\plain{\super 
$}Strings.Length}{\ {\super K}\footnote \pard\plain{\super K}Length}\pard\s28\plain\li0\sb120\sa120\keepn\f1\fs28\b 
Length\par
\pard\s31\plain\li0\sb120\sa120\f1\fs20\b defined in module {\strike\cf5 Strings}{\v 
Strings}\par
\pard\s29\plain\li0\sb180\f1\fs24\b Syntax\par
\pard\s27\plain\li0\sb120\tx1702\f2\fs20 PROCEDURE Length(VAR t-:{\ul\cf5 StringT
}{\v Strings_StringT}):LONGINT\par
\pard\s29\plain\li0\sb180\f1\fs24\b Description\par
\pard\s30\plain\li0\sb60\f1\fs20 Returns the length of a zero terminated string in characters. 
\par
\page
{\ {\super #}\footnote \pard\plain{\super #}Strings_PosChar}{\ {\super $}\footnote \pard\plain{\super 
$}Strings.PosChar}{\ {\super K}\footnote \pard\plain{\super K}PosChar}\pard\s28\plain\li0\sb120\sa120\keepn\f1\fs28\b 
PosChar\par
\pard\s31\plain\li0\sb120\sa120\f1\fs20\b defined in module {\strike\cf5 Strings}{\v 
Strings}\par
\pard\s29\plain\li0\sb180\f1\fs24\b Syntax\par
\pard\s27\plain\li0\sb120\tx1702\f2\fs20 PROCEDURE PosChar(x:CHAR; \line
                  VAR t-:{\ul\cf5 StringT}{\v Strings_StringT}; \line
                  start:LONGINT):LONGINT\par
\pard\s29\plain\li0\sb180\f1\fs24\b Parameters\par
\pard\s32\plain\f1\fs20\sb60\fi-2880\li2880 start\tab
\tab
\tab
\tab
\pard\s32\plain\f1\fs20\sb60\fi-2880\li2880 Indicates the position starting from which
 the search is to be carried out. If start is less than one it is set to one. If start denotes a
 position beyond the end of t the function returns zero. \par
\pard\s29\plain\li0\sb180\f1\fs24\b Description\par
\pard\s30\plain\li0\sb60\f1\fs20 This function returns the position of the character 
{\b x} in the string {\b t}. If {\b x} does not occur in {\b t} zero is returned. If 
{\b x} occurs several times the position of the first occurrence is returned. \par

\page
{\ {\super #}\footnote \pard\plain{\super #}Strings_Pos}{\ {\super $}\footnote \pard\plain{\super 
$}Strings.Pos}{\ {\super K}\footnote \pard\plain{\super K}Pos}\pard\s28\plain\li0\sb120\sa120\keepn\f1\fs28\b 
Pos\par
\pard\s31\plain\li0\sb120\sa120\f1\fs20\b defined in module {\strike\cf5 Strings}{\v 
Strings}\par
\pard\s29\plain\li0\sb180\f1\fs24\b Syntax\par
\pard\s27\plain\li0\sb120\tx1702\f2\fs20 PROCEDURE Pos(VAR pattern-:{\ul\cf5 StringT
}{\v Strings_StringT}; \line
              VAR t-:{\ul\cf5 StringT}{\v Strings_StringT}; \line
              start:LONGINT):LONGINT\par
\pard\s29\plain\li0\sb180\f1\fs24\b Parameters\par
\pard\s32\plain\f1\fs20\sb60\fi-2880\li2880 start\tab
\tab
\tab
\tab
\pard\s32\plain\f1\fs20\sb60\fi-2880\li2880 Indicates the position starting from which the search shall be
 carried out. If start is less than one it is set to one. If start denotes a position beyond the end of t the function returns zero. 
\par
\pard\s29\plain\li0\sb180\f1\fs24\b Description\par
\pard\s30\plain\li0\sb60\f1\fs20 This function returns the position of the string pattern in the string 
{\b t}. If pattern does not occur in {\b t} zero is returned. If the pattern occurs several
 times the position of the first occurrence is returned. \par
\page
{\ {\super #}\footnote \pard\plain{\super #}Strings_Copy}{\ {\super $}\footnote \pard\plain{\super 
$}Strings.Copy}{\ {\super K}\footnote \pard\plain{\super K}Copy}\pard\s28\plain\li0\sb120\sa120\keepn\f1\fs28\b 
Copy\par
\pard\s31\plain\li0\sb120\sa120\f1\fs20\b defined in module {\strike\cf5 Strings}{\v 
Strings}\par
\pard\s29\plain\li0\sb180\f1\fs24\b Syntax\par
\pard\s27\plain\li0\sb120\tx1702\f2\fs20 PROCEDURE Copy(VAR source-, dest:{\ul\cf5 
StringT}{\v Strings_StringT}; \line
               pos, n:LONGINT)\par
\pard\s29\plain\li0\sb180\f1\fs24\b Parameters\par
\pard\s32\plain\f1\fs20\sb60\fi-2880\li2880 pos\tab
\tab
\tab
\tab
\pard\s32\plain\f1\fs20\sb60\fi-2880\li2880 character position of the source fragment 
\par
\pard\s32\plain\f1\fs20\sb60\fi-2880\li2880 n\tab
\tab
\tab
\tab
\pard\s32\plain\f1\fs20\sb60\fi-2880\li2880 length of the source fragment \par
\pard\s29\plain\li0\sb180\f1\fs24\b Description\par
\pard\s30\plain\li0\sb60\f1\fs20 A section of the string {\b source} is copied to the string 
{\b dest}. The former contents of {\b dest} are overwritten and therefore lost.\par

The copied section in {\b source} starts at the position {\b pos} and is {\b n} characters long.
\par
If {\b dest} is not large enough to hold the copied string then only the part that fits into 
{\b dest} is copied. \par
\page
{\ {\super #}\footnote \pard\plain{\super #}Strings_Append}{\ {\super $}\footnote \pard\plain{\super 
$}Strings.Append}{\ {\super K}\footnote \pard\plain{\super K}Append}\pard\s28\plain\li0\sb120\sa120\keepn\f1\fs28\b 
Append\par
\pard\s31\plain\li0\sb120\sa120\f1\fs20\b defined in module {\strike\cf5 Strings}{\v 
Strings}\par
\pard\s29\plain\li0\sb180\f1\fs24\b Syntax\par
\pard\s27\plain\li0\sb120\tx1702\f2\fs20 PROCEDURE Append(VAR dest:{\ul\cf5 StringT
}{\v Strings_StringT}; \line
                 VAR src-:{\ul\cf5 StringT}{\v Strings_StringT})\par
\pard\s29\plain\li0\sb180\f1\fs24\b Description\par
\pard\s30\plain\li0\sb60\f1\fs20 The string {\b src} is appended to the string {\b 
dest}. \par
\page
{\ {\super #}\footnote \pard\plain{\super #}Strings_AppendChar}{\ {\super $}\footnote \pard\plain{\super 
$}Strings.AppendChar}{\ {\super K}\footnote \pard\plain{\super K}AppendChar}\pard\s28
\plain\li0\sb120\sa120\keepn\f1\fs28\b AppendChar\par
\pard\s31\plain\li0\sb120\sa120\f1\fs20\b defined in module {\strike\cf5 Strings}{\v 
Strings}\par
\pard\s29\plain\li0\sb180\f1\fs24\b Syntax\par
\pard\s27\plain\li0\sb120\tx1702\f2\fs20 PROCEDURE AppendChar(VAR dest:{\ul\cf5 StringT
}{\v Strings_StringT}; \line
                     ch:CHAR)\par
\pard\s29\plain\li0\sb180\f1\fs24\b Description\par
\pard\s30\plain\li0\sb60\f1\fs20 The character {\b ch} is appended to the string 
{\b dest}. \par
\page
{\ {\super #}\footnote \pard\plain{\super #}Strings_UpCaseChar}{\ {\super $}\footnote \pard\plain{\super 
$}Strings.UpCaseChar}{\ {\super K}\footnote \pard\plain{\super K}UpCaseChar}\pard\s28
\plain\li0\sb120\sa120\keepn\f1\fs28\b UpCaseChar\par
\pard\s31\plain\li0\sb120\sa120\f1\fs20\b defined in module {\strike\cf5 Strings}{\v 
Strings}\par
\pard\s29\plain\li0\sb180\f1\fs24\b Syntax\par
\pard\s27\plain\li0\sb120\tx1702\f2\fs20 PROCEDURE UpCaseChar(x:CHAR):CHAR\par
\pard\s29\plain\li0\sb180\f1\fs24\b Description\par
\pard\s30\plain\li0\sb60\f1\fs20 For all lower case letters the corresponding capital letter is returned. This also
 applies to international characters such as \'e4, \'e1, \'e0, \'e2... All other characters are
 returned unchanged. The difference between this function and the Oberon-2 function
 CAP(x:CHAR): CHAR is that the return value for characters other than lower case 
letters of the latter function depends on the individual compiler implementation. 
\par
\page
{\ {\super #}\footnote \pard\plain{\super #}Strings_UpCase}{\ {\super $}\footnote \pard\plain{\super 
$}Strings.UpCase}{\ {\super K}\footnote \pard\plain{\super K}UpCase}\pard\s28\plain\li0\sb120\sa120\keepn\f1\fs28\b 
UpCase\par
\pard\s31\plain\li0\sb120\sa120\f1\fs20\b defined in module {\strike\cf5 Strings}{\v 
Strings}\par
\pard\s29\plain\li0\sb180\f1\fs24\b Syntax\par
\pard\s27\plain\li0\sb120\tx1702\f2\fs20 PROCEDURE UpCase(VAR t:{\ul\cf5 StringT}{\v 
Strings_StringT})\par
\pard\s29\plain\li0\sb180\f1\fs24\b Description\par
\pard\s30\plain\li0\sb60\f1\fs20 All lower case letters in {\b t} are converted to upper case. This also
 applies to international characters such as \'e4, \'e1, \'e0, \'e2... All other characters are
 returned unchanged. \par
\page
{\ {\super #}\footnote \pard\plain{\super #}Strings_Delete}{\ {\super $}\footnote \pard\plain{\super 
$}Strings.Delete}{\ {\super K}\footnote \pard\plain{\super K}Delete}\pard\s28\plain\li0\sb120\sa120\keepn\f1\fs28\b 
Delete\par
\pard\s31\plain\li0\sb120\sa120\f1\fs20\b defined in module {\strike\cf5 Strings}{\v 
Strings}\par
\pard\s29\plain\li0\sb180\f1\fs24\b Syntax\par
\pard\s27\plain\li0\sb120\tx1702\f2\fs20 PROCEDURE Delete(VAR t:{\ul\cf5 StringT}{\v 
Strings_StringT}; \line
                 pos, n:LONGINT)\par
\pard\s29\plain\li0\sb180\f1\fs24\b Description\par
\pard\s30\plain\li0\sb60\f1\fs20 Starting at the position {\b pos} {\b n} characters of the string 
{\b t} are deleted. \par
\page
{\ {\super #}\footnote \pard\plain{\super #}Strings_RemoveTrailingSpaces}{\ {\super 
$}\footnote \pard\plain{\super $}Strings.RemoveTrailingSpaces}{\ {\super K}\footnote \pard\plain{\super 
K}RemoveTrailingSpaces}\pard\s28\plain\li0\sb120\sa120\keepn\f1\fs28\b RemoveTrailingSpaces
\par
\pard\s31\plain\li0\sb120\sa120\f1\fs20\b defined in module {\strike\cf5 Strings}{\v 
Strings}\par
\pard\s29\plain\li0\sb180\f1\fs24\b Syntax\par
\pard\s27\plain\li0\sb120\tx1702\f2\fs20 PROCEDURE RemoveTrailingSpaces(VAR t:{\ul\cf5 
StringT}{\v Strings_StringT})\par
\pard\s29\plain\li0\sb180\f1\fs24\b Description\par
\pard\s30\plain\li0\sb60\f1\fs20 All blanks at the end of {\b t} are removed. \par

\page
{\ {\super #}\footnote \pard\plain{\super #}Strings_RemoveLeadingSpaces}{\ {\super 
$}\footnote \pard\plain{\super $}Strings.RemoveLeadingSpaces}{\ {\super K}\footnote \pard\plain{\super 
K}RemoveLeadingSpaces}\pard\s28\plain\li0\sb120\sa120\keepn\f1\fs28\b RemoveLeadingSpaces
\par
\pard\s31\plain\li0\sb120\sa120\f1\fs20\b defined in module {\strike\cf5 Strings}{\v 
Strings}\par
\pard\s29\plain\li0\sb180\f1\fs24\b Syntax\par
\pard\s27\plain\li0\sb120\tx1702\f2\fs20 PROCEDURE RemoveLeadingSpaces(VAR t:{\ul\cf5 
StringT}{\v Strings_StringT})\par
\pard\s29\plain\li0\sb180\f1\fs24\b Description\par
\pard\s30\plain\li0\sb60\f1\fs20 All blanks at the beginning of {\b t} are removed. 
\par
\page
{\ {\super #}\footnote \pard\plain{\super #}Strings_Val}{\ {\super $}\footnote \pard\plain{\super 
$}Strings.Val}{\ {\super K}\footnote \pard\plain{\super K}Val}\pard\s28\plain\li0\sb120\sa120\keepn\f1\fs28\b 
Val\par
\pard\s31\plain\li0\sb120\sa120\f1\fs20\b defined in module {\strike\cf5 Strings}{\v 
Strings}\par
\pard\s29\plain\li0\sb180\f1\fs24\b Syntax\par
\pard\s27\plain\li0\sb120\tx1702\f2\fs20 PROCEDURE Val(t:{\ul\cf5 StringT}{\v Strings_StringT
}):LONGINT\par
\pard\s29\plain\li0\sb180\f1\fs24\b Description\par
\pard\s30\plain\li0\sb60\f1\fs20 The string {\b t} is converted to a number and returned as result of the function.
\par
If the character sequence in {\b t} does not represent a number and thus the conversion to a number fails the smallest negative number (MIN(LONGINT)) is returned.
 Blanks at the beginning and the end of {\b t} are ignored. The number must not contain blanks. 
\par
\page
{\ {\super #}\footnote \pard\plain{\super #}Strings_ValResult}{\ {\super $}\footnote \pard\plain{\super 
$}Strings.ValResult}{\ {\super K}\footnote \pard\plain{\super K}ValResult}\pard\s28
\plain\li0\sb120\sa120\keepn\f1\fs28\b ValResult\par
\pard\s31\plain\li0\sb120\sa120\f1\fs20\b defined in module {\strike\cf5 Strings}{\v 
Strings}\par
\pard\s29\plain\li0\sb180\f1\fs24\b Syntax\par
\pard\s27\plain\li0\sb120\tx1702\f2\fs20 PROCEDURE ValResult(t:{\ul\cf5 StringT}{\v 
Strings_StringT}):INTEGER\par
\pard\s29\plain\li0\sb180\f1\fs24\b Description\par
\pard\s30\plain\li0\sb60\f1\fs20 This function can be used to discover whether the string 
{\b t} can be converted to a number, and which kind of integer is at least necessary for storing it.
\par
The IS??? constants defined for the return value have a numerical order defined relative to each other:
\par
ISSHORTINT < ISINTEGER < ISLONGINT < ISOUTOFRANGE < (STRINGEMPTY, STRINGILLEGAL)\par

This definition makes it easier to find out if e.g. a number is small enough to be stored in a INTEGER variable.
\par
IF Strings.ValResult(txt)<=Strings.ISINTEGER THEN ... END;\par
instead of\par
IF (Strings.ValResult(txt)=Strings.ISSHORTINT) OR (Strings.ValResult(txt)=Strings.ISINTEGER) THEN ... 
\par
\page
{\ {\super #}\footnote \pard\plain{\super #}Strings_Str}{\ {\super $}\footnote \pard\plain{\super 
$}Strings.Str}{\ {\super K}\footnote \pard\plain{\super K}Str}\pard\s28\plain\li0\sb120\sa120\keepn\f1\fs28\b 
Str\par
\pard\s31\plain\li0\sb120\sa120\f1\fs20\b defined in module {\strike\cf5 Strings}{\v 
Strings}\par
\pard\s29\plain\li0\sb180\f1\fs24\b Syntax\par
\pard\s27\plain\li0\sb120\tx1702\f2\fs20 PROCEDURE Str(x:LONGINT; \line
              VAR t:{\ul\cf5 StringT}{\v Strings_StringT})\par
\pard\s29\plain\li0\sb180\f1\fs24\b Description\par
\pard\s30\plain\li0\sb60\f1\fs20 The number {\b x} is converted to a string and the result is stored in 
{\b t}. If {\b t} is not large enough to hold all characters of the number, {\b t
} is filled with "$" characters. \par
\page
{\ {\super #}\footnote \pard\plain{\super #}Strings_HexStr}{\ {\super $}\footnote \pard\plain{\super 
$}Strings.HexStr}{\ {\super K}\footnote \pard\plain{\super K}HexStr}\pard\s28\plain\li0\sb120\sa120\keepn\f1\fs28\b 
HexStr\par
\pard\s31\plain\li0\sb120\sa120\f1\fs20\b defined in module {\strike\cf5 Strings}{\v 
Strings}\par
\pard\s29\plain\li0\sb180\f1\fs24\b Syntax\par
\pard\s27\plain\li0\sb120\tx1702\f2\fs20 PROCEDURE HexStr(x:LONGINT; \line
                 VAR t:{\ul\cf5 StringT}{\v Strings_StringT})\par
\pard\s29\plain\li0\sb180\f1\fs24\b Description\par
\pard\s30\plain\li0\sb60\f1\fs20 The number {\b x} is converted to a string of hexadecimal format and the result is stored
 in {\b t}. At the end of the string an "h" is appended to indicate the hexadecimal
 representation of the number.\par
If {\b t} is not large enough to hold all characters of the number, {\b t} is filled with "$"
 characters. Example: 0 becomes "0h", 15 becomes "Fh", 16 becomes "10h". \par
\page
{\ {\super #}\footnote \pard\plain{\super #}Strings_InsertChar}{\ {\super $}\footnote \pard\plain{\super 
$}Strings.InsertChar}{\ {\super K}\footnote \pard\plain{\super K}InsertChar}\pard\s28
\plain\li0\sb120\sa120\keepn\f1\fs28\b InsertChar\par
\pard\s31\plain\li0\sb120\sa120\f1\fs20\b defined in module {\strike\cf5 Strings}{\v 
Strings}\par
\pard\s29\plain\li0\sb180\f1\fs24\b Syntax\par
\pard\s27\plain\li0\sb120\tx1702\f2\fs20 PROCEDURE InsertChar(x:CHAR; \line
                     VAR t:{\ul\cf5 StringT}{\v Strings_StringT}; \line
                     pos:LONGINT)\par
\pard\s29\plain\li0\sb180\f1\fs24\b Description\par
\pard\s30\plain\li0\sb60\f1\fs20 The character {\b x} is inserted into the string 
{\b t} at the position {\b pos} if {\b t} provides space for it. \par
\page
{\ {\super #}\footnote \pard\plain{\super #}Strings_Insert}{\ {\super $}\footnote \pard\plain{\super 
$}Strings.Insert}{\ {\super K}\footnote \pard\plain{\super K}Insert}\pard\s28\plain\li0\sb120\sa120\keepn\f1\fs28\b 
Insert\par
\pard\s31\plain\li0\sb120\sa120\f1\fs20\b defined in module {\strike\cf5 Strings}{\v 
Strings}\par
\pard\s29\plain\li0\sb180\f1\fs24\b Syntax\par
\pard\s27\plain\li0\sb120\tx1702\f2\fs20 PROCEDURE Insert(VAR source-:{\ul\cf5 StringT
}{\v Strings_StringT}; \line
                 VAR dest:{\ul\cf5 StringT}{\v Strings_StringT}; \line
                 pos:LONGINT)\par
\pard\s29\plain\li0\sb180\f1\fs24\b Description\par
\pard\s30\plain\li0\sb60\f1\fs20 The string {\b source} is inserted into the string 
{\b dest} at the position {\b pos}. If the maximum length of {\b dest} is insufficient to store the result only
 the part of {\b source} fitting in {\b dest} is inserted. \par
\page
{\ {\super #}\footnote \pard\plain{\super #}Strings_LeftAlign}{\ {\super $}\footnote \pard\plain{\super 
$}Strings.LeftAlign}{\ {\super K}\footnote \pard\plain{\super K}LeftAlign}\pard\s28
\plain\li0\sb120\sa120\keepn\f1\fs28\b LeftAlign\par
\pard\s31\plain\li0\sb120\sa120\f1\fs20\b defined in module {\strike\cf5 Strings}{\v 
Strings}\par
\pard\s29\plain\li0\sb180\f1\fs24\b Syntax\par
\pard\s27\plain\li0\sb120\tx1702\f2\fs20 PROCEDURE LeftAlign(VAR t:{\ul\cf5 StringT
}{\v Strings_StringT}; \line
                    n:LONGINT)\par
\pard\s29\plain\li0\sb180\f1\fs24\b Description\par
\pard\s30\plain\li0\sb60\f1\fs20 The length of {\b t} is increased to {\b n} characters by appending blanks. If 
{\b t} has already the appropriate length or is longer {\b t} remains unchanged. 
\par
\page
{\ {\super #}\footnote \pard\plain{\super #}Strings_RightAlign}{\ {\super $}\footnote \pard\plain{\super 
$}Strings.RightAlign}{\ {\super K}\footnote \pard\plain{\super K}RightAlign}\pard\s28
\plain\li0\sb120\sa120\keepn\f1\fs28\b RightAlign\par
\pard\s31\plain\li0\sb120\sa120\f1\fs20\b defined in module {\strike\cf5 Strings}{\v 
Strings}\par
\pard\s29\plain\li0\sb180\f1\fs24\b Syntax\par
\pard\s27\plain\li0\sb120\tx1702\f2\fs20 PROCEDURE RightAlign(VAR t:{\ul\cf5 StringT
}{\v Strings_StringT}; \line
                     n:LONGINT)\par
\pard\s29\plain\li0\sb180\f1\fs24\b Description\par
\pard\s30\plain\li0\sb60\f1\fs20 The length of {\b t} is increased to {\b n} characters by inserting blanks at the
 beginning. If {\b t} has already the appropriate length or is longer {\b t} remains unchanged. 
\par
\page
{\ {\super #}\footnote \pard\plain{\super #}Strings_StringT}{\ {\super $}\footnote \pard\plain{\super 
$}Strings.StringT}{\ {\super K}\footnote \pard\plain{\super K}StringT}\pard\s30\plain\li0\sb60\f1\fs20 
{\b StringT}\par
\pard\s27\plain\li0\sb120\tx1702\f2\fs20 StringT*=ARRAY OF CHAR;\par
\page
{\ {\super #}\footnote \pard\plain{\super #}Strings_String}{\ {\super $}\footnote \pard\plain{\super 
$}Strings.String}{\ {\super K}\footnote \pard\plain{\super K}String}\pard\s30\plain\li0\sb60\f1\fs20 
{\b String}\par
\pard\s27\plain\li0\sb120\tx1702\f2\fs20 String*=POINTER TO {\ul\cf5 StringT}{\v 
Strings_StringT};\par
\page
{\ {\super #}\footnote \pard\plain{\super #}Utils}{\ {\super $}\footnote \pard\plain{\super 
$}module Utils}{\ {\super K}\footnote \pard\plain{\super K}Utils}\pard\s28\plain\li0\sb120\sa120\keepn\f1\fs28\b 
Module Utils\par
\pard\s30\plain\li0\sb60\f1\fs20 The functions implemented here tend to be system dependent. Therefore the
 module Utils is a relative of the module SYSTEM. The import of Utils is an indicator that the program using it is
 non-portable\par
\pard\s29\plain\li0\sb180\f1\fs24\b Procedures\par
\pard\s30\plain\li0\sb60\f1\fs20 {\strike\cf5 BitAnd}{\v Utils_BitAnd}\par
{\strike\cf5 BitXOr}{\v Utils_BitXOr}\par
{\strike\cf5 BitOr}{\v Utils_BitOr}\par
{\strike\cf5 BitNot}{\v Utils_BitNot}\par
{\strike\cf5 BitAndL}{\v Utils_BitAndL}\par
{\strike\cf5 BitXOrL}{\v Utils_BitXOrL}\par
{\strike\cf5 BitOrL}{\v Utils_BitOrL}\par
{\strike\cf5 BitNotL}{\v Utils_BitNotL}\par
{\strike\cf5 LoWord}{\v Utils_LoWord}\par
{\strike\cf5 HiWord}{\v Utils_HiWord}\par
{\strike\cf5 LoByte}{\v Utils_LoByte}\par
{\strike\cf5 HiByte}{\v Utils_HiByte}\par
{\strike\cf5 MakeLong}{\v Utils_MakeLong}\par
{\strike\cf5 MakeWord}{\v Utils_MakeWord}\par
{\strike\cf5 GetDate}{\v Utils_GetDate}\par
{\strike\cf5 GetTime}{\v Utils_GetTime}\par
{\strike\cf5 GetDateStr}{\v Utils_GetDateStr}\par
{\strike\cf5 GetTimeStr}{\v Utils_GetTimeStr}\par
\page
{\ {\super #}\footnote \pard\plain{\super #}Utils_BitAnd}{\ {\super $}\footnote \pard\plain{\super 
$}Utils.BitAnd}{\ {\super K}\footnote \pard\plain{\super K}BitAnd}\pard\s28\plain\li0\sb120\sa120\keepn\f1\fs28\b 
BitAnd\par
\pard\s31\plain\li0\sb120\sa120\f1\fs20\b defined in module {\strike\cf5 Utils}{\v 
Utils}\par
\pard\s29\plain\li0\sb180\f1\fs24\b Syntax\par
\pard\s27\plain\li0\sb120\tx1702\f2\fs20 PROCEDURE BitAnd(a, b:INTEGER):INTEGER\par

\pard\s29\plain\li0\sb180\f1\fs24\b Description\par
\pard\s30\plain\li0\sb60\f1\fs20 A bitwise AND is applied to the values {\b a} and 
{\b b}, and the result returned.\par
The module SYSTEM now supports an equivalent function which is resolved in-line and therefore does not generate the overhead of a procedure call:
 SYSTEM.BITAND  \par
\page
{\ {\super #}\footnote \pard\plain{\super #}Utils_BitXOr}{\ {\super $}\footnote \pard\plain{\super 
$}Utils.BitXOr}{\ {\super K}\footnote \pard\plain{\super K}BitXOr}\pard\s28\plain\li0\sb120\sa120\keepn\f1\fs28\b 
BitXOr\par
\pard\s31\plain\li0\sb120\sa120\f1\fs20\b defined in module {\strike\cf5 Utils}{\v 
Utils}\par
\pard\s29\plain\li0\sb180\f1\fs24\b Syntax\par
\pard\s27\plain\li0\sb120\tx1702\f2\fs20 PROCEDURE BitXOr(a, b:INTEGER):INTEGER\par

\pard\s29\plain\li0\sb180\f1\fs24\b Description\par
\pard\s30\plain\li0\sb60\f1\fs20 A bitwise XOR is applied to the values {\b a} and 
{\b b}, and the result returned.\par
The module SYSTEM now supports an equivalent function which is resolved in-line and therefore does not generate the overhead of a procedure call:
 SYSTEM.BITXOR  \par
\page
{\ {\super #}\footnote \pard\plain{\super #}Utils_BitOr}{\ {\super $}\footnote \pard\plain{\super 
$}Utils.BitOr}{\ {\super K}\footnote \pard\plain{\super K}BitOr}\pard\s28\plain\li0\sb120\sa120\keepn\f1\fs28\b 
BitOr\par
\pard\s31\plain\li0\sb120\sa120\f1\fs20\b defined in module {\strike\cf5 Utils}{\v 
Utils}\par
\pard\s29\plain\li0\sb180\f1\fs24\b Syntax\par
\pard\s27\plain\li0\sb120\tx1702\f2\fs20 PROCEDURE BitOr(a, b:INTEGER):INTEGER\par

\pard\s29\plain\li0\sb180\f1\fs24\b Description\par
\pard\s30\plain\li0\sb60\f1\fs20 A bitwise OR is applied to the values {\b a} and 
{\b b}, and the result returned.\par
The module SYSTEM now supports an equivalent function which is resolved in-line and therefore does not generate the overhead of a procedure call:
 SYSTEM.BITOR  \par
\page
{\ {\super #}\footnote \pard\plain{\super #}Utils_BitNot}{\ {\super $}\footnote \pard\plain{\super 
$}Utils.BitNot}{\ {\super K}\footnote \pard\plain{\super K}BitNot}\pard\s28\plain\li0\sb120\sa120\keepn\f1\fs28\b 
BitNot\par
\pard\s31\plain\li0\sb120\sa120\f1\fs20\b defined in module {\strike\cf5 Utils}{\v 
Utils}\par
\pard\s29\plain\li0\sb180\f1\fs24\b Syntax\par
\pard\s27\plain\li0\sb120\tx1702\f2\fs20 PROCEDURE BitNot(a:INTEGER):INTEGER\par
\pard\s29\plain\li0\sb180\f1\fs24\b Description\par
\pard\s30\plain\li0\sb60\f1\fs20 The value of {\b a} is bitwise negated, and the result returned.
\par
The module SYSTEM now supports an equivalent function which is resolved in-line and therefore does not generate the overhead of a procedure call:
 SYSTEM.BITNOT  \par
\page
{\ {\super #}\footnote \pard\plain{\super #}Utils_BitAndL}{\ {\super $}\footnote \pard\plain{\super 
$}Utils.BitAndL}{\ {\super K}\footnote \pard\plain{\super K}BitAndL}\pard\s28\plain\li0\sb120\sa120\keepn\f1\fs28\b 
BitAndL\par
\pard\s31\plain\li0\sb120\sa120\f1\fs20\b defined in module {\strike\cf5 Utils}{\v 
Utils}\par
\pard\s29\plain\li0\sb180\f1\fs24\b Syntax\par
\pard\s27\plain\li0\sb120\tx1702\f2\fs20 PROCEDURE BitAndL(a, b:LONGINT):LONGINT\par

\pard\s29\plain\li0\sb180\f1\fs24\b Description\par
\pard\s30\plain\li0\sb60\f1\fs20 A bitwise AND is applied to the values {\b a} and 
{\b b}, and the result returned.\par
The module SYSTEM now supports an equivalent function which is resolved in-line and therefore does not generate the overhead of a procedure call:
 SYSTEM.BITAND  \par
\page
{\ {\super #}\footnote \pard\plain{\super #}Utils_BitXOrL}{\ {\super $}\footnote \pard\plain{\super 
$}Utils.BitXOrL}{\ {\super K}\footnote \pard\plain{\super K}BitXOrL}\pard\s28\plain\li0\sb120\sa120\keepn\f1\fs28\b 
BitXOrL\par
\pard\s31\plain\li0\sb120\sa120\f1\fs20\b defined in module {\strike\cf5 Utils}{\v 
Utils}\par
\pard\s29\plain\li0\sb180\f1\fs24\b Syntax\par
\pard\s27\plain\li0\sb120\tx1702\f2\fs20 PROCEDURE BitXOrL(a, b:LONGINT):LONGINT\par

\pard\s29\plain\li0\sb180\f1\fs24\b Description\par
\pard\s30\plain\li0\sb60\f1\fs20 A bitwise XOR is applied to the values {\b a} and 
{\b b}, and the result returned.\par
The module SYSTEM now supports an equivalent function which is resolved in-line and therefore does not generate the overhead of a procedure call:
 SYSTEM.BITXOR  \par
\page
{\ {\super #}\footnote \pard\plain{\super #}Utils_BitOrL}{\ {\super $}\footnote \pard\plain{\super 
$}Utils.BitOrL}{\ {\super K}\footnote \pard\plain{\super K}BitOrL}\pard\s28\plain\li0\sb120\sa120\keepn\f1\fs28\b 
BitOrL\par
\pard\s31\plain\li0\sb120\sa120\f1\fs20\b defined in module {\strike\cf5 Utils}{\v 
Utils}\par
\pard\s29\plain\li0\sb180\f1\fs24\b Syntax\par
\pard\s27\plain\li0\sb120\tx1702\f2\fs20 PROCEDURE BitOrL(a, b:LONGINT):LONGINT\par

\pard\s29\plain\li0\sb180\f1\fs24\b Description\par
\pard\s30\plain\li0\sb60\f1\fs20 A bitwise OR is applied to the values {\b a} and 
{\b b}, and the result returned.\par
The module SYSTEM now supports an equivalent function which is resolved in-line and therefore does not generate the overhead of a procedure call:
 SYSTEM.BITOR  \par
\page
{\ {\super #}\footnote \pard\plain{\super #}Utils_BitNotL}{\ {\super $}\footnote \pard\plain{\super 
$}Utils.BitNotL}{\ {\super K}\footnote \pard\plain{\super K}BitNotL}\pard\s28\plain\li0\sb120\sa120\keepn\f1\fs28\b 
BitNotL\par
\pard\s31\plain\li0\sb120\sa120\f1\fs20\b defined in module {\strike\cf5 Utils}{\v 
Utils}\par
\pard\s29\plain\li0\sb180\f1\fs24\b Syntax\par
\pard\s27\plain\li0\sb120\tx1702\f2\fs20 PROCEDURE BitNotL(a:LONGINT):LONGINT\par

\pard\s29\plain\li0\sb180\f1\fs24\b Description\par
\pard\s30\plain\li0\sb60\f1\fs20 The value of {\b a} is bitwise negated, and the result returned.
\par
The module SYSTEM now supports an equivalent function which is resolved in-line and therefore does not generate the overhead of a procedure call:
 SYSTEM.BITNOT  \par
\page
{\ {\super #}\footnote \pard\plain{\super #}Utils_LoWord}{\ {\super $}\footnote \pard\plain{\super 
$}Utils.LoWord}{\ {\super K}\footnote \pard\plain{\super K}LoWord}\pard\s28\plain\li0\sb120\sa120\keepn\f1\fs28\b 
LoWord\par
\pard\s31\plain\li0\sb120\sa120\f1\fs20\b defined in module {\strike\cf5 Utils}{\v 
Utils}\par
\pard\s29\plain\li0\sb180\f1\fs24\b Syntax\par
\pard\s27\plain\li0\sb120\tx1702\f2\fs20 PROCEDURE LoWord(x:LONGINT):INTEGER\par
\pard\s29\plain\li0\sb180\f1\fs24\b Description\par
\pard\s30\plain\li0\sb60\f1\fs20 The return value of LoWord is the least significant half of the four-byte
 value {\b x}.\par
The module SYSTEM now supports an equivalent function which is resolved in-line and therefore does not generate the overhead of a procedure call:
 SYSTEM.LOWORD  \par
\page
{\ {\super #}\footnote \pard\plain{\super #}Utils_HiWord}{\ {\super $}\footnote \pard\plain{\super 
$}Utils.HiWord}{\ {\super K}\footnote \pard\plain{\super K}HiWord}\pard\s28\plain\li0\sb120\sa120\keepn\f1\fs28\b 
HiWord\par
\pard\s31\plain\li0\sb120\sa120\f1\fs20\b defined in module {\strike\cf5 Utils}{\v 
Utils}\par
\pard\s29\plain\li0\sb180\f1\fs24\b Syntax\par
\pard\s27\plain\li0\sb120\tx1702\f2\fs20 PROCEDURE HiWord(x:LONGINT):INTEGER\par
\pard\s29\plain\li0\sb180\f1\fs24\b Description\par
\pard\s30\plain\li0\sb60\f1\fs20 The return value of HiWord is the most significant half of the four-byte
 value {\b x}.\par
The module SYSTEM now supports an equivalent function which is resolved in-line and therefore does not generate the overhead of a procedure call:
 SYSTEM.HIWORD  \par
\page
{\ {\super #}\footnote \pard\plain{\super #}Utils_LoByte}{\ {\super $}\footnote \pard\plain{\super 
$}Utils.LoByte}{\ {\super K}\footnote \pard\plain{\super K}LoByte}\pard\s28\plain\li0\sb120\sa120\keepn\f1\fs28\b 
LoByte\par
\pard\s31\plain\li0\sb120\sa120\f1\fs20\b defined in module {\strike\cf5 Utils}{\v 
Utils}\par
\pard\s29\plain\li0\sb180\f1\fs24\b Syntax\par
\pard\s27\plain\li0\sb120\tx1702\f2\fs20 PROCEDURE LoByte(x:INTEGER):CHAR\par
\pard\s29\plain\li0\sb180\f1\fs24\b Description\par
\pard\s30\plain\li0\sb60\f1\fs20 The return value of LoByte is the least significant byte of the two-byte
 value {\b x}. \par
\page
{\ {\super #}\footnote \pard\plain{\super #}Utils_HiByte}{\ {\super $}\footnote \pard\plain{\super 
$}Utils.HiByte}{\ {\super K}\footnote \pard\plain{\super K}HiByte}\pard\s28\plain\li0\sb120\sa120\keepn\f1\fs28\b 
HiByte\par
\pard\s31\plain\li0\sb120\sa120\f1\fs20\b defined in module {\strike\cf5 Utils}{\v 
Utils}\par
\pard\s29\plain\li0\sb180\f1\fs24\b Syntax\par
\pard\s27\plain\li0\sb120\tx1702\f2\fs20 PROCEDURE HiByte(x:INTEGER):CHAR\par
\pard\s29\plain\li0\sb180\f1\fs24\b Description\par
\pard\s30\plain\li0\sb60\f1\fs20 The return value of HiByte is the most significant byte of the two-byte
 value {\b x}. \par
\page
{\ {\super #}\footnote \pard\plain{\super #}Utils_MakeLong}{\ {\super $}\footnote \pard\plain{\super 
$}Utils.MakeLong}{\ {\super K}\footnote \pard\plain{\super K}MakeLong}\pard\s28\plain\li0\sb120\sa120\keepn\f1\fs28\b 
MakeLong\par
\pard\s31\plain\li0\sb120\sa120\f1\fs20\b defined in module {\strike\cf5 Utils}{\v 
Utils}\par
\pard\s29\plain\li0\sb180\f1\fs24\b Syntax\par
\pard\s27\plain\li0\sb120\tx1702\f2\fs20 PROCEDURE MakeLong(hi, lo:INTEGER):LONGINT
\par
\pard\s29\plain\li0\sb180\f1\fs24\b Description\par
\pard\s30\plain\li0\sb60\f1\fs20 The two-byte values {\b hi} and {\b lo} are combined to a four-byte value by
 concatenation and returned as result of the function. {\b hi} becomes the most significant and 
{\b lo} the least significant part of the result.\par
The module SYSTEM now supports an equivalent function which is resolved in-line and therefore does not generate the overhead of a procedure call:
 SYSTEM.MAKELONG  \par
\page
{\ {\super #}\footnote \pard\plain{\super #}Utils_MakeWord}{\ {\super $}\footnote \pard\plain{\super 
$}Utils.MakeWord}{\ {\super K}\footnote \pard\plain{\super K}MakeWord}\pard\s28\plain\li0\sb120\sa120\keepn\f1\fs28\b 
MakeWord\par
\pard\s31\plain\li0\sb120\sa120\f1\fs20\b defined in module {\strike\cf5 Utils}{\v 
Utils}\par
\pard\s29\plain\li0\sb180\f1\fs24\b Syntax\par
\pard\s27\plain\li0\sb120\tx1702\f2\fs20 PROCEDURE MakeWord(hi, lo:CHAR):INTEGER\par

\pard\s29\plain\li0\sb180\f1\fs24\b Description\par
\pard\s30\plain\li0\sb60\f1\fs20 The one-byte values {\b hi} and {\b lo} are combined to a two-byte value by
 concatenation and returned as result of the function. {\b hi} becomes the most significant and 
{\b lo} the least significant part of the result. \par
\page
{\ {\super #}\footnote \pard\plain{\super #}Utils_GetDate}{\ {\super $}\footnote \pard\plain{\super 
$}Utils.GetDate}{\ {\super K}\footnote \pard\plain{\super K}GetDate}\pard\s28\plain\li0\sb120\sa120\keepn\f1\fs28\b 
GetDate\par
\pard\s31\plain\li0\sb120\sa120\f1\fs20\b defined in module {\strike\cf5 Utils}{\v 
Utils}\par
\pard\s29\plain\li0\sb180\f1\fs24\b Syntax\par
\pard\s27\plain\li0\sb120\tx1702\f2\fs20 PROCEDURE GetDate(VAR day, month, year, 
dayOfWeek:INTEGER)\par
\pard\s29\plain\li0\sb180\f1\fs24\b Description\par
\pard\s30\plain\li0\sb60\f1\fs20 The current date is read from the system's real-time clock and returned
 in the parameters {\b day}, {\b month}, {\b year}, and {\b dayOfWeek}.\par
The year is stated including the century. In addition, in {\b dayOfWeek} a value between 1 and 7 is returned,
 where 1 denotes Monday and 7 Sunday. \par
\page
{\ {\super #}\footnote \pard\plain{\super #}Utils_GetTime}{\ {\super $}\footnote \pard\plain{\super 
$}Utils.GetTime}{\ {\super K}\footnote \pard\plain{\super K}GetTime}\pard\s28\plain\li0\sb120\sa120\keepn\f1\fs28\b 
GetTime\par
\pard\s31\plain\li0\sb120\sa120\f1\fs20\b defined in module {\strike\cf5 Utils}{\v 
Utils}\par
\pard\s29\plain\li0\sb180\f1\fs24\b Syntax\par
\pard\s27\plain\li0\sb120\tx1702\f2\fs20 PROCEDURE GetTime(VAR sec, min, hour:INTEGER
)\par
\pard\s29\plain\li0\sb180\f1\fs24\b Description\par
\pard\s30\plain\li0\sb60\f1\fs20 The current time is read from the system's real-time clock and returned
 in the parameters {\b sec}, {\b min}, and {\b hour}. \par
\page
{\ {\super #}\footnote \pard\plain{\super #}Utils_GetDateStr}{\ {\super $}\footnote \pard\plain{\super 
$}Utils.GetDateStr}{\ {\super K}\footnote \pard\plain{\super K}GetDateStr}\pard\s28
\plain\li0\sb120\sa120\keepn\f1\fs28\b GetDateStr\par
\pard\s31\plain\li0\sb120\sa120\f1\fs20\b defined in module {\strike\cf5 Utils}{\v 
Utils}\par
\pard\s29\plain\li0\sb180\f1\fs24\b Syntax\par
\pard\s27\plain\li0\sb120\tx1702\f2\fs20 PROCEDURE GetDateStr(VAR t:ARRAY OF CHAR
)\par
\pard\s29\plain\li0\sb180\f1\fs24\b Description\par
\pard\s30\plain\li0\sb60\f1\fs20 The current date is read from the system's real-time clock and returned
 as a string in {\b t}. The result is 10 characters long and has the format "dd.mm.yyyy". If 
{\b t} cannot hold a string of 10 characters length, a completely empty string is returned.
\par
\page
{\ {\super #}\footnote \pard\plain{\super #}Utils_GetTimeStr}{\ {\super $}\footnote \pard\plain{\super 
$}Utils.GetTimeStr}{\ {\super K}\footnote \pard\plain{\super K}GetTimeStr}\pard\s28
\plain\li0\sb120\sa120\keepn\f1\fs28\b GetTimeStr\par
\pard\s31\plain\li0\sb120\sa120\f1\fs20\b defined in module {\strike\cf5 Utils}{\v 
Utils}\par
\pard\s29\plain\li0\sb180\f1\fs24\b Syntax\par
\pard\s27\plain\li0\sb120\tx1702\f2\fs20 PROCEDURE GetTimeStr(VAR t:ARRAY OF CHAR
)\par
\pard\s29\plain\li0\sb180\f1\fs24\b Description\par
\pard\s30\plain\li0\sb60\f1\fs20 The current time is read from the system's real-time clock and
 returned as a string in {\b t}. The result is 8 characters long and has the format "HH.MM.SS". If 
{\b t} cannot hold a string of 8 characters length, a completely empty string is returned. 
\par
\page
{\ {\super #}\footnote \pard\plain{\super #}Volume}{\ {\super $}\footnote \pard\plain{\super 
$}module Volume}{\ {\super K}\footnote \pard\plain{\super K}Volume}\pard\s28\plain\li0\sb120\sa120\keepn\f1\fs28\b 
Module Volume\par
\pard\s30\plain\li0\sb60\f1\fs20 The Volume module provides facilities for creating, searching, and modifying
 file directories.\par
The module interface is designed to be applicable to different systems. The following notes refer exclusively to the file system of MS-DOS.
\par
Drives are identified by letters. The letter "A" refers to the first floppy disk, drive, "B" to the second,
 and "C" to the first hard disk drive. All letters down to "Z" may be used, but the settings vary from system to system. A drive is specified using
 a single letter or a letter followed by a colon passed as parameter. No distinction between uppercase and lowercase is made. For example,
 "a", "A:" and "A" have the same meaning.\par
A colon must be put after the drive identification when a path is defined, a path being a combination of a drive name and a file name. The backslash
 "\\" serves as a separating symbol between directory names. For compatibility with other systems the forward slash "/" may also be used. For example,
 a path statement "C:\\" refers to the root directory of the drive C.\par
For access to the current drive the drive identification may be omitted in path statements. If the only the drive identification is given as a parameter
 then a blank is passed as a reference to the current drive.\par
File names are passed through to the operating system without any modification. Therefore the rules for creating valid directory and
 filenames under MS-DOS must be adhered to.\par
All procedures with a parameter {\b resCode} return an error code. This code can be used to check if the function was carried out
 successfully ({\b resCode} = NOERROR) or indicate more details about the cause of the error.
\par
All errors occurring during file or drive operations are indicated by an appropriate error code there should be no cases where a
 runtime error is reported or the program is terminated. It is the programmer's responsibility to arrange for an error handling and to
 avoid further errors. The procedure GetErrorMessage provides an equivalent message for every possible error code and can be used for
 building error diagnostic dialogs.\par
\pard\s29\plain\li0\sb180\f1\fs24\b Constants\par
\pard\s32\plain\f1\fs20\sb60\fi-2880\li2880 MAXPATH\tab
\tab
\par
\pard\s32\plain\f1\fs20\sb60\fi-2880\li2880 MAXFILENAME\tab
\pard\s32\plain\f1\fs20\sb60\fi-2880\li2880 \par
\pard\s34\plain\li0\sb90\f1\fs20\b Error Codes \par
\pard\s32\plain\f1\fs20\sb60\fi-2880\li2880 \pard\s32\plain\f1\fs20\sb60\fi-2880\li2880 
NOERROR\tab
\tab
\pard\s32\plain\f1\fs20\sb60\fi-2880\li2880 the operation was successfull              
\par
\pard\s32\plain\f1\fs20\sb60\fi-2880\li2880 WRITEPROTECTED\tab
\pard\s32\plain\f1\fs20\sb60\fi-2880\li2880 attempted write to a write-protected drive 
\par
\pard\s32\plain\f1\fs20\sb60\fi-2880\li2880 PATHNOTFOUND\tab
\pard\s32\plain\f1\fs20\sb60\fi-2880\li2880 the stated path could not be found         
\par
\pard\s32\plain\f1\fs20\sb60\fi-2880\li2880 INVALIDDRIVE\tab
\pard\s32\plain\f1\fs20\sb60\fi-2880\li2880 the indicated drive could not be found     
\par
\pard\s32\plain\f1\fs20\sb60\fi-2880\li2880 NOMOREFILES\tab
\pard\s32\plain\f1\fs20\sb60\fi-2880\li2880 no further suitable files could be found
 \par
\pard\s34\plain\li0\sb90\f1\fs20\b File Attributes \par
\pard\s32\plain\f1\fs20\sb60\fi-2880\li2880 \pard\s32\plain\f1\fs20\sb60\fi-2880\li2880 
ATTRREADONLY\tab
\pard\s32\plain\f1\fs20\sb60\fi-2880\li2880 the file is read-only                     
\par
\pard\s32\plain\f1\fs20\sb60\fi-2880\li2880 ATTRHIDDEN\tab
\tab
\pard\s32\plain\f1\fs20\sb60\fi-2880\li2880 the file is hidden                        
\par
\pard\s32\plain\f1\fs20\sb60\fi-2880\li2880 ATTRSYSTEM\tab
\tab
\pard\s32\plain\f1\fs20\sb60\fi-2880\li2880 the file is part of the operating system  
\par
\pard\s32\plain\f1\fs20\sb60\fi-2880\li2880 ATTRVOLUME\tab
\tab
\pard\s32\plain\f1\fs20\sb60\fi-2880\li2880 maintained for compatibility only         
\par
\pard\s32\plain\f1\fs20\sb60\fi-2880\li2880 ATTRDIR\tab
\tab
\tab
\pard\s32\plain\f1\fs20\sb60\fi-2880\li2880 file entry is really a directory          
\par
\pard\s32\plain\f1\fs20\sb60\fi-2880\li2880 ATTRARCHIVE\tab
\pard\s32\plain\f1\fs20\sb60\fi-2880\li2880 file marked for backup                    
\par
\pard\s32\plain\f1\fs20\sb60\fi-2880\li2880 ATTRNORMAL\tab
\tab
\pard\s32\plain\f1\fs20\sb60\fi-2880\li2880 a plain file with no other attributes set 
\par
\pard\s32\plain\f1\fs20\sb60\fi-2880\li2880 ATTRTEMP\tab
\tab
\pard\s32\plain\f1\fs20\sb60\fi-2880\li2880 the file is used for temporary storage    
\par
\pard\s32\plain\f1\fs20\sb60\fi-2880\li2880 ATTRCOMPRESSED\tab
\pard\s32\plain\f1\fs20\sb60\fi-2880\li2880 the file or directory is compressed       
\par
\pard\s32\plain\f1\fs20\sb60\fi-2880\li2880 ATTROFFLINE\tab
\pard\s32\plain\f1\fs20\sb60\fi-2880\li2880 file currently physically unavailable     
\par
\pard\s29\plain\li0\sb180\f1\fs24\b Types\par
\pard\s30\plain\li0\sb60\f1\fs20 {\ul\cf5 ScanP}{\v Volume_ScanP}\par
{\ul\cf5 RetCodeT}{\v Volume_RetCodeT}\par
\pard\s29\plain\li0\sb180\f1\fs24\b Classes / Record Types\par
\pard\s30\plain\li0\sb60\f1\fs20 {\strike\cf5 Scan}{\v Volume_Scan}\par
\pard\s29\plain\li0\sb180\f1\fs24\b Procedures\par
\pard\s30\plain\li0\sb60\f1\fs20 {\strike\cf5 GetErrorMessage}{\v Volume_GetErrorMessage
}\par
{\strike\cf5 CurrentDirectory}{\v Volume_CurrentDirectory}\par
{\strike\cf5 ChangeDirectory}{\v Volume_ChangeDirectory}\par
{\strike\cf5 CreateDirectory}{\v Volume_CreateDirectory}\par
{\strike\cf5 RemoveDirectory}{\v Volume_RemoveDirectory}\par
{\strike\cf5 FreeSpace}{\v Volume_FreeSpace}\par
{\strike\cf5 TotalSpace}{\v Volume_TotalSpace}\par
\page
{\ {\super #}\footnote \pard\plain{\super #}Volume_GetErrorMessage}{\ {\super $}\footnote \pard\plain{\super 
$}Volume.GetErrorMessage}{\ {\super K}\footnote \pard\plain{\super K}GetErrorMessage
}\pard\s28\plain\li0\sb120\sa120\keepn\f1\fs28\b GetErrorMessage\par
\pard\s31\plain\li0\sb120\sa120\f1\fs20\b defined in module {\strike\cf5 Volume}{\v 
Volume}\par
\pard\s29\plain\li0\sb180\f1\fs24\b Syntax\par
\pard\s27\plain\li0\sb120\tx1702\f2\fs20 PROCEDURE GetErrorMessage(error:{\ul\cf5 
RetCodeT}{\v Volume_RetCodeT}; \line
                          VAR message:ARRAY OF CHAR)\par
\pard\s29\plain\li0\sb180\f1\fs24\b Description\par
\pard\s30\plain\li0\sb60\f1\fs20 The text returned in {\b message} describes the error code error.
 All return values for all functions in this module may be passed as an error code. Under certain circumstances an error code might
 be reported which is different from all predefined constants. Even in this case GetErrorMessage will provide an appropriate text.
\par
Identical constants for error codes defined in the module Volume have the same numerical value as their counterparts in the module File. 
\par
\page
{\ {\super #}\footnote \pard\plain{\super #}Volume_CurrentDirectory}{\ {\super $}\footnote \pard\plain{\super 
$}Volume.CurrentDirectory}{\ {\super K}\footnote \pard\plain{\super K}CurrentDirectory
}\pard\s28\plain\li0\sb120\sa120\keepn\f1\fs28\b CurrentDirectory\par
\pard\s31\plain\li0\sb120\sa120\f1\fs20\b defined in module {\strike\cf5 Volume}{\v 
Volume}\par
\pard\s29\plain\li0\sb180\f1\fs24\b Syntax\par
\pard\s27\plain\li0\sb120\tx1702\f2\fs20 PROCEDURE CurrentDirectory(VAR dir:ARRAY 
OF CHAR; \line
                           VAR resCode:{\ul\cf5 RetCodeT}{\v Volume_RetCodeT})\par

\pard\s29\plain\li0\sb180\f1\fs24\b Description\par
\pard\s30\plain\li0\sb60\f1\fs20 The current directory of the current drive is returned in 
{\b dir}. The path stated in {\b dir} always contains a drive identification.\par

The interface has changed from OPAL 16 bit: the drive is no longer a parameter of this function. 
\par
\page
{\ {\super #}\footnote \pard\plain{\super #}Volume_ChangeDirectory}{\ {\super $}\footnote \pard\plain{\super 
$}Volume.ChangeDirectory}{\ {\super K}\footnote \pard\plain{\super K}ChangeDirectory
}\pard\s28\plain\li0\sb120\sa120\keepn\f1\fs28\b ChangeDirectory\par
\pard\s31\plain\li0\sb120\sa120\f1\fs20\b defined in module {\strike\cf5 Volume}{\v 
Volume}\par
\pard\s29\plain\li0\sb180\f1\fs24\b Syntax\par
\pard\s27\plain\li0\sb120\tx1702\f2\fs20 PROCEDURE ChangeDirectory(dir:ARRAY OF CHAR
; \line
                          VAR resCode:{\ul\cf5 RetCodeT}{\v Volume_RetCodeT})\par

\pard\s29\plain\li0\sb180\f1\fs24\b Description\par
\pard\s30\plain\li0\sb60\f1\fs20 The current directory is changed to the one stated in 
{\b dir}. If the path in {\b dir} contains a drive identification, the current directory of this
 drive is selected, otherwise the directory of the current drive if it exists. The current drive remains unchanged.
\par
The parameter {\b resCode} returns an error code. \par
\page
{\ {\super #}\footnote \pard\plain{\super #}Volume_CreateDirectory}{\ {\super $}\footnote \pard\plain{\super 
$}Volume.CreateDirectory}{\ {\super K}\footnote \pard\plain{\super K}CreateDirectory
}\pard\s28\plain\li0\sb120\sa120\keepn\f1\fs28\b CreateDirectory\par
\pard\s31\plain\li0\sb120\sa120\f1\fs20\b defined in module {\strike\cf5 Volume}{\v 
Volume}\par
\pard\s29\plain\li0\sb180\f1\fs24\b Syntax\par
\pard\s27\plain\li0\sb120\tx1702\f2\fs20 PROCEDURE CreateDirectory(dir:ARRAY OF CHAR
; \line
                          VAR resCode:{\ul\cf5 RetCodeT}{\v Volume_RetCodeT})\par

\pard\s29\plain\li0\sb180\f1\fs24\b Description\par
\pard\s30\plain\li0\sb60\f1\fs20 The directory specified by {\b dir} is created. Only one directory and not
 a whole path can be created per call.\par
The parameter {\b resCode} returns an error code. \par
\page
{\ {\super #}\footnote \pard\plain{\super #}Volume_RemoveDirectory}{\ {\super $}\footnote \pard\plain{\super 
$}Volume.RemoveDirectory}{\ {\super K}\footnote \pard\plain{\super K}RemoveDirectory
}\pard\s28\plain\li0\sb120\sa120\keepn\f1\fs28\b RemoveDirectory\par
\pard\s31\plain\li0\sb120\sa120\f1\fs20\b defined in module {\strike\cf5 Volume}{\v 
Volume}\par
\pard\s29\plain\li0\sb180\f1\fs24\b Syntax\par
\pard\s27\plain\li0\sb120\tx1702\f2\fs20 PROCEDURE RemoveDirectory(dir:ARRAY OF CHAR
; \line
                          VAR resCode:{\ul\cf5 RetCodeT}{\v Volume_RetCodeT})\par

\pard\s29\plain\li0\sb180\f1\fs24\b Description\par
\pard\s30\plain\li0\sb60\f1\fs20 The directory stated in {\b dir} is removed.\par

The parameter {\b resCode} returns an error code. \par
\page
{\ {\super #}\footnote \pard\plain{\super #}Volume_FreeSpace}{\ {\super $}\footnote \pard\plain{\super 
$}Volume.FreeSpace}{\ {\super K}\footnote \pard\plain{\super K}FreeSpace}\pard\s28
\plain\li0\sb120\sa120\keepn\f1\fs28\b FreeSpace\par
\pard\s31\plain\li0\sb120\sa120\f1\fs20\b defined in module {\strike\cf5 Volume}{\v 
Volume}\par
\pard\s29\plain\li0\sb180\f1\fs24\b Syntax\par
\pard\s27\plain\li0\sb120\tx1702\f2\fs20 PROCEDURE FreeSpace(drive:ARRAY OF CHAR; 
\line
                    VAR space:LONGINT; \line
                    VAR unit:LONGINT; \line
                    VAR resCode:{\ul\cf5 RetCodeT}{\v Volume_RetCodeT})\par
\pard\s29\plain\li0\sb180\f1\fs24\b Parameters\par
\pard\s32\plain\f1\fs20\sb60\fi-2880\li2880 unit\tab
\tab
\tab
\tab
\pard\s32\plain\f1\fs20\sb60\fi-2880\li2880 {\b unit} determins the unit used for the number returned in 
{\b space}. The returned value is either 1 for 1 byte or 1024 for kBytes. The smallest possible unit is used which still allows
 {\b space} to be expressed as a LONGINT. \par
\pard\s29\plain\li0\sb180\f1\fs24\b Description\par
\pard\s30\plain\li0\sb60\f1\fs20 The available space on the drive specified by {\b 
drive} is returned in {\b space}. The free space in bytes is {\b space} * {\b unit
}.\par
The parameter {\b resCode} returns an error code. \par
\page
{\ {\super #}\footnote \pard\plain{\super #}Volume_TotalSpace}{\ {\super $}\footnote \pard\plain{\super 
$}Volume.TotalSpace}{\ {\super K}\footnote \pard\plain{\super K}TotalSpace}\pard\s28
\plain\li0\sb120\sa120\keepn\f1\fs28\b TotalSpace\par
\pard\s31\plain\li0\sb120\sa120\f1\fs20\b defined in module {\strike\cf5 Volume}{\v 
Volume}\par
\pard\s29\plain\li0\sb180\f1\fs24\b Syntax\par
\pard\s27\plain\li0\sb120\tx1702\f2\fs20 PROCEDURE TotalSpace(drive:ARRAY OF CHAR
; \line
                     VAR space:LONGINT; \line
                     VAR unit:LONGINT; \line
                     VAR resCode:{\ul\cf5 RetCodeT}{\v Volume_RetCodeT})\par
\pard\s29\plain\li0\sb180\f1\fs24\b Parameters\par
\pard\s32\plain\f1\fs20\sb60\fi-2880\li2880 unit\tab
\tab
\tab
\tab
\pard\s32\plain\f1\fs20\sb60\fi-2880\li2880 {\b unit} determins the unit used for the number returned in 
{\b space}. The returned value is either 1 for 1 byte or 1024 for kBytes. The smallest possible unit is used which still allows
 {\b space} to be expressed as a LONGINT. \par
\pard\s29\plain\li0\sb180\f1\fs24\b Description\par
\pard\s30\plain\li0\sb60\f1\fs20 The full drive capacity of {\b drive} in bytes is returned in 
{\b space}. The full space in bytes is {\b space} * {\b unit}.\par
The parameter resCode returns an error code. \par
\page
{\ {\super #}\footnote \pard\plain{\super #}Volume_ScanP}{\ {\super $}\footnote \pard\plain{\super 
$}Volume.ScanP}{\ {\super K}\footnote \pard\plain{\super K}ScanP}\pard\s30\plain\li0\sb60\f1\fs20 
{\b ScanP}\par
\pard\s27\plain\li0\sb120\tx1702\f2\fs20 ScanP*=POINTER TO {\strike\cf5 Scan}{\v 
Volume_Scan};\par
\page
{\ {\super #}\footnote \pard\plain{\super #}Volume_RetCodeT}{\ {\super $}\footnote \pard\plain{\super 
$}Volume.RetCodeT}{\ {\super K}\footnote \pard\plain{\super K}RetCodeT}\pard\s30\plain\li0\sb60\f1\fs20 
{\b RetCodeT}\par
\pard\s27\plain\li0\sb120\tx1702\f2\fs20 RetCodeT*=INTEGER;\par
\page
{\ {\super #}\footnote \pard\plain{\super #}Volume_Scan}{\ {\super $}\footnote \pard\plain{\super 
$}Volume.Scan}{\ {\super K}\footnote \pard\plain{\super K}Scan}\pard\s28\plain\li0\sb120\sa120\keepn\f1\fs28\b 
Scan\par
\pard\s31\plain\li0\sb120\sa120\f1\fs20\b defined in module {\strike\cf5 Volume}{\v 
Volume}\par
\pard\s29\plain\li0\sb180\f1\fs24\b Syntax\par
\pard\s27\plain\li0\sb120\tx1702\f2\fs20 Scan=RECORD \line
END;\par
\pard\s29\plain\li0\sb180\f1\fs24\b Methods\par
\pard\s30\plain\li0\sb60\f1\fs20 {\strike\cf5 First}{\v Volume_Scan_First}\par
{\strike\cf5 Next}{\v Volume_Scan_Next}\par
{\strike\cf5 GetName}{\v Volume_Scan_GetName}\par
{\strike\cf5 GetCreationDate}{\v Volume_Scan_GetCreationDate}\par
{\strike\cf5 GetModifyDate}{\v Volume_Scan_GetModifyDate}\par
{\strike\cf5 GetAccessDate}{\v Volume_Scan_GetAccessDate}\par
{\strike\cf5 GetAttr}{\v Volume_Scan_GetAttr}\par
{\strike\cf5 GetSize}{\v Volume_Scan_GetSize}\par
\page
{\ {\super #}\footnote \pard\plain{\super #}Volume_Scan_First}{\ {\super $}\footnote \pard\plain{\super 
$}Volume.Scan.First}{\ {\super K}\footnote \pard\plain{\super K}First}\pard\s28\plain\li0\sb120\sa120\keepn\f1\fs28\b 
First\par
\pard\s31\plain\li0\sb120\sa120\f1\fs20\b defined in module {\strike\cf5 Volume}{\v 
Volume}, bound to type {\strike\cf5 Scan}{\v Volume_Scan}\par
\pard\s29\plain\li0\sb180\f1\fs24\b Syntax\par
\pard\s27\plain\li0\sb120\tx1702\f2\fs20 PROCEDURE (VAR) First(searchName:ARRAY OF 
CHAR; \line
                      VAR resCode:{\ul\cf5 RetCodeT}{\v Volume_RetCodeT})\par
\pard\s29\plain\li0\sb180\f1\fs24\b Description\par
\pard\s30\plain\li0\sb60\f1\fs20 The first directory entry that matches the stated searching pattern given in
 {\b searchName} is searched. This method must be called before any other method.
 In {\b searchName} any path may be stated; wildcards like "*" and "?" are permitted
 in the file name.\par
"*" stands for any number and combination of characters and "?" for precisely one character.
\par
Example for {\b searchName}: "C:\\WIN98\\*.DLL" starts a search for all files with the extension "DLL"
 in the directory "C:\\WIN98".\par
If the value NOERROR was returned in {\b resCode} the search was successful and the name and other characteristics of the matching directory entry may
 then be obtained using the other methods of the scan object. \par
\page
{\ {\super #}\footnote \pard\plain{\super #}Volume_Scan_Next}{\ {\super $}\footnote \pard\plain{\super 
$}Volume.Scan.Next}{\ {\super K}\footnote \pard\plain{\super K}Next}\pard\s28\plain\li0\sb120\sa120\keepn\f1\fs28\b 
Next\par
\pard\s31\plain\li0\sb120\sa120\f1\fs20\b defined in module {\strike\cf5 Volume}{\v 
Volume}, bound to type {\strike\cf5 Scan}{\v Volume_Scan}\par
\pard\s29\plain\li0\sb180\f1\fs24\b Syntax\par
\pard\s27\plain\li0\sb120\tx1702\f2\fs20 PROCEDURE (VAR) Next(VAR resCode:{\ul\cf5 
RetCodeT}{\v Volume_RetCodeT})\par
\pard\s29\plain\li0\sb180\f1\fs24\b Description\par
\pard\s30\plain\li0\sb60\f1\fs20 On each call of this method the next matching directory entry is searched
 for until no more entries are available. If the value NOERROR is returned in {\b 
resCode} the search was successful and the name and other characteristics of the found entry may be obtained using the corresponding methods. If an
 error occurs then the methods GetName, GetSize, GetAttr, GetCreationDate, and GetModifyDate must not be called. 
\par
\page
{\ {\super #}\footnote \pard\plain{\super #}Volume_Scan_GetName}{\ {\super $}\footnote \pard\plain{\super 
$}Volume.Scan.GetName}{\ {\super K}\footnote \pard\plain{\super K}GetName}\pard\s28
\plain\li0\sb120\sa120\keepn\f1\fs28\b GetName\par
\pard\s31\plain\li0\sb120\sa120\f1\fs20\b defined in module {\strike\cf5 Volume}{\v 
Volume}, bound to type {\strike\cf5 Scan}{\v Volume_Scan}\par
\pard\s29\plain\li0\sb180\f1\fs24\b Syntax\par
\pard\s27\plain\li0\sb120\tx1702\f2\fs20 PROCEDURE (VAR) GetName(VAR fileName:ARRAY 
OF CHAR)\par
\pard\s29\plain\li0\sb180\f1\fs24\b Description\par
\pard\s30\plain\li0\sb60\f1\fs20 The name of the last matching entry is returned in 
{\b fileName}. If the size of {\b fileName} is not sufficient to hold the result an empty string
 is returned. The array for the parameter {\b fileName} should be sized using the constant MAXFILENAME. 
\par
\page
{\ {\super #}\footnote \pard\plain{\super #}Volume_Scan_GetCreationDate}{\ {\super 
$}\footnote \pard\plain{\super $}Volume.Scan.GetCreationDate}{\ {\super K}\footnote \pard\plain{\super 
K}GetCreationDate}\pard\s28\plain\li0\sb120\sa120\keepn\f1\fs28\b GetCreationDate
\par
\pard\s31\plain\li0\sb120\sa120\f1\fs20\b defined in module {\strike\cf5 Volume}{\v 
Volume}, bound to type {\strike\cf5 Scan}{\v Volume_Scan}\par
\pard\s29\plain\li0\sb180\f1\fs24\b Syntax\par
\pard\s27\plain\li0\sb120\tx1702\f2\fs20 PROCEDURE (VAR) GetCreationDate(VAR dateStr
:ARRAY OF CHAR)\par
\pard\s29\plain\li0\sb180\f1\fs24\b Description\par
\pard\s30\plain\li0\sb60\f1\fs20 The creation date of the found file is returned in 
{\b dateStr}. If the underlying file system does not supply this information an empty string is returned. 
\par
\page
{\ {\super #}\footnote \pard\plain{\super #}Volume_Scan_GetModifyDate}{\ {\super 
$}\footnote \pard\plain{\super $}Volume.Scan.GetModifyDate}{\ {\super K}\footnote \pard\plain{\super 
K}GetModifyDate}\pard\s28\plain\li0\sb120\sa120\keepn\f1\fs28\b GetModifyDate\par

\pard\s31\plain\li0\sb120\sa120\f1\fs20\b defined in module {\strike\cf5 Volume}{\v 
Volume}, bound to type {\strike\cf5 Scan}{\v Volume_Scan}\par
\pard\s29\plain\li0\sb180\f1\fs24\b Syntax\par
\pard\s27\plain\li0\sb120\tx1702\f2\fs20 PROCEDURE (VAR) GetModifyDate(VAR dateStr
:ARRAY OF CHAR)\par
\pard\s29\plain\li0\sb180\f1\fs24\b Description\par
\pard\s30\plain\li0\sb60\f1\fs20 The date of the last modification of the found file is returned in 
{\b dateStr}. The format of the date is "DD.MM.YYYY  HH:MM:SS" with two separating blanks.
 The total length of the string is 20 characters. If {\b dateStr} cannot hold a string
 of length 20 the result is truncated. \par
\page
{\ {\super #}\footnote \pard\plain{\super #}Volume_Scan_GetAccessDate}{\ {\super 
$}\footnote \pard\plain{\super $}Volume.Scan.GetAccessDate}{\ {\super K}\footnote \pard\plain{\super 
K}GetAccessDate}\pard\s28\plain\li0\sb120\sa120\keepn\f1\fs28\b GetAccessDate\par

\pard\s31\plain\li0\sb120\sa120\f1\fs20\b defined in module {\strike\cf5 Volume}{\v 
Volume}, bound to type {\strike\cf5 Scan}{\v Volume_Scan}\par
\pard\s29\plain\li0\sb180\f1\fs24\b Syntax\par
\pard\s27\plain\li0\sb120\tx1702\f2\fs20 PROCEDURE (VAR) GetAccessDate(VAR dateStr
:ARRAY OF CHAR)\par
\pard\s29\plain\li0\sb180\f1\fs24\b Description\par
\pard\s30\plain\li0\sb60\f1\fs20 The date at which the found file has been accessed the last time is
 returned in {\b dateStr}. If the underlying file system does not supply this information an empty string is returned. 
\par
\page
{\ {\super #}\footnote \pard\plain{\super #}Volume_Scan_GetAttr}{\ {\super $}\footnote \pard\plain{\super 
$}Volume.Scan.GetAttr}{\ {\super K}\footnote \pard\plain{\super K}GetAttr}\pard\s28
\plain\li0\sb120\sa120\keepn\f1\fs28\b GetAttr\par
\pard\s31\plain\li0\sb120\sa120\f1\fs20\b defined in module {\strike\cf5 Volume}{\v 
Volume}, bound to type {\strike\cf5 Scan}{\v Volume_Scan}\par
\pard\s29\plain\li0\sb180\f1\fs24\b Syntax\par
\pard\s27\plain\li0\sb120\tx1702\f2\fs20 PROCEDURE (VAR) GetAttr():SET\par
\pard\s29\plain\li0\sb180\f1\fs24\b Description\par
\pard\s30\plain\li0\sb60\f1\fs20 The return value of the function is a set containing the attributes of the
 last detected directory entry. The ATTR* constants should be used to evaluate the contents of the returned set. 
\par
\page
{\ {\super #}\footnote \pard\plain{\super #}Volume_Scan_GetSize}{\ {\super $}\footnote \pard\plain{\super 
$}Volume.Scan.GetSize}{\ {\super K}\footnote \pard\plain{\super K}GetSize}\pard\s28
\plain\li0\sb120\sa120\keepn\f1\fs28\b GetSize\par
\pard\s31\plain\li0\sb120\sa120\f1\fs20\b defined in module {\strike\cf5 Volume}{\v 
Volume}, bound to type {\strike\cf5 Scan}{\v Volume_Scan}\par
\pard\s29\plain\li0\sb180\f1\fs24\b Syntax\par
\pard\s27\plain\li0\sb120\tx1702\f2\fs20 PROCEDURE (VAR) GetSize():LONGINT\par
\pard\s29\plain\li0\sb180\f1\fs24\b Description\par
\pard\s30\plain\li0\sb60\f1\fs20 The return value of the function is the size of the last detected file. 
\par
\page
{\ {\super #}\footnote \pard\plain{\super #}XYplane}{\ {\super $}\footnote \pard\plain{\super 
$}module XYplane}{\ {\super K}\footnote \pard\plain{\super K}XYplane}\pard\s28\plain\li0\sb120\sa120\keepn\f1\fs28\b 
Module XYplane\par
\pard\s30\plain\li0\sb60\f1\fs20 This module supports very simple monochrome graphics.
\par
The interface of this module is call-compatible to the standard for the simple graphics module defined in the Oakwood Guidelines.
\par
The drawing area uses a Cartesian system of co-ordinates with the (0,0) origin in the bottom left hand corner. Dots can be drawn in either a
 foreground or background color.\par
\pard\s29\plain\li0\sb180\f1\fs24\b Constants\par
\pard\s32\plain\f1\fs20\sb60\fi-2880\li2880 draw\tab
\tab
\tab
\tab
\pard\s32\plain\f1\fs20\sb60\fi-2880\li2880 Used for the parameter mode when the foreground color should be used 
\par
\pard\s32\plain\f1\fs20\sb60\fi-2880\li2880 erase\tab
\tab
\tab
\pard\s32\plain\f1\fs20\sb60\fi-2880\li2880 Used for the parameter mode when the background color should be used 
\par
\pard\s29\plain\li0\sb180\f1\fs24\b Variables\par
\pard\s30\plain\li0\sb60\f1\fs20 {\ul\cf5 W}{\v XYplane_W}\par
\pard\s30\plain\li0\sb60\f1\fs20 {\ul\cf5 H}{\v XYplane_H}\par
\pard\s30\plain\li0\sb60\f1\fs20 {\ul\cf5 X}{\v XYplane_X}\par
\pard\s30\plain\li0\sb60\f1\fs20 {\ul\cf5 Y}{\v XYplane_Y}\par
\pard\s29\plain\li0\sb180\f1\fs24\b Procedures\par
\pard\s30\plain\li0\sb60\f1\fs20 {\strike\cf5 Open}{\v XYplane_Open}\par
{\strike\cf5 Close}{\v XYplane_Close}\par
{\strike\cf5 Dot}{\v XYplane_Dot}\par
{\strike\cf5 IsDot}{\v XYplane_IsDot}\par
{\strike\cf5 Key}{\v XYplane_Key}\par
{\strike\cf5 Clear}{\v XYplane_Clear}\par
\page
{\ {\super #}\footnote \pard\plain{\super #}XYplane_Open}{\ {\super $}\footnote \pard\plain{\super 
$}XYplane.Open}{\ {\super K}\footnote \pard\plain{\super K}Open}\pard\s28\plain\li0\sb120\sa120\keepn\f1\fs28\b 
Open\par
\pard\s31\plain\li0\sb120\sa120\f1\fs20\b defined in module {\strike\cf5 XYplane}{\v 
XYplane}\par
\pard\s29\plain\li0\sb180\f1\fs24\b Syntax\par
\pard\s27\plain\li0\sb120\tx1702\f2\fs20 PROCEDURE Open()\par
\pard\s29\plain\li0\sb180\f1\fs24\b Description\par
\pard\s30\plain\li0\sb60\f1\fs20 The module is initialized and the drawing area is created on the screen.
 Open must be called before any other procedure of the module is called. \par
\page
{\ {\super #}\footnote \pard\plain{\super #}XYplane_Close}{\ {\super $}\footnote \pard\plain{\super 
$}XYplane.Close}{\ {\super K}\footnote \pard\plain{\super K}Close}\pard\s28\plain\li0\sb120\sa120\keepn\f1\fs28\b 
Close\par
\pard\s31\plain\li0\sb120\sa120\f1\fs20\b defined in module {\strike\cf5 XYplane}{\v 
XYplane}\par
\pard\s29\plain\li0\sb180\f1\fs24\b Syntax\par
\pard\s27\plain\li0\sb120\tx1702\f2\fs20 PROCEDURE Close()\par
\pard\s29\plain\li0\sb180\f1\fs24\b Description\par
\pard\s30\plain\li0\sb60\f1\fs20 The drawing area is closed and the space released on the screen is used
 for the output of other modules (Display, Out, ColorPlane).\par
This procedure is not defined in the Oakwood Guidelines. \par
\page
{\ {\super #}\footnote \pard\plain{\super #}XYplane_Dot}{\ {\super $}\footnote \pard\plain{\super 
$}XYplane.Dot}{\ {\super K}\footnote \pard\plain{\super K}Dot}\pard\s28\plain\li0\sb120\sa120\keepn\f1\fs28\b 
Dot\par
\pard\s31\plain\li0\sb120\sa120\f1\fs20\b defined in module {\strike\cf5 XYplane}{\v 
XYplane}\par
\pard\s29\plain\li0\sb180\f1\fs24\b Syntax\par
\pard\s27\plain\li0\sb120\tx1702\f2\fs20 PROCEDURE Dot(x, y, mode:INTEGER)\par
\pard\s29\plain\li0\sb180\f1\fs24\b Description\par
\pard\s30\plain\li0\sb60\f1\fs20 A dot is drawn at the co-ordinates ({\b x},{\b y
}) if {\b mode} has the value {\b draw} or erased if mode has the value {\b erase
}. \par
\page
{\ {\super #}\footnote \pard\plain{\super #}XYplane_IsDot}{\ {\super $}\footnote \pard\plain{\super 
$}XYplane.IsDot}{\ {\super K}\footnote \pard\plain{\super K}IsDot}\pard\s28\plain\li0\sb120\sa120\keepn\f1\fs28\b 
IsDot\par
\pard\s31\plain\li0\sb120\sa120\f1\fs20\b defined in module {\strike\cf5 XYplane}{\v 
XYplane}\par
\pard\s29\plain\li0\sb180\f1\fs24\b Syntax\par
\pard\s27\plain\li0\sb120\tx1702\f2\fs20 PROCEDURE IsDot(x, y:INTEGER):BOOLEAN\par

\pard\s29\plain\li0\sb180\f1\fs24\b Description\par
\pard\s30\plain\li0\sb60\f1\fs20 The return value of the function is TRUE if the dot with the co-ordinate
 ({\b x},{\b y}) is set. \par
\page
{\ {\super #}\footnote \pard\plain{\super #}XYplane_Key}{\ {\super $}\footnote \pard\plain{\super 
$}XYplane.Key}{\ {\super K}\footnote \pard\plain{\super K}Key}\pard\s28\plain\li0\sb120\sa120\keepn\f1\fs28\b 
Key\par
\pard\s31\plain\li0\sb120\sa120\f1\fs20\b defined in module {\strike\cf5 XYplane}{\v 
XYplane}\par
\pard\s29\plain\li0\sb180\f1\fs24\b Syntax\par
\pard\s27\plain\li0\sb120\tx1702\f2\fs20 PROCEDURE Key():CHAR\par
\pard\s29\plain\li0\sb180\f1\fs24\b Description\par
\pard\s30\plain\li0\sb60\f1\fs20 The return value of the function is 0X, if no key was pressed, otherwise
 it is the key code. Keys that are not assigned an ASCII code are ignored. \par
\page
{\ {\super #}\footnote \pard\plain{\super #}XYplane_Clear}{\ {\super $}\footnote \pard\plain{\super 
$}XYplane.Clear}{\ {\super K}\footnote \pard\plain{\super K}Clear}\pard\s28\plain\li0\sb120\sa120\keepn\f1\fs28\b 
Clear\par
\pard\s31\plain\li0\sb120\sa120\f1\fs20\b defined in module {\strike\cf5 XYplane}{\v 
XYplane}\par
\pard\s29\plain\li0\sb180\f1\fs24\b Syntax\par
\pard\s27\plain\li0\sb120\tx1702\f2\fs20 PROCEDURE Clear()\par
\pard\s29\plain\li0\sb180\f1\fs24\b Description\par
\pard\s30\plain\li0\sb60\f1\fs20 The drawing area is cleared to the background color. 
\par
\page
{\ {\super #}\footnote \pard\plain{\super #}XYplane_W}{\ {\super $}\footnote \pard\plain{\super 
$}XYplane.W}{\ {\super K}\footnote \pard\plain{\super K}W}\pard\s30\plain\li0\sb60\f1\fs20 
{\b W}\par
\pard\s27\plain\li0\sb120\tx1702\f2\fs20 W-:INTEGER;\par
\pard\s30\plain\li0\sb60\f1\fs20 This write-protected variable contains the width (W) of the drawing area. 
\par
\page
{\ {\super #}\footnote \pard\plain{\super #}XYplane_H}{\ {\super $}\footnote \pard\plain{\super 
$}XYplane.H}{\ {\super K}\footnote \pard\plain{\super K}H}\pard\s30\plain\li0\sb60\f1\fs20 
{\b H}\par
\pard\s27\plain\li0\sb120\tx1702\f2\fs20 H-:INTEGER;\par
\pard\s30\plain\li0\sb60\f1\fs20 This write-protected variable contains the height (H) of the drawing area. 
\par
\page
{\ {\super #}\footnote \pard\plain{\super #}XYplane_X}{\ {\super $}\footnote \pard\plain{\super 
$}XYplane.X}{\ {\super K}\footnote \pard\plain{\super K}X}\pard\s30\plain\li0\sb60\f1\fs20 
{\b X}\par
\pard\s27\plain\li0\sb120\tx1702\f2\fs20 X-:INTEGER;\par
\pard\s30\plain\li0\sb60\f1\fs20 This write-protected variables contains the horizontal component of the
 the position of the bottom left corner of the drawing area. In some implementations
 of this module the drawing area does not create its own local system of co-ordinates. If this is the case then all drawing
 operations must compensate (x,y) values with the required offsets.\par
In the Windows implementation the drawing area creates its own system of co-ordinates with an origin at (0,0). 
\par
\page
{\ {\super #}\footnote \pard\plain{\super #}XYplane_Y}{\ {\super $}\footnote \pard\plain{\super 
$}XYplane.Y}{\ {\super K}\footnote \pard\plain{\super K}Y}\pard\s30\plain\li0\sb60\f1\fs20 
{\b Y}\par
\pard\s27\plain\li0\sb120\tx1702\f2\fs20 Y-:INTEGER;\par
\pard\s30\plain\li0\sb60\f1\fs20 This write-protected variables contains the vertical component of the
 the position of the bottom left corner of the drawing area. In some implementations
 of this module the drawing area does not create its own local system of co-ordinates. If this is the case then all drawing
 operations must compensate (x,y) values with the required offsets.\par
In the Windows implementation the drawing area creates its own system of co-ordinates with an origin at (0,0). 
\par
\page
{\ {\super #}\footnote \pard\plain{\super #}ColorPlane}{\ {\super $}\footnote \pard\plain{\super 
$}module ColorPlane}{\ {\super K}\footnote \pard\plain{\super K}ColorPlane}\pard\s28
\plain\li0\sb120\sa120\keepn\f1\fs28\b Module ColorPlane\par
\pard\s30\plain\li0\sb60\f1\fs20 This module provides easy to use simple color graphics.
\par
All output operations represent their output in a drawing region with fixed resolution. This implementation provides an area of 800 x 650 pixel (horizontal
 by vertical).\par
The left bottom corner of the output area has the co-ordinate (0,0), the same as for the Cartesian system of co-ordinates.
\par
The definition of colors is based upon a true-color model which defines the colors by their relative concentrations of red, green and blue. As not
 every system supports a true-color display the desired colors are mapped to the nearest available colors.
\par
A cursor is used to indicate the position for input and output of text. It can be positioned by calling the relevant procedures and appears as a
 flashing mark on the screen.\par
\pard\s29\plain\li0\sb180\f1\fs24\b Constants\par
\pard\s32\plain\f1\fs20\sb60\fi-2880\li2880 draw\tab
\tab
\tab
\tab
\pard\s32\plain\f1\fs20\sb60\fi-2880\li2880 \par
\pard\s32\plain\f1\fs20\sb60\fi-2880\li2880 erase\tab
\tab
\tab
\pard\s32\plain\f1\fs20\sb60\fi-2880\li2880 \par
\pard\s32\plain\f1\fs20\sb60\fi-2880\li2880 DRAW\tab
\tab
\tab
\pard\s32\plain\f1\fs20\sb60\fi-2880\li2880 required with the parameter {\b mode}
 to draw with the foreground color \par
\pard\s32\plain\f1\fs20\sb60\fi-2880\li2880 ERASE\tab
\tab
\tab
\pard\s32\plain\f1\fs20\sb60\fi-2880\li2880 required with the parameter {\b mode}
 to draw with the background color \par
\pard\s32\plain\f1\fs20\sb60\fi-2880\li2880 RESOLUTIONX\tab
\pard\s32\plain\f1\fs20\sb60\fi-2880\li2880 horizontal resolution of the drawing area 
\par
\pard\s32\plain\f1\fs20\sb60\fi-2880\li2880 RESOLUTIONY\tab
\pard\s32\plain\f1\fs20\sb60\fi-2880\li2880 vertical resolution of the drawing area 
\par
\pard\s32\plain\f1\fs20\sb60\fi-2880\li2880 BACKSPACE\tab
\tab
\par
\pard\s32\plain\f1\fs20\sb60\fi-2880\li2880 CURSDOWN\tab
\tab
\par
\pard\s32\plain\f1\fs20\sb60\fi-2880\li2880 CURSLEFT\tab
\tab
\par
\pard\s32\plain\f1\fs20\sb60\fi-2880\li2880 CURSRIGHT\tab
\tab
\par
\pard\s32\plain\f1\fs20\sb60\fi-2880\li2880 CURSUP\tab
\tab
\tab
\par
\pard\s32\plain\f1\fs20\sb60\fi-2880\li2880 DELETE\tab
\tab
\tab
\par
\pard\s32\plain\f1\fs20\sb60\fi-2880\li2880 ENDKEY\tab
\tab
\tab
\par
\pard\s32\plain\f1\fs20\sb60\fi-2880\li2880 ENTER\tab
\tab
\tab
\par
\pard\s32\plain\f1\fs20\sb60\fi-2880\li2880 ESC\tab
\tab
\tab
\tab
\par
\pard\s32\plain\f1\fs20\sb60\fi-2880\li2880 F1\tab
\tab
\tab
\tab
\par
\pard\s32\plain\f1\fs20\sb60\fi-2880\li2880 F2\tab
\tab
\tab
\tab
\par
\pard\s32\plain\f1\fs20\sb60\fi-2880\li2880 F3\tab
\tab
\tab
\tab
\par
\pard\s32\plain\f1\fs20\sb60\fi-2880\li2880 F4\tab
\tab
\tab
\tab
\par
\pard\s32\plain\f1\fs20\sb60\fi-2880\li2880 F5\tab
\tab
\tab
\tab
\par
\pard\s32\plain\f1\fs20\sb60\fi-2880\li2880 F6\tab
\tab
\tab
\tab
\par
\pard\s32\plain\f1\fs20\sb60\fi-2880\li2880 F7\tab
\tab
\tab
\tab
\par
\pard\s32\plain\f1\fs20\sb60\fi-2880\li2880 F8\tab
\tab
\tab
\tab
\par
\pard\s32\plain\f1\fs20\sb60\fi-2880\li2880 F9\tab
\tab
\tab
\tab
\par
\pard\s32\plain\f1\fs20\sb60\fi-2880\li2880 F10\tab
\tab
\tab
\tab
\par
\pard\s32\plain\f1\fs20\sb60\fi-2880\li2880 F11\tab
\tab
\tab
\tab
\par
\pard\s32\plain\f1\fs20\sb60\fi-2880\li2880 F12\tab
\tab
\tab
\tab
\par
\pard\s32\plain\f1\fs20\sb60\fi-2880\li2880 F13\tab
\tab
\tab
\tab
\par
\pard\s32\plain\f1\fs20\sb60\fi-2880\li2880 F14\tab
\tab
\tab
\tab
\par
\pard\s32\plain\f1\fs20\sb60\fi-2880\li2880 F15\tab
\tab
\tab
\tab
\par
\pard\s32\plain\f1\fs20\sb60\fi-2880\li2880 F16\tab
\tab
\tab
\tab
\par
\pard\s32\plain\f1\fs20\sb60\fi-2880\li2880 F17\tab
\tab
\tab
\tab
\par
\pard\s32\plain\f1\fs20\sb60\fi-2880\li2880 F18\tab
\tab
\tab
\tab
\par
\pard\s32\plain\f1\fs20\sb60\fi-2880\li2880 F19\tab
\tab
\tab
\tab
\par
\pard\s32\plain\f1\fs20\sb60\fi-2880\li2880 F20\tab
\tab
\tab
\tab
\par
\pard\s32\plain\f1\fs20\sb60\fi-2880\li2880 F21\tab
\tab
\tab
\tab
\par
\pard\s32\plain\f1\fs20\sb60\fi-2880\li2880 F22\tab
\tab
\tab
\tab
\par
\pard\s32\plain\f1\fs20\sb60\fi-2880\li2880 F23\tab
\tab
\tab
\tab
\par
\pard\s32\plain\f1\fs20\sb60\fi-2880\li2880 F24\tab
\tab
\tab
\tab
\par
\pard\s32\plain\f1\fs20\sb60\fi-2880\li2880 HOME\tab
\tab
\tab
\par
\pard\s32\plain\f1\fs20\sb60\fi-2880\li2880 INSERT\tab
\tab
\tab
\par
\pard\s32\plain\f1\fs20\sb60\fi-2880\li2880 PAGEDOWN\tab
\tab
\par
\pard\s32\plain\f1\fs20\sb60\fi-2880\li2880 PAGEUP\tab
\tab
\tab
\par
\pard\s32\plain\f1\fs20\sb60\fi-2880\li2880 TAB\tab
\tab
\tab
\tab
\par
\pard\s32\plain\f1\fs20\sb60\fi-2880\li2880 INPUTINVALID\tab
\par
\pard\s29\plain\li0\sb180\f1\fs24\b Procedures\par
\pard\s30\plain\li0\sb60\f1\fs20 {\strike\cf5 Bar}{\v ColorPlane_Bar}\par
{\strike\cf5 Box}{\v ColorPlane_Box}\par
{\strike\cf5 Clear}{\v ColorPlane_Clear}\par
{\strike\cf5 Close}{\v ColorPlane_Close}\par
{\strike\cf5 CursorOff}{\v ColorPlane_CursorOff}\par
{\strike\cf5 CursorOn}{\v ColorPlane_CursorOn}\par
{\strike\cf5 Dot}{\v ColorPlane_Dot}\par
{\strike\cf5 EditStr}{\v ColorPlane_EditStr}\par
{\strike\cf5 GetBackColor}{\v ColorPlane_GetBackColor}\par
{\strike\cf5 GetDot}{\v ColorPlane_GetDot}\par
{\strike\cf5 GetForeColor}{\v ColorPlane_GetForeColor}\par
{\strike\cf5 GetMouse}{\v ColorPlane_GetMouse}\par
{\strike\cf5 GotoXY}{\v ColorPlane_GotoXY}\par
{\strike\cf5 IsCursorOn}{\v ColorPlane_IsCursorOn}\par
{\strike\cf5 KeyPressed}{\v ColorPlane_KeyPressed}\par
{\strike\cf5 Line}{\v ColorPlane_Line}\par
{\strike\cf5 Open}{\v ColorPlane_Open}\par
{\strike\cf5 ReadKey}{\v ColorPlane_ReadKey}\par
{\strike\cf5 ReadStr}{\v ColorPlane_ReadStr}\par
{\strike\cf5 SetBackColor}{\v ColorPlane_SetBackColor}\par
{\strike\cf5 SetForeColor}{\v ColorPlane_SetForeColor}\par
{\strike\cf5 SetScreenUpdate}{\v ColorPlane_SetScreenUpdate}\par
{\strike\cf5 TextHeight}{\v ColorPlane_TextHeight}\par
{\strike\cf5 TextWidth}{\v ColorPlane_TextWidth}\par
{\strike\cf5 WhereX}{\v ColorPlane_WhereX}\par
{\strike\cf5 WhereY}{\v ColorPlane_WhereY}\par
{\strike\cf5 WriteLn}{\v ColorPlane_WriteLn}\par
{\strike\cf5 WriteStr}{\v ColorPlane_WriteStr}\par
\page
{\ {\super #}\footnote \pard\plain{\super #}ColorPlane_Bar}{\ {\super $}\footnote \pard\plain{\super 
$}ColorPlane.Bar}{\ {\super K}\footnote \pard\plain{\super K}Bar}\pard\s28\plain\li0\sb120\sa120\keepn\f1\fs28\b 
Bar\par
\pard\s31\plain\li0\sb120\sa120\f1\fs20\b defined in module {\strike\cf5 ColorPlane
}{\v ColorPlane}\par
\pard\s29\plain\li0\sb180\f1\fs24\b Syntax\par
\pard\s27\plain\li0\sb120\tx1702\f2\fs20 PROCEDURE Bar(x1, y1, x2, y2:INTEGER; \line

              mode:INTEGER)\par
\pard\s29\plain\li0\sb180\f1\fs24\b Description\par
\pard\s30\plain\li0\sb60\f1\fs20 Draws a filled rectangle where the left top corner is defined by the
 co-ordinate ({\b x1},{\b y1}) and the right bottom corner by ({\b x2},{\b y2}). 
{\b mode} determines whether the rectangle is drawn in the current foreground or background color. The value 
{\b DRAW} represents the foreground color, {\b ERASE} the background color. \par
\page
{\ {\super #}\footnote \pard\plain{\super #}ColorPlane_Box}{\ {\super $}\footnote \pard\plain{\super 
$}ColorPlane.Box}{\ {\super K}\footnote \pard\plain{\super K}Box}\pard\s28\plain\li0\sb120\sa120\keepn\f1\fs28\b 
Box\par
\pard\s31\plain\li0\sb120\sa120\f1\fs20\b defined in module {\strike\cf5 ColorPlane
}{\v ColorPlane}\par
\pard\s29\plain\li0\sb180\f1\fs24\b Syntax\par
\pard\s27\plain\li0\sb120\tx1702\f2\fs20 PROCEDURE Box(x1, y1, x2, y2:INTEGER; \line

              mode:INTEGER)\par
\pard\s29\plain\li0\sb180\f1\fs24\b Description\par
\pard\s30\plain\li0\sb60\f1\fs20 Draws a rectangle where the left top corner is defined by the
 co-ordinates ({\b x1},{\b y1}) and the right bottom corner by ({\b x2},{\b y2}).
 {\b mode} determines whether the rectangle is drawn in the current foreground or background color. The value 
{\b DRAW} represents the foreground color, {\b ERASE} the background color. \par
\page
{\ {\super #}\footnote \pard\plain{\super #}ColorPlane_Clear}{\ {\super $}\footnote \pard\plain{\super 
$}ColorPlane.Clear}{\ {\super K}\footnote \pard\plain{\super K}Clear}\pard\s28\plain\li0\sb120\sa120\keepn\f1\fs28\b 
Clear\par
\pard\s31\plain\li0\sb120\sa120\f1\fs20\b defined in module {\strike\cf5 ColorPlane
}{\v ColorPlane}\par
\pard\s29\plain\li0\sb180\f1\fs24\b Syntax\par
\pard\s27\plain\li0\sb120\tx1702\f2\fs20 PROCEDURE Clear()\par
\pard\s29\plain\li0\sb180\f1\fs24\b Description\par
\pard\s30\plain\li0\sb60\f1\fs20 The whole drawing area is cleared, or in other words, set to the
 current background color. \par
\page
{\ {\super #}\footnote \pard\plain{\super #}ColorPlane_Close}{\ {\super $}\footnote \pard\plain{\super 
$}ColorPlane.Close}{\ {\super K}\footnote \pard\plain{\super K}Close}\pard\s28\plain\li0\sb120\sa120\keepn\f1\fs28\b 
Close\par
\pard\s31\plain\li0\sb120\sa120\f1\fs20\b defined in module {\strike\cf5 ColorPlane
}{\v ColorPlane}\par
\pard\s29\plain\li0\sb180\f1\fs24\b Syntax\par
\pard\s27\plain\li0\sb120\tx1702\f2\fs20 PROCEDURE Close()\par
\pard\s29\plain\li0\sb180\f1\fs24\b Description\par
\pard\s30\plain\li0\sb60\f1\fs20 The display area for the graphics is closed. The free space in the
 program window is divided for the remaining output areas (e.g., for the modules 
{\b Display} or {\b Out}). \par
\page
{\ {\super #}\footnote \pard\plain{\super #}ColorPlane_CursorOff}{\ {\super $}\footnote \pard\plain{\super 
$}ColorPlane.CursorOff}{\ {\super K}\footnote \pard\plain{\super K}CursorOff}\pard\s28
\plain\li0\sb120\sa120\keepn\f1\fs28\b CursorOff\par
\pard\s31\plain\li0\sb120\sa120\f1\fs20\b defined in module {\strike\cf5 ColorPlane
}{\v ColorPlane}\par
\pard\s29\plain\li0\sb180\f1\fs24\b Syntax\par
\pard\s27\plain\li0\sb120\tx1702\f2\fs20 PROCEDURE CursorOff()\par
\pard\s29\plain\li0\sb180\f1\fs24\b Description\par
\pard\s30\plain\li0\sb60\f1\fs20 The cursor becomes invisible. Its position and function remain unchanged. 
\par
\page
{\ {\super #}\footnote \pard\plain{\super #}ColorPlane_CursorOn}{\ {\super $}\footnote \pard\plain{\super 
$}ColorPlane.CursorOn}{\ {\super K}\footnote \pard\plain{\super K}CursorOn}\pard\s28
\plain\li0\sb120\sa120\keepn\f1\fs28\b CursorOn\par
\pard\s31\plain\li0\sb120\sa120\f1\fs20\b defined in module {\strike\cf5 ColorPlane
}{\v ColorPlane}\par
\pard\s29\plain\li0\sb180\f1\fs24\b Syntax\par
\pard\s27\plain\li0\sb120\tx1702\f2\fs20 PROCEDURE CursorOn()\par
\pard\s29\plain\li0\sb180\f1\fs24\b Description\par
\pard\s30\plain\li0\sb60\f1\fs20 The cursor is displayed. \par
\page
{\ {\super #}\footnote \pard\plain{\super #}ColorPlane_Dot}{\ {\super $}\footnote \pard\plain{\super 
$}ColorPlane.Dot}{\ {\super K}\footnote \pard\plain{\super K}Dot}\pard\s28\plain\li0\sb120\sa120\keepn\f1\fs28\b 
Dot\par
\pard\s31\plain\li0\sb120\sa120\f1\fs20\b defined in module {\strike\cf5 ColorPlane
}{\v ColorPlane}\par
\pard\s29\plain\li0\sb180\f1\fs24\b Syntax\par
\pard\s27\plain\li0\sb120\tx1702\f2\fs20 PROCEDURE Dot(x, y:INTEGER; \line
              mode:INTEGER)\par
\pard\s29\plain\li0\sb180\f1\fs24\b Description\par
\pard\s30\plain\li0\sb60\f1\fs20 Draws a dot at the co-ordinate (x,y). The value DRAW for mode draws the
 dot in the current foreground color and ERASE selects the background color. \par

\page
{\ {\super #}\footnote \pard\plain{\super #}ColorPlane_EditStr}{\ {\super $}\footnote \pard\plain{\super 
$}ColorPlane.EditStr}{\ {\super K}\footnote \pard\plain{\super K}EditStr}\pard\s28
\plain\li0\sb120\sa120\keepn\f1\fs28\b EditStr\par
\pard\s31\plain\li0\sb120\sa120\f1\fs20\b defined in module {\strike\cf5 ColorPlane
}{\v ColorPlane}\par
\pard\s29\plain\li0\sb180\f1\fs24\b Syntax\par
\pard\s27\plain\li0\sb120\tx1702\f2\fs20 PROCEDURE EditStr(VAR aString:ARRAY OF CHAR
; \line
                  maxLen:INTEGER; \line
                  VAR resCode:CHAR)\par
\pard\s29\plain\li0\sb180\f1\fs24\b Description\par
\pard\s30\plain\li0\sb60\f1\fs20 The text passed in {\b aString} is displayed, then the cursor is displayed and
 an input from the keyboard is awaited. The input line may be edited using the delete, cursor left, and cursor right keys. The entered string is shown on
 the screen.\par
The maximum length of the input is limited by the length of the array passed in {\b 
aString}. In addition, it may be limited by {\b maxLen}. The input may be finished by using the enter or the escape key.
\par
The code of the terminating key used is returned in {\b resCode}.  \par
\page
{\ {\super #}\footnote \pard\plain{\super #}ColorPlane_GetBackColor}{\ {\super $}\footnote \pard\plain{\super 
$}ColorPlane.GetBackColor}{\ {\super K}\footnote \pard\plain{\super K}GetBackColor
}\pard\s28\plain\li0\sb120\sa120\keepn\f1\fs28\b GetBackColor\par
\pard\s31\plain\li0\sb120\sa120\f1\fs20\b defined in module {\strike\cf5 ColorPlane
}{\v ColorPlane}\par
\pard\s29\plain\li0\sb180\f1\fs24\b Syntax\par
\pard\s27\plain\li0\sb120\tx1702\f2\fs20 PROCEDURE GetBackColor(VAR red, green, blue
:INTEGER)\par
\pard\s29\plain\li0\sb180\f1\fs24\b Description\par
\pard\s30\plain\li0\sb60\f1\fs20 The current background color values are returned in 
{\b red}, {\b green}, and {\b blue}. \par
\page
{\ {\super #}\footnote \pard\plain{\super #}ColorPlane_GetDot}{\ {\super $}\footnote \pard\plain{\super 
$}ColorPlane.GetDot}{\ {\super K}\footnote \pard\plain{\super K}GetDot}\pard\s28\plain\li0\sb120\sa120\keepn\f1\fs28\b 
GetDot\par
\pard\s31\plain\li0\sb120\sa120\f1\fs20\b defined in module {\strike\cf5 ColorPlane
}{\v ColorPlane}\par
\pard\s29\plain\li0\sb180\f1\fs24\b Syntax\par
\pard\s27\plain\li0\sb120\tx1702\f2\fs20 PROCEDURE GetDot(x, y:INTEGER; \line
                 VAR r, g, b:INTEGER)\par
\pard\s29\plain\li0\sb180\f1\fs24\b Description\par
\pard\s30\plain\li0\sb60\f1\fs20 The actual color of the point with the co-ordinate (
{\b x},{\b y}) is returned, separated into red, green, and blue components. If the system does not
 support true-color display the color reported by GetDot may deviate from the color values previously passed to SetDot. 
\par
\page
{\ {\super #}\footnote \pard\plain{\super #}ColorPlane_GetForeColor}{\ {\super $}\footnote \pard\plain{\super 
$}ColorPlane.GetForeColor}{\ {\super K}\footnote \pard\plain{\super K}GetForeColor
}\pard\s28\plain\li0\sb120\sa120\keepn\f1\fs28\b GetForeColor\par
\pard\s31\plain\li0\sb120\sa120\f1\fs20\b defined in module {\strike\cf5 ColorPlane
}{\v ColorPlane}\par
\pard\s29\plain\li0\sb180\f1\fs24\b Syntax\par
\pard\s27\plain\li0\sb120\tx1702\f2\fs20 PROCEDURE GetForeColor(VAR red, green, blue
:INTEGER)\par
\pard\s29\plain\li0\sb180\f1\fs24\b Description\par
\pard\s30\plain\li0\sb60\f1\fs20 The current foreground color values are returned in 
{\b red}, {\b green}, and {\b blue}. \par
\page
{\ {\super #}\footnote \pard\plain{\super #}ColorPlane_GetMouse}{\ {\super $}\footnote \pard\plain{\super 
$}ColorPlane.GetMouse}{\ {\super K}\footnote \pard\plain{\super K}GetMouse}\pard\s28
\plain\li0\sb120\sa120\keepn\f1\fs28\b GetMouse\par
\pard\s31\plain\li0\sb120\sa120\f1\fs20\b defined in module {\strike\cf5 ColorPlane
}{\v ColorPlane}\par
\pard\s29\plain\li0\sb180\f1\fs24\b Syntax\par
\pard\s27\plain\li0\sb120\tx1702\f2\fs20 PROCEDURE GetMouse(VAR buttons:SET; \line

                   VAR x, y:INTEGER)\par
\pard\s29\plain\li0\sb180\f1\fs24\b Description\par
\pard\s30\plain\li0\sb60\f1\fs20 The co-ordinates of the current mouse position are returned in 
{\b x} and {\b y}. The mouse buttons currently pressed are returned in {\b buttons
}. The following coding is used:\par
0 = left button\par
1 = central button\par
2 = right button\par
The mouse pointer may also be located outside the possible drawing area. In this situation at least one mouse co-ordinate is either less than zero
 or more than or equal to the corresponding {\b RESOLUTION} constant. \par
\page
{\ {\super #}\footnote \pard\plain{\super #}ColorPlane_GotoXY}{\ {\super $}\footnote \pard\plain{\super 
$}ColorPlane.GotoXY}{\ {\super K}\footnote \pard\plain{\super K}GotoXY}\pard\s28\plain\li0\sb120\sa120\keepn\f1\fs28\b 
GotoXY\par
\pard\s31\plain\li0\sb120\sa120\f1\fs20\b defined in module {\strike\cf5 ColorPlane
}{\v ColorPlane}\par
\pard\s29\plain\li0\sb180\f1\fs24\b Syntax\par
\pard\s27\plain\li0\sb120\tx1702\f2\fs20 PROCEDURE GotoXY(x, y:INTEGER)\par
\pard\s29\plain\li0\sb180\f1\fs24\b Description\par
\pard\s30\plain\li0\sb60\f1\fs20 The cursor is set to the co-ordinate ({\b x},{\b 
y}) position. \par
\page
{\ {\super #}\footnote \pard\plain{\super #}ColorPlane_IsCursorOn}{\ {\super $}\footnote \pard\plain{\super 
$}ColorPlane.IsCursorOn}{\ {\super K}\footnote \pard\plain{\super K}IsCursorOn}\pard\s28
\plain\li0\sb120\sa120\keepn\f1\fs28\b IsCursorOn\par
\pard\s31\plain\li0\sb120\sa120\f1\fs20\b defined in module {\strike\cf5 ColorPlane
}{\v ColorPlane}\par
\pard\s29\plain\li0\sb180\f1\fs24\b Syntax\par
\pard\s27\plain\li0\sb120\tx1702\f2\fs20 PROCEDURE IsCursorOn():BOOLEAN\par
\pard\s29\plain\li0\sb180\f1\fs24\b Description\par
\pard\s30\plain\li0\sb60\f1\fs20 The return value of this function is TRUE if the cursor is visible. 
\par
\page
{\ {\super #}\footnote \pard\plain{\super #}ColorPlane_KeyPressed}{\ {\super $}\footnote \pard\plain{\super 
$}ColorPlane.KeyPressed}{\ {\super K}\footnote \pard\plain{\super K}KeyPressed}\pard\s28
\plain\li0\sb120\sa120\keepn\f1\fs28\b KeyPressed\par
\pard\s31\plain\li0\sb120\sa120\f1\fs20\b defined in module {\strike\cf5 ColorPlane
}{\v ColorPlane}\par
\pard\s29\plain\li0\sb180\f1\fs24\b Syntax\par
\pard\s27\plain\li0\sb120\tx1702\f2\fs20 PROCEDURE KeyPressed():BOOLEAN\par
\pard\s29\plain\li0\sb180\f1\fs24\b Description\par
\pard\s30\plain\li0\sb60\f1\fs20 The return value of the function is TRUE if a key was pressed;
 the corresponding code is stored in the keyboard buffer and may be read by calling ReadKey. 
\par
\page
{\ {\super #}\footnote \pard\plain{\super #}ColorPlane_Line}{\ {\super $}\footnote \pard\plain{\super 
$}ColorPlane.Line}{\ {\super K}\footnote \pard\plain{\super K}Line}\pard\s28\plain\li0\sb120\sa120\keepn\f1\fs28\b 
Line\par
\pard\s31\plain\li0\sb120\sa120\f1\fs20\b defined in module {\strike\cf5 ColorPlane
}{\v ColorPlane}\par
\pard\s29\plain\li0\sb180\f1\fs24\b Syntax\par
\pard\s27\plain\li0\sb120\tx1702\f2\fs20 PROCEDURE Line(x1, y1, x2, y2, mode:INTEGER
)\par
\pard\s29\plain\li0\sb180\f1\fs24\b Description\par
\pard\s30\plain\li0\sb60\f1\fs20 Draws a line starting from the co-ordinate ({\b 
x1},{\b y1}) to the co-ordinate ({\b x2},{\b y2}). {\b mode} determines whether the line is drawn in the current
 foreground or background color. The value {\b DRAW} represents the foreground color, 
{\b ERASE} the background color. \par
\page
{\ {\super #}\footnote \pard\plain{\super #}ColorPlane_Open}{\ {\super $}\footnote \pard\plain{\super 
$}ColorPlane.Open}{\ {\super K}\footnote \pard\plain{\super K}Open}\pard\s28\plain\li0\sb120\sa120\keepn\f1\fs28\b 
Open\par
\pard\s31\plain\li0\sb120\sa120\f1\fs20\b defined in module {\strike\cf5 ColorPlane
}{\v ColorPlane}\par
\pard\s29\plain\li0\sb180\f1\fs24\b Syntax\par
\pard\s27\plain\li0\sb120\tx1702\f2\fs20 PROCEDURE Open()\par
\pard\s29\plain\li0\sb180\f1\fs24\b Description\par
\pard\s30\plain\li0\sb60\f1\fs20 The display area for the graphics is created in the program window.
 This function must be called before any other function in the module as it provides the initialization. 
\par
\page
{\ {\super #}\footnote \pard\plain{\super #}ColorPlane_ReadKey}{\ {\super $}\footnote \pard\plain{\super 
$}ColorPlane.ReadKey}{\ {\super K}\footnote \pard\plain{\super K}ReadKey}\pard\s28
\plain\li0\sb120\sa120\keepn\f1\fs28\b ReadKey\par
\pard\s31\plain\li0\sb120\sa120\f1\fs20\b defined in module {\strike\cf5 ColorPlane
}{\v ColorPlane}\par
\pard\s29\plain\li0\sb180\f1\fs24\b Syntax\par
\pard\s27\plain\li0\sb120\tx1702\f2\fs20 PROCEDURE ReadKey():CHAR\par
\pard\s29\plain\li0\sb180\f1\fs24\b Description\par
\pard\s30\plain\li0\sb60\f1\fs20 This function waits for the next key and returns its character value.
 This character is not displayed on the screen. If the key cannot be represented by an ASCII code, the result of the function is initially
 zero. The next call of the function returns a code which identifies a special key (e.g., the function keys or the cursor keys). 
\par
\page
{\ {\super #}\footnote \pard\plain{\super #}ColorPlane_ReadStr}{\ {\super $}\footnote \pard\plain{\super 
$}ColorPlane.ReadStr}{\ {\super K}\footnote \pard\plain{\super K}ReadStr}\pard\s28
\plain\li0\sb120\sa120\keepn\f1\fs28\b ReadStr\par
\pard\s31\plain\li0\sb120\sa120\f1\fs20\b defined in module {\strike\cf5 ColorPlane
}{\v ColorPlane}\par
\pard\s29\plain\li0\sb180\f1\fs24\b Syntax\par
\pard\s27\plain\li0\sb120\tx1702\f2\fs20 PROCEDURE ReadStr(VAR aString:ARRAY OF CHAR
; \line
                  maxLen:INTEGER; \line
                  VAR resCode:CHAR)\par
\pard\s29\plain\li0\sb180\f1\fs24\b Parameters\par
\pard\s32\plain\f1\fs20\sb60\fi-2880\li2880 aString\tab
\tab
\tab
\pard\s32\plain\f1\fs20\sb60\fi-2880\li2880 returns the result \par
\pard\s32\plain\f1\fs20\sb60\fi-2880\li2880 maxLen\tab
\tab
\tab
\pard\s32\plain\f1\fs20\sb60\fi-2880\li2880 limits the length of the input \par
\pard\s32\plain\f1\fs20\sb60\fi-2880\li2880 resCode\tab
\tab
\tab
\pard\s32\plain\f1\fs20\sb60\fi-2880\li2880 set to either {\b ENTER} or {\b ESC},
 see the text below \par
\pard\s29\plain\li0\sb180\f1\fs24\b Description\par
\pard\s30\plain\li0\sb60\f1\fs20 The cursor is displayed and the procedure waits for key input. The string
 that is entered is displayed on the screen. The maximum length of the input string is limited by the length of the
 array passed in {\b aString}. In addition to this, it may be limited by {\b maxLen
}. The input action can be terminated with either the enter and the escape key. In the first case the value 
{\b ENTER} is returned in {\b resCode}, in the second the value {\b ESC}. \par
\page
{\ {\super #}\footnote \pard\plain{\super #}ColorPlane_SetBackColor}{\ {\super $}\footnote \pard\plain{\super 
$}ColorPlane.SetBackColor}{\ {\super K}\footnote \pard\plain{\super K}SetBackColor
}\pard\s28\plain\li0\sb120\sa120\keepn\f1\fs28\b SetBackColor\par
\pard\s31\plain\li0\sb120\sa120\f1\fs20\b defined in module {\strike\cf5 ColorPlane
}{\v ColorPlane}\par
\pard\s29\plain\li0\sb180\f1\fs24\b Syntax\par
\pard\s27\plain\li0\sb120\tx1702\f2\fs20 PROCEDURE SetBackColor(red, green, blue:
INTEGER)\par
\pard\s29\plain\li0\sb180\f1\fs24\b Description\par
\pard\s30\plain\li0\sb60\f1\fs20 The new background color is set. The color is defined by the red,
 green, and blue values contained in {\b red}, {\b green}, and {\b blue}. The color values range from 0 to 255.
\par
If the system cannot provide the desired color then the nearest available color is selected. 
\par
\page
{\ {\super #}\footnote \pard\plain{\super #}ColorPlane_SetForeColor}{\ {\super $}\footnote \pard\plain{\super 
$}ColorPlane.SetForeColor}{\ {\super K}\footnote \pard\plain{\super K}SetForeColor
}\pard\s28\plain\li0\sb120\sa120\keepn\f1\fs28\b SetForeColor\par
\pard\s31\plain\li0\sb120\sa120\f1\fs20\b defined in module {\strike\cf5 ColorPlane
}{\v ColorPlane}\par
\pard\s29\plain\li0\sb180\f1\fs24\b Syntax\par
\pard\s27\plain\li0\sb120\tx1702\f2\fs20 PROCEDURE SetForeColor(red, green, blue:
INTEGER)\par
\pard\s29\plain\li0\sb180\f1\fs24\b Description\par
\pard\s30\plain\li0\sb60\f1\fs20 Sets the new foreground color for all subsequent drawing operations.
 The color is defined by the red, green, and blue values contained in {\b red}, {\b 
green}, and {\b blue}. The color values range from 0 to 255.\par
If the system cannot provide the desired color then the nearest available color is selected. 
\par
\page
{\ {\super #}\footnote \pard\plain{\super #}ColorPlane_SetScreenUpdate}{\ {\super 
$}\footnote \pard\plain{\super $}ColorPlane.SetScreenUpdate}{\ {\super K}\footnote \pard\plain{\super 
K}SetScreenUpdate}\pard\s28\plain\li0\sb120\sa120\keepn\f1\fs28\b SetScreenUpdate
\par
\pard\s31\plain\li0\sb120\sa120\f1\fs20\b defined in module {\strike\cf5 ColorPlane
}{\v ColorPlane}\par
\pard\s29\plain\li0\sb180\f1\fs24\b Syntax\par
\pard\s27\plain\li0\sb120\tx1702\f2\fs20 PROCEDURE SetScreenUpdate(x:BOOLEAN)\par

\pard\s29\plain\li0\sb180\f1\fs24\b Description\par
\pard\s30\plain\li0\sb60\f1\fs20 This function inhibits drawing visibly on the screen if 
{\b x} is FALSE; if TRUE then drawing is as normal. When the update is re-enabled again all changes that have taken place
 in the meantime are displayed automatically. \par
\page
{\ {\super #}\footnote \pard\plain{\super #}ColorPlane_TextHeight}{\ {\super $}\footnote \pard\plain{\super 
$}ColorPlane.TextHeight}{\ {\super K}\footnote \pard\plain{\super K}TextHeight}\pard\s28
\plain\li0\sb120\sa120\keepn\f1\fs28\b TextHeight\par
\pard\s31\plain\li0\sb120\sa120\f1\fs20\b defined in module {\strike\cf5 ColorPlane
}{\v ColorPlane}\par
\pard\s29\plain\li0\sb180\f1\fs24\b Syntax\par
\pard\s27\plain\li0\sb120\tx1702\f2\fs20 PROCEDURE TextHeight():INTEGER\par
\pard\s29\plain\li0\sb180\f1\fs24\b Description\par
\pard\s30\plain\li0\sb60\f1\fs20 The return value of this function is the height of the character set (font)
 currently in use. \par
\page
{\ {\super #}\footnote \pard\plain{\super #}ColorPlane_TextWidth}{\ {\super $}\footnote \pard\plain{\super 
$}ColorPlane.TextWidth}{\ {\super K}\footnote \pard\plain{\super K}TextWidth}\pard\s28
\plain\li0\sb120\sa120\keepn\f1\fs28\b TextWidth\par
\pard\s31\plain\li0\sb120\sa120\f1\fs20\b defined in module {\strike\cf5 ColorPlane
}{\v ColorPlane}\par
\pard\s29\plain\li0\sb180\f1\fs24\b Syntax\par
\pard\s27\plain\li0\sb120\tx1702\f2\fs20 PROCEDURE TextWidth(VAR txt:ARRAY OF CHAR
):INTEGER\par
\pard\s29\plain\li0\sb180\f1\fs24\b Description\par
\pard\s30\plain\li0\sb60\f1\fs20 The return value of this function is the width of the string 
{\b txt} if it were written with the character set currently in use. \par
\page
{\ {\super #}\footnote \pard\plain{\super #}ColorPlane_WhereX}{\ {\super $}\footnote \pard\plain{\super 
$}ColorPlane.WhereX}{\ {\super K}\footnote \pard\plain{\super K}WhereX}\pard\s28\plain\li0\sb120\sa120\keepn\f1\fs28\b 
WhereX\par
\pard\s31\plain\li0\sb120\sa120\f1\fs20\b defined in module {\strike\cf5 ColorPlane
}{\v ColorPlane}\par
\pard\s29\plain\li0\sb180\f1\fs24\b Syntax\par
\pard\s27\plain\li0\sb120\tx1702\f2\fs20 PROCEDURE WhereX():INTEGER\par
\pard\s29\plain\li0\sb180\f1\fs24\b Description\par
\pard\s30\plain\li0\sb60\f1\fs20 The return value of this function is the X-co-ordinate of the cursor
 position. \par
\page
{\ {\super #}\footnote \pard\plain{\super #}ColorPlane_WhereY}{\ {\super $}\footnote \pard\plain{\super 
$}ColorPlane.WhereY}{\ {\super K}\footnote \pard\plain{\super K}WhereY}\pard\s28\plain\li0\sb120\sa120\keepn\f1\fs28\b 
WhereY\par
\pard\s31\plain\li0\sb120\sa120\f1\fs20\b defined in module {\strike\cf5 ColorPlane
}{\v ColorPlane}\par
\pard\s29\plain\li0\sb180\f1\fs24\b Syntax\par
\pard\s27\plain\li0\sb120\tx1702\f2\fs20 PROCEDURE WhereY():INTEGER\par
\pard\s29\plain\li0\sb180\f1\fs24\b Description\par
\pard\s30\plain\li0\sb60\f1\fs20 The return value of this function is the Y-co-ordinate of the cursor
 position. \par
\page
{\ {\super #}\footnote \pard\plain{\super #}ColorPlane_WriteLn}{\ {\super $}\footnote \pard\plain{\super 
$}ColorPlane.WriteLn}{\ {\super K}\footnote \pard\plain{\super K}WriteLn}\pard\s28
\plain\li0\sb120\sa120\keepn\f1\fs28\b WriteLn\par
\pard\s31\plain\li0\sb120\sa120\f1\fs20\b defined in module {\strike\cf5 ColorPlane
}{\v ColorPlane}\par
\pard\s29\plain\li0\sb180\f1\fs24\b Syntax\par
\pard\s27\plain\li0\sb120\tx1702\f2\fs20 PROCEDURE WriteLn()\par
\pard\s29\plain\li0\sb180\f1\fs24\b Description\par
\pard\s30\plain\li0\sb60\f1\fs20 The cursor is moved to the left edge of the drawing region and then
 one text line down (i.e., the height of the character set in use). \par
\page
{\ {\super #}\footnote \pard\plain{\super #}ColorPlane_WriteStr}{\ {\super $}\footnote \pard\plain{\super 
$}ColorPlane.WriteStr}{\ {\super K}\footnote \pard\plain{\super K}WriteStr}\pard\s28
\plain\li0\sb120\sa120\keepn\f1\fs28\b WriteStr\par
\pard\s31\plain\li0\sb120\sa120\f1\fs20\b defined in module {\strike\cf5 ColorPlane
}{\v ColorPlane}\par
\pard\s29\plain\li0\sb180\f1\fs24\b Syntax\par
\pard\s27\plain\li0\sb120\tx1702\f2\fs20 PROCEDURE WriteStr(txt:ARRAY OF CHAR)\par

\pard\s29\plain\li0\sb180\f1\fs24\b Description\par
\pard\s30\plain\li0\sb60\f1\fs20 The string {\b txt} is written to the screen starting at the cursor position,
 and results in the cursor being moved to the end of the output. If the left edge of the drawing area is reached then the output is truncated.
 A carriage return/line feed is not provided automatically. \par
\page
}
